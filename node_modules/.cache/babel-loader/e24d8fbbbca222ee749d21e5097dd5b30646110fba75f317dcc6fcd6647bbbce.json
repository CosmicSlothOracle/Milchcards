{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\skank\\\\Videos\\\\Cards\\\\Milchcards\\\\src\\\\components\\\\Dice3D.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useImperativeHandle, forwardRef, useCallback } from 'react';\nimport * as THREE from 'three';\nimport gsap from 'gsap';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n/**\n * Dice3D â€“ simple WebGL dice rendered with three.js\n * Usage:\n *   const diceRef = useRef<Dice3DHandle>(null);\n *   <Dice3D ref={diceRef} onRoll={(f)=>console.log(f)}/>\n *   diceRef.current?.roll();\n */\nconst Dice3D = /*#__PURE__*/_s(/*#__PURE__*/forwardRef(_c = _s(({\n  size = 180,\n  duration = 1200,\n  onRoll,\n  className,\n  spinOnly = true\n}, ref) => {\n  _s();\n  const canvasRef = useRef(null);\n  const sceneRef = useRef();\n  const cubeRef = useRef();\n  const rendererRef = useRef();\n  const cameraRef = useRef();\n  const animIdRef = useRef(0);\n  const lastRequestRef = useRef(null);\n  const isSettledRef = useRef(true); // when true, dice remain static until next roll\n\n  /** helper to create a texture with pips */\n  const createFaceTexture = face => {\n    const size = 128;\n    const cvs = document.createElement('canvas');\n    cvs.width = cvs.height = size;\n    const ctx = cvs.getContext('2d');\n    ctx.fillStyle = '#fff';\n    ctx.fillRect(0, 0, size, size);\n    ctx.fillStyle = '#111';\n    const dot = (x, y) => {\n      ctx.beginPath();\n      ctx.arc(x, y, size * 0.1, 0, Math.PI * 2);\n      ctx.fill();\n    };\n    const g = size * 0.25;\n    const centers = {\n      1: [[size / 2, size / 2]],\n      2: [[g, g], [size - g, size - g]],\n      3: [[g, g], [size / 2, size / 2], [size - g, size - g]],\n      4: [[g, g], [size - g, g], [g, size - g], [size - g, size - g]],\n      5: [[g, g], [size - g, g], [size / 2, size / 2], [g, size - g], [size - g, size - g]],\n      6: [[g, g], [size - g, g], [g, size / 2], [size - g, size / 2], [g, size - g], [size - g, size - g]]\n    };\n    centers[face].forEach(([x, y]) => dot(x, y));\n    const tex = new THREE.CanvasTexture(cvs);\n    tex.needsUpdate = true;\n    return tex;\n  };\n\n  // initialize three scene\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x000000);\n    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);\n    camera.position.z = 4;\n    const renderer = new THREE.WebGLRenderer({\n      canvas,\n      antialias: true,\n      alpha: true\n    });\n    renderer.setSize(size, size);\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n    // lights\n    const ambient = new THREE.AmbientLight(0xffffff, 0.6);\n    scene.add(ambient);\n    const dir = new THREE.DirectionalLight(0xffffff, 1.0);\n    dir.position.set(5, 10, 7);\n    dir.castShadow = true;\n    dir.shadow.mapSize.width = 1024;\n    dir.shadow.mapSize.height = 1024;\n    dir.shadow.camera.left = -5;\n    dir.shadow.camera.right = 5;\n    dir.shadow.camera.top = 5;\n    dir.shadow.camera.bottom = -5;\n    scene.add(dir);\n\n    // ground plane to receive shadow\n    const planeGeo = new THREE.PlaneGeometry(10, 10);\n    const planeMat = new THREE.ShadowMaterial({\n      opacity: 0.35\n    });\n    const plane = new THREE.Mesh(planeGeo, planeMat);\n    plane.rotation.x = -Math.PI / 2;\n    plane.position.y = -1.1;\n    plane.receiveShadow = true;\n    scene.add(plane);\n\n    // Create a simple procedural equirectangular-like texture for subtle reflections\n    let generatedEnvMap = null;\n    try {\n      const envCanvas = document.createElement('canvas');\n      envCanvas.width = envCanvas.height = 256;\n      const ectx = envCanvas.getContext('2d');\n      // simple radial gradient\n      const grad = ectx.createRadialGradient(128, 128, 20, 128, 128, 140);\n      grad.addColorStop(0, '#ffffff');\n      grad.addColorStop(0.5, '#ccccff');\n      grad.addColorStop(1, '#556688');\n      ectx.fillStyle = grad;\n      ectx.fillRect(0, 0, 256, 256);\n      const envTex = new THREE.CanvasTexture(envCanvas);\n      envTex.mapping = THREE.EquirectangularReflectionMapping;\n      const pmremGen = new THREE.PMREMGenerator(renderer);\n      pmremGen.compileEquirectangularShader();\n      generatedEnvMap = pmremGen.fromEquirectangular(envTex).texture;\n      scene.environment = generatedEnvMap;\n    } catch (e) {\n      // ignore if PMREM not supported in environment\n      generatedEnvMap = null;\n    }\n\n    // cube\n    const materials = [1, 2, 3, 4, 5, 6].map(f => new THREE.MeshStandardMaterial({\n      map: createFaceTexture(f),\n      metalness: 0.4,\n      roughness: 0.25,\n      envMapIntensity: 1.0\n    }));\n    const geometry = new THREE.BoxGeometry(2, 2, 2);\n    const cube = new THREE.Mesh(geometry, materials);\n    cube.castShadow = true;\n    cube.receiveShadow = false;\n    scene.add(cube);\n\n    // If we generated an environment map, apply it to materials for reflections\n    if (generatedEnvMap) {\n      try {\n        materials.forEach(m => {\n          m.envMap = generatedEnvMap;\n          m.envMapIntensity = 0.8;\n          m.needsUpdate = true;\n        });\n      } catch (e) {}\n    }\n    sceneRef.current = scene;\n    cubeRef.current = cube;\n    rendererRef.current = renderer;\n    cameraRef.current = camera;\n\n    // Ensure canvas is anchored bottom-right and has no initial transform\n    try {\n      const el = canvas;\n      el.style.position = 'fixed';\n      el.style.right = '20px';\n      el.style.bottom = '20px';\n      el.style.left = '';\n      el.style.top = '';\n      el.style.transform = '';\n      el.style.transition = '';\n    } catch (e) {}\n\n    // animation loop\n    // previous rotation for motion-blur estimation\n    const prevRot = {\n      x: 0,\n      y: 0,\n      z: 0\n    };\n    const animate = () => {\n      animIdRef.current = requestAnimationFrame(animate);\n      // subtle idle rotate\n      if (cube) {\n        // only apply subtle idle motion while an active roll timeline is running\n        if (!isSettledRef.current) {\n          cube.rotation.x *= 0.995;\n          cube.rotation.y *= 0.995;\n\n          // compute angular velocity\n          const dx = cube.rotation.x - prevRot.x;\n          const dy = cube.rotation.y - prevRot.y;\n          const dz = cube.rotation.z - prevRot.z;\n          const angSpeed = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n          // map angular speed to CSS blur (px)\n          const blurPx = Math.min(12, angSpeed * 120);\n          try {\n            const el = canvas;\n            if (el && el.style) {\n              el.style.filter = blurPx > 0.3 ? `blur(${blurPx.toFixed(2)}px)` : 'none';\n            }\n          } catch (e) {}\n          prevRot.x = cube.rotation.x;\n          prevRot.y = cube.rotation.y;\n          prevRot.z = cube.rotation.z;\n        } else {\n          // settled: ensure no blur and reset prevRot\n          try {\n            const el = canvas;\n            if (el && el.style) el.style.filter = 'none';\n          } catch (e) {}\n          prevRot.x = cube.rotation.x;\n          prevRot.y = cube.rotation.y;\n          prevRot.z = cube.rotation.z;\n        }\n      }\n      renderer.render(scene, camera);\n    };\n    animate();\n    return () => {\n      cancelAnimationFrame(animIdRef.current);\n      renderer.dispose();\n    };\n  }, [size]);\n\n  // roll logic (includes DOM motion)\n  const rollInternal = useCallback(targetFace => {\n    if (!cubeRef.current) return;\n    const cube = cubeRef.current;\n    // pick target if not provided\n    const face = targetFace !== null && targetFace !== void 0 ? targetFace : 1 + Math.floor(Math.random() * 6);\n\n    // orientation map: face -> Euler rotation (approx)\n    const orientations = {\n      1: [0, 0, 0],\n      2: [0, Math.PI / 2, 0],\n      3: [-Math.PI / 2, 0, 0],\n      4: [Math.PI / 2, 0, 0],\n      5: [0, -Math.PI / 2, 0],\n      6: [Math.PI, 0, 0]\n    };\n    const [tx, ty, tz] = orientations[face];\n    const start = {\n      x: cube.rotation.x,\n      y: cube.rotation.y,\n      z: cube.rotation.z\n    };\n    const end = {\n      x: tx + 2 * Math.PI,\n      y: ty + 2 * Math.PI,\n      z: tz + 2 * Math.PI\n    };\n\n    // Ensure any previous rotation tweens on cube are killed so they can't override final orientation\n    try {\n      if (cube) {\n        gsap.killTweensOf(cube);\n        gsap.killTweensOf(cube.rotation);\n      }\n    } catch (e) {}\n    // Use GSAP timeline for smooth rotation + bounces and DOM motion\n    const timeline = gsap.timeline({\n      onStart: () => {\n        // mark as active so idle loop applies motion\n        try {\n          isSettledRef.current = false;\n        } catch (e) {}\n      },\n      onComplete: () => {\n        // explicitly kill any remaining tweens affecting cube and set final orientation\n        try {\n          if (cube) {\n            gsap.killTweensOf(cube);\n            gsap.killTweensOf(cube.rotation);\n          }\n        } catch (e) {}\n        cube.rotation.set(tx, ty, tz);\n        try {\n          isSettledRef.current = true;\n        } catch (e) {}\n        enhancedOnRoll(face);\n      }\n    });\n\n    // ensure any previous tweens are cleared and canvas anchored bottom-right\n    const canvasEl = canvasRef.current;\n    if (canvasEl) {\n      try {\n        gsap.killTweensOf(canvasEl);\n      } catch (e) {}\n      try {\n        canvasEl.style.transform = '';\n        canvasEl.style.transition = '';\n        canvasEl.style.left = '';\n        canvasEl.style.top = '';\n        canvasEl.style.right = '20px';\n        canvasEl.style.bottom = '20px';\n        canvasEl.style.willChange = 'auto';\n      } catch (e) {}\n    }\n    if (spinOnly) {\n      // keep canvas fixed bottom-right with no transform\n      if (canvasEl && canvasEl.style) {\n        gsap.set(canvasEl, {\n          x: 0,\n          y: 0,\n          filter: 'blur(0px)'\n        });\n        canvasEl.style.right = '20px';\n        canvasEl.style.bottom = '20px';\n      }\n    } else {\n      // physics-like multi-bounce motion across screen\n      if (canvasEl && canvasEl.style) {\n        canvasEl.style.position = 'fixed';\n        canvasEl.style.left = '0px';\n        canvasEl.style.top = '0px';\n        canvasEl.style.willChange = 'transform, filter';\n\n        // initial velocity and angle\n        const speedBase = Math.max(200, duration * 0.6); // px per second scale\n        const angle = Math.random() * Math.PI * 2;\n        let vx = Math.cos(angle) * (speedBase * (0.6 + Math.random() * 0.8));\n        let vy = Math.sin(angle) * (speedBase * (0.6 + Math.random() * 0.8));\n\n        // start position: bottom-right corner with small margin\n        const margin = 20;\n        const startX = Math.max(0, window.innerWidth - size - margin);\n        const startY = Math.max(0, window.innerHeight - size - margin);\n        let x = startX;\n        let y = startY;\n        gsap.set(canvasEl, {\n          x,\n          y,\n          filter: 'blur(0px)'\n        });\n\n        // final target: within 100px radius around screen center\n        const centerX = Math.round(window.innerWidth / 2 - size / 2);\n        const centerY = Math.round(window.innerHeight / 2 - size / 2);\n        const radius = 100;\n        const angT = Math.random() * Math.PI * 2;\n        const endX = Math.max(0, Math.min(window.innerWidth - size, centerX + Math.cos(angT) * (Math.random() * radius)));\n        const endY = Math.max(0, Math.min(window.innerHeight - size, centerY + Math.sin(angT) * (Math.random() * radius)));\n\n        // generate bounces until energy low or max 6 bounces\n        const bounces = [];\n        let energy = Math.hypot(vx, vy);\n        const damp = 0.45 + Math.random() * 0.18; // energy retention per bounce\n        const maxBounces = 6;\n        for (let i = 0; i < maxBounces && energy > 80; i++) {\n          // project next position with simple friction\n          const dt = duration / 1000 * (0.25 + Math.random() * 0.35);\n          const nx = x + vx * dt;\n          const ny = y + vy * dt + 200 * (Math.random() - 0.5) * 0.1; // slight gravity variation\n          const dur = Math.max(0.06, dt * (0.6 + Math.random() * 0.6));\n          const blur = Math.min(6, energy / 200);\n          bounces.push({\n            nx,\n            ny,\n            dur,\n            blur\n          });\n\n          // update for next\n          x = nx;\n          y = ny;\n          energy *= damp * (0.8 + Math.random() * 0.4);\n          // random angle change\n          const angChange = (Math.random() - 0.5) * 0.8;\n          const vAngle = Math.atan2(vy, vx) + angChange;\n          const vMag = energy;\n          vx = Math.cos(vAngle) * vMag * 0.02;\n          vy = Math.sin(vAngle) * vMag * 0.02;\n        }\n\n        // schedule bounces in timeline\n        let tOffset = 0;\n        for (const b of bounces) {\n          timeline.to(canvasEl, {\n            duration: b.dur,\n            x: b.nx,\n            y: b.ny,\n            ease: 'power2.out'\n          }, tOffset);\n          timeline.to(canvasEl, {\n            duration: b.dur,\n            filter: `blur(${b.blur}px)`\n          }, tOffset);\n          tOffset += b.dur * 0.9;\n        }\n        // final settle to the computed center-target\n        timeline.to(canvasEl, {\n          duration: 0.12,\n          x: endX,\n          y: endY,\n          ease: 'power1.out'\n        }, '>-0.02');\n        timeline.to(canvasEl, {\n          duration: 0.12,\n          filter: 'blur(0px)',\n          ease: 'power1.out'\n        }, '>-0.02');\n      }\n    }\n\n    // rotation: spin multiple revolutions then ease to final orientation\n    // we'll use a GSAP ticker to update cube.rotation\n    const totalSpins = 3 + Math.floor(Math.random() * 4);\n    const rotEnd = {\n      x: end.x,\n      y: end.y,\n      z: end.z\n    };\n    const rotStart = {\n      x: start.x,\n      y: start.y,\n      z: start.z\n    };\n\n    // animate rotation using timeline with an onUpdate that writes to cube\n    let progress = {\n      t: 0\n    };\n    timeline.to(progress, {\n      t: 1,\n      duration: duration / 1000,\n      ease: 'power3.out',\n      onUpdate: () => {\n        const k = progress.t;\n        // combine ease with extra spins\n        const spinFactor = 1 - Math.pow(1 - k, 3);\n        const currentX = rotStart.x + (rotEnd.x - rotStart.x) * k + totalSpins * Math.PI * 2 * (1 - (1 - k));\n        const currentY = rotStart.y + (rotEnd.y - rotStart.y) * k + totalSpins * Math.PI * 2 * (1 - (1 - k));\n        const currentZ = rotStart.z + (rotEnd.z - rotStart.z) * k + totalSpins * Math.PI * 2 * (1 - (1 - k));\n        cube.rotation.set(currentX, currentY, currentZ);\n      }\n    });\n\n    // small multi-bounce sequence on completion (scale + tilt)\n    timeline.to(cube.scale, {\n      x: 1.08,\n      y: 0.90,\n      z: 0.9,\n      duration: 0.07,\n      ease: 'power2.out'\n    }, '>-0.05');\n    timeline.to(cube.scale, {\n      x: 0.95,\n      y: 1.07,\n      z: 0.95,\n      duration: 0.06,\n      ease: 'power2.in'\n    });\n    timeline.to(cube.scale, {\n      x: 1.03,\n      y: 0.98,\n      z: 1.02,\n      duration: 0.05,\n      ease: 'power2.out'\n    });\n    timeline.to(cube.scale, {\n      x: 1,\n      y: 1,\n      z: 1,\n      duration: 0.04,\n      ease: 'power2.out'\n    });\n  }, [duration, onRoll, spinOnly, size]);\n  useImperativeHandle(ref, () => ({\n    roll: () => rollInternal(),\n    rollTo: face => rollInternal(Math.max(1, Math.min(6, face)))\n  }), [rollInternal]);\n\n  // click to roll\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const handler = () => rollInternal();\n    canvas.addEventListener('click', handler);\n    return () => canvas.removeEventListener('click', handler);\n  }, [rollInternal]);\n\n  // auto-roll when requested by corruption system\n  useEffect(() => {\n    const handler = ev => {\n      console.log('ðŸŽ² DICE: Received auto-roll request', ev.detail);\n      lastRequestRef.current = ev.detail; // store player/targetUid\n      rollInternal();\n    };\n    window.addEventListener('pc:ui_request_dice_roll', handler);\n    return () => window.removeEventListener('pc:ui_request_dice_roll', handler);\n  }, [rollInternal]);\n\n  // listen for engine-calculated dice result to display exact value\n  useEffect(() => {\n    const handler = ev => {\n      const {\n        roll\n      } = ev.detail || {};\n      if (roll && typeof roll === 'number' && roll >= 1 && roll <= 6) {\n        console.log('ðŸŽ² DICE: Engine calculated roll received:', roll, '- displaying exact value');\n        lastRequestRef.current = ev.detail; // store player/targetUid\n        rollInternal(roll); // roll to exact face\n      }\n    };\n    window.addEventListener('pc:engine_dice_result', handler);\n    return () => window.removeEventListener('pc:engine_dice_result', handler);\n  }, [rollInternal]);\n\n  // dispatch dice result including player info\n  const enhancedOnRoll = useCallback(face => {\n    onRoll === null || onRoll === void 0 ? void 0 : onRoll(face);\n    try {\n      const det = lastRequestRef.current || {};\n      window.dispatchEvent(new CustomEvent('pc:dice_result', {\n        detail: {\n          roll: face,\n          player: det.player,\n          targetUid: det.targetUid\n        }\n      }));\n    } catch (e) {\n      console.error('dice_result dispatch error', e);\n    }\n  }, [onRoll]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    width: size,\n    height: size,\n    className: className,\n    style: {\n      cursor: 'pointer'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 417,\n    columnNumber: 12\n  }, this);\n}, \"sUJN7esodfCDiTXMgoVk3CysRlY=\")), \"sUJN7esodfCDiTXMgoVk3CysRlY=\");\n_c2 = Dice3D;\nexport default Dice3D;\nvar _c, _c2;\n$RefreshReg$(_c, \"Dice3D$forwardRef\");\n$RefreshReg$(_c2, \"Dice3D\");","map":{"version":3,"names":["React","useEffect","useRef","useImperativeHandle","forwardRef","useCallback","THREE","gsap","jsxDEV","_jsxDEV","Dice3D","_s","_c","size","duration","onRoll","className","spinOnly","ref","canvasRef","sceneRef","cubeRef","rendererRef","cameraRef","animIdRef","lastRequestRef","isSettledRef","createFaceTexture","face","cvs","document","createElement","width","height","ctx","getContext","fillStyle","fillRect","dot","x","y","beginPath","arc","Math","PI","fill","g","centers","forEach","tex","CanvasTexture","needsUpdate","canvas","current","scene","Scene","background","Color","camera","PerspectiveCamera","position","z","renderer","WebGLRenderer","antialias","alpha","setSize","shadowMap","enabled","type","PCFSoftShadowMap","ambient","AmbientLight","add","dir","DirectionalLight","set","castShadow","shadow","mapSize","left","right","top","bottom","planeGeo","PlaneGeometry","planeMat","ShadowMaterial","opacity","plane","Mesh","rotation","receiveShadow","generatedEnvMap","envCanvas","ectx","grad","createRadialGradient","addColorStop","envTex","mapping","EquirectangularReflectionMapping","pmremGen","PMREMGenerator","compileEquirectangularShader","fromEquirectangular","texture","environment","e","materials","map","f","MeshStandardMaterial","metalness","roughness","envMapIntensity","geometry","BoxGeometry","cube","m","envMap","el","style","transform","transition","prevRot","animate","requestAnimationFrame","dx","dy","dz","angSpeed","sqrt","blurPx","min","filter","toFixed","render","cancelAnimationFrame","dispose","rollInternal","targetFace","floor","random","orientations","tx","ty","tz","start","end","killTweensOf","timeline","onStart","onComplete","enhancedOnRoll","canvasEl","willChange","speedBase","max","angle","vx","cos","vy","sin","margin","startX","window","innerWidth","startY","innerHeight","centerX","round","centerY","radius","angT","endX","endY","bounces","energy","hypot","damp","maxBounces","i","dt","nx","ny","dur","blur","push","angChange","vAngle","atan2","vMag","tOffset","b","to","ease","totalSpins","rotEnd","rotStart","progress","t","onUpdate","k","spinFactor","pow","currentX","currentY","currentZ","scale","roll","rollTo","handler","addEventListener","removeEventListener","ev","console","log","detail","det","dispatchEvent","CustomEvent","player","targetUid","error","cursor","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/components/Dice3D.tsx"],"sourcesContent":["import React, { useEffect, useRef, useImperativeHandle, forwardRef, useCallback } from 'react';\nimport * as THREE from 'three';\nimport gsap from 'gsap';\n\nexport interface Dice3DProps {\n  /** pixel size of canvas */\n  size?: number;\n  /** roll animation duration in ms */\n  duration?: number;\n  /** callback when roll ends */\n  onRoll?: (face: number) => void;\n  className?: string;\n  /** if true, only spin in place; if false, do screen bounces */\n  spinOnly?: boolean;\n}\n\nexport interface Dice3DHandle {\n  roll: () => void;\n  rollTo: (face: number) => void;\n}\n\n/**\n * Dice3D â€“ simple WebGL dice rendered with three.js\n * Usage:\n *   const diceRef = useRef<Dice3DHandle>(null);\n *   <Dice3D ref={diceRef} onRoll={(f)=>console.log(f)}/>\n *   diceRef.current?.roll();\n */\nconst Dice3D = forwardRef<Dice3DHandle, Dice3DProps>(\n  ({ size = 180, duration = 1200, onRoll, className, spinOnly = true }: Dice3DProps, ref) => {\n    const canvasRef = useRef<HTMLCanvasElement | null>(null);\n    const sceneRef = useRef<THREE.Scene>();\n    const cubeRef = useRef<THREE.Mesh>();\n    const rendererRef = useRef<THREE.WebGLRenderer>();\n    const cameraRef = useRef<THREE.PerspectiveCamera>();\n    const animIdRef = useRef(0);\n    const lastRequestRef = useRef<any>(null);\n    const isSettledRef = useRef<boolean>(true); // when true, dice remain static until next roll\n\n    /** helper to create a texture with pips */\n    const createFaceTexture = (face: number): THREE.Texture => {\n      const size = 128;\n      const cvs = document.createElement('canvas');\n      cvs.width = cvs.height = size;\n      const ctx = cvs.getContext('2d')!;\n      ctx.fillStyle = '#fff';\n      ctx.fillRect(0, 0, size, size);\n      ctx.fillStyle = '#111';\n\n      const dot = (x: number, y: number) => {\n        ctx.beginPath();\n        ctx.arc(x, y, size * 0.1, 0, Math.PI * 2);\n        ctx.fill();\n      };\n      const g = size * 0.25;\n      const centers: Record<number, Array<[number, number]>> = {\n        1: [[size / 2, size / 2]],\n        2: [[g, g], [size - g, size - g]],\n        3: [[g, g], [size / 2, size / 2], [size - g, size - g]],\n        4: [[g, g], [size - g, g], [g, size - g], [size - g, size - g]],\n        5: [[g, g], [size - g, g], [size / 2, size / 2], [g, size - g], [size - g, size - g]],\n        6: [[g, g], [size - g, g], [g, size / 2], [size - g, size / 2], [g, size - g], [size - g, size - g]],\n      };\n      centers[face].forEach(([x, y]) => dot(x, y));\n      const tex = new THREE.CanvasTexture(cvs);\n      tex.needsUpdate = true;\n      return tex;\n    };\n\n    // initialize three scene\n    useEffect(() => {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n      const scene = new THREE.Scene();\n      scene.background = new THREE.Color(0x000000);\n      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);\n      camera.position.z = 4;\n      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });\n      renderer.setSize(size, size);\n      renderer.shadowMap.enabled = true;\n      renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n      // lights\n      const ambient = new THREE.AmbientLight(0xffffff, 0.6);\n      scene.add(ambient);\n      const dir = new THREE.DirectionalLight(0xffffff, 1.0);\n      dir.position.set(5, 10, 7);\n      dir.castShadow = true;\n      dir.shadow.mapSize.width = 1024;\n      dir.shadow.mapSize.height = 1024;\n      dir.shadow.camera.left = -5;\n      dir.shadow.camera.right = 5;\n      dir.shadow.camera.top = 5;\n      dir.shadow.camera.bottom = -5;\n      scene.add(dir);\n\n      // ground plane to receive shadow\n      const planeGeo = new THREE.PlaneGeometry(10, 10);\n      const planeMat = new THREE.ShadowMaterial({ opacity: 0.35 });\n      const plane = new THREE.Mesh(planeGeo, planeMat);\n      plane.rotation.x = -Math.PI / 2;\n      plane.position.y = -1.1;\n      plane.receiveShadow = true;\n      scene.add(plane);\n\n      // Create a simple procedural equirectangular-like texture for subtle reflections\n      let generatedEnvMap: THREE.Texture | null = null;\n      try {\n        const envCanvas = document.createElement('canvas');\n        envCanvas.width = envCanvas.height = 256;\n        const ectx = envCanvas.getContext('2d')!;\n        // simple radial gradient\n        const grad = ectx.createRadialGradient(128, 128, 20, 128, 128, 140);\n        grad.addColorStop(0, '#ffffff');\n        grad.addColorStop(0.5, '#ccccff');\n        grad.addColorStop(1, '#556688');\n        ectx.fillStyle = grad;\n        ectx.fillRect(0, 0, 256, 256);\n        const envTex = new THREE.CanvasTexture(envCanvas);\n        envTex.mapping = THREE.EquirectangularReflectionMapping;\n        const pmremGen = new THREE.PMREMGenerator(renderer);\n        pmremGen.compileEquirectangularShader();\n        generatedEnvMap = pmremGen.fromEquirectangular(envTex).texture;\n        scene.environment = generatedEnvMap;\n      } catch (e) {\n        // ignore if PMREM not supported in environment\n        generatedEnvMap = null;\n      }\n\n      // cube\n      const materials = [1, 2, 3, 4, 5, 6].map(f => new THREE.MeshStandardMaterial({ map: createFaceTexture(f), metalness: 0.4, roughness: 0.25, envMapIntensity: 1.0 }));\n      const geometry = new THREE.BoxGeometry(2, 2, 2);\n      const cube = new THREE.Mesh(geometry, materials);\n      cube.castShadow = true;\n      cube.receiveShadow = false;\n      scene.add(cube);\n\n      // If we generated an environment map, apply it to materials for reflections\n      if (generatedEnvMap) {\n        try {\n          materials.forEach((m: any) => {\n            m.envMap = generatedEnvMap;\n            m.envMapIntensity = 0.8;\n            m.needsUpdate = true;\n          });\n        } catch (e) {}\n      }\n\n      sceneRef.current = scene;\n      cubeRef.current = cube;\n      rendererRef.current = renderer;\n      cameraRef.current = camera;\n\n      // Ensure canvas is anchored bottom-right and has no initial transform\n      try {\n        const el = canvas as HTMLCanvasElement;\n        el.style.position = 'fixed';\n        el.style.right = '20px';\n        el.style.bottom = '20px';\n        el.style.left = '';\n        el.style.top = '';\n        el.style.transform = '';\n        el.style.transition = '';\n      } catch (e) {}\n\n      // animation loop\n      // previous rotation for motion-blur estimation\n      const prevRot = { x: 0, y: 0, z: 0 };\n      const animate = () => {\n        animIdRef.current = requestAnimationFrame(animate);\n        // subtle idle rotate\n        if (cube) {\n          // only apply subtle idle motion while an active roll timeline is running\n          if (!isSettledRef.current) {\n            cube.rotation.x *= 0.995;\n            cube.rotation.y *= 0.995;\n\n            // compute angular velocity\n            const dx = cube.rotation.x - prevRot.x;\n            const dy = cube.rotation.y - prevRot.y;\n            const dz = cube.rotation.z - prevRot.z;\n            const angSpeed = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n            // map angular speed to CSS blur (px)\n            const blurPx = Math.min(12, angSpeed * 120);\n            try {\n              const el = canvas as HTMLCanvasElement;\n              if (el && el.style) {\n                el.style.filter = blurPx > 0.3 ? `blur(${blurPx.toFixed(2)}px)` : 'none';\n              }\n            } catch (e) {}\n\n            prevRot.x = cube.rotation.x;\n            prevRot.y = cube.rotation.y;\n            prevRot.z = cube.rotation.z;\n          } else {\n            // settled: ensure no blur and reset prevRot\n            try { const el = canvas as HTMLCanvasElement; if (el && el.style) el.style.filter = 'none'; } catch(e) {}\n            prevRot.x = cube.rotation.x;\n            prevRot.y = cube.rotation.y;\n            prevRot.z = cube.rotation.z;\n          }\n        }\n        renderer.render(scene, camera);\n      };\n      animate();\n\n      return () => {\n        cancelAnimationFrame(animIdRef.current);\n        renderer.dispose();\n      };\n    }, [size]);\n\n    // roll logic (includes DOM motion)\n    const rollInternal = useCallback((targetFace?: number) => {\n      if (!cubeRef.current) return;\n      const cube = cubeRef.current;\n      // pick target if not provided\n      const face = targetFace ?? (1 + Math.floor(Math.random() * 6));\n\n      // orientation map: face -> Euler rotation (approx)\n      const orientations: Record<number, [number, number, number]> = {\n        1: [0, 0, 0],\n        2: [0, Math.PI / 2, 0],\n        3: [-Math.PI / 2, 0, 0],\n        4: [Math.PI / 2, 0, 0],\n        5: [0, -Math.PI / 2, 0],\n        6: [Math.PI, 0, 0],\n      };\n      const [tx, ty, tz] = orientations[face];\n\n      const start = { x: cube.rotation.x, y: cube.rotation.y, z: cube.rotation.z };\n      const end = { x: tx + 2 * Math.PI, y: ty + 2 * Math.PI, z: tz + 2 * Math.PI };\n\n      // Ensure any previous rotation tweens on cube are killed so they can't override final orientation\n      try { if (cube) { gsap.killTweensOf(cube); gsap.killTweensOf(cube.rotation); } } catch (e) {}\n      // Use GSAP timeline for smooth rotation + bounces and DOM motion\n      const timeline = gsap.timeline({ onStart: () => {\n        // mark as active so idle loop applies motion\n        try { isSettledRef.current = false; } catch(e) {}\n      }, onComplete: () => {\n        // explicitly kill any remaining tweens affecting cube and set final orientation\n        try { if (cube) { gsap.killTweensOf(cube); gsap.killTweensOf(cube.rotation); } } catch(e) {}\n        cube.rotation.set(tx, ty, tz);\n        try { isSettledRef.current = true; } catch(e) {}\n        enhancedOnRoll(face);\n      }});\n\n      // ensure any previous tweens are cleared and canvas anchored bottom-right\n      const canvasEl = canvasRef.current as HTMLCanvasElement | null;\n      if (canvasEl) {\n        try { gsap.killTweensOf(canvasEl); } catch (e) {}\n        try {\n          canvasEl.style.transform = '';\n          canvasEl.style.transition = '';\n          canvasEl.style.left = '';\n          canvasEl.style.top = '';\n          canvasEl.style.right = '20px';\n          canvasEl.style.bottom = '20px';\n          canvasEl.style.willChange = 'auto';\n        } catch (e) {}\n      }\n\n      if (spinOnly) {\n        // keep canvas fixed bottom-right with no transform\n        if (canvasEl && canvasEl.style) {\n          gsap.set(canvasEl, { x: 0, y: 0, filter: 'blur(0px)' });\n          canvasEl.style.right = '20px';\n          canvasEl.style.bottom = '20px';\n        }\n      } else {\n        // physics-like multi-bounce motion across screen\n        if (canvasEl && canvasEl.style) {\n          canvasEl.style.position = 'fixed';\n          canvasEl.style.left = '0px';\n          canvasEl.style.top = '0px';\n          canvasEl.style.willChange = 'transform, filter';\n\n          // initial velocity and angle\n          const speedBase = Math.max(200, duration * 0.6); // px per second scale\n          const angle = Math.random() * Math.PI * 2;\n          let vx = Math.cos(angle) * (speedBase * (0.6 + Math.random() * 0.8));\n          let vy = Math.sin(angle) * (speedBase * (0.6 + Math.random() * 0.8));\n\n          // start position: bottom-right corner with small margin\n          const margin = 20;\n          const startX = Math.max(0, window.innerWidth - size - margin);\n          const startY = Math.max(0, window.innerHeight - size - margin);\n          let x = startX;\n          let y = startY;\n          gsap.set(canvasEl, { x, y, filter: 'blur(0px)' });\n\n          // final target: within 100px radius around screen center\n          const centerX = Math.round(window.innerWidth / 2 - size / 2);\n          const centerY = Math.round(window.innerHeight / 2 - size / 2);\n          const radius = 100;\n          const angT = Math.random() * Math.PI * 2;\n          const endX = Math.max(0, Math.min(window.innerWidth - size, centerX + Math.cos(angT) * (Math.random() * radius)));\n          const endY = Math.max(0, Math.min(window.innerHeight - size, centerY + Math.sin(angT) * (Math.random() * radius)));\n\n          // generate bounces until energy low or max 6 bounces\n          const bounces: Array<{ nx: number; ny: number; dur: number; blur: number }> = [];\n          let energy = Math.hypot(vx, vy);\n          const damp = 0.45 + Math.random() * 0.18; // energy retention per bounce\n          const maxBounces = 6;\n          for (let i = 0; i < maxBounces && energy > 80; i++) {\n            // project next position with simple friction\n            const dt = (duration / 1000) * (0.25 + Math.random() * 0.35);\n            const nx = x + vx * dt;\n            const ny = y + vy * dt + 200 * (Math.random() - 0.5) * 0.1; // slight gravity variation\n            const dur = Math.max(0.06, dt * (0.6 + Math.random() * 0.6));\n            const blur = Math.min(6, energy / 200);\n            bounces.push({ nx, ny, dur, blur });\n\n            // update for next\n            x = nx; y = ny;\n            energy *= damp * (0.8 + Math.random() * 0.4);\n            // random angle change\n            const angChange = (Math.random() - 0.5) * 0.8;\n            const vAngle = Math.atan2(vy, vx) + angChange;\n            const vMag = energy;\n            vx = Math.cos(vAngle) * vMag * 0.02;\n            vy = Math.sin(vAngle) * vMag * 0.02;\n          }\n\n          // schedule bounces in timeline\n          let tOffset = 0;\n          for (const b of bounces) {\n            timeline.to(canvasEl, { duration: b.dur, x: b.nx, y: b.ny, ease: 'power2.out' }, tOffset);\n            timeline.to(canvasEl, { duration: b.dur, filter: `blur(${b.blur}px)` }, tOffset);\n            tOffset += b.dur * 0.9;\n          }\n          // final settle to the computed center-target\n          timeline.to(canvasEl, { duration: 0.12, x: endX, y: endY, ease: 'power1.out' }, '>-0.02');\n          timeline.to(canvasEl, { duration: 0.12, filter: 'blur(0px)', ease: 'power1.out' }, '>-0.02');\n        }\n      }\n\n      // rotation: spin multiple revolutions then ease to final orientation\n      // we'll use a GSAP ticker to update cube.rotation\n      const totalSpins = 3 + Math.floor(Math.random() * 4);\n      const rotEnd = { x: end.x, y: end.y, z: end.z };\n      const rotStart = { x: start.x, y: start.y, z: start.z };\n\n      // animate rotation using timeline with an onUpdate that writes to cube\n      let progress = { t: 0 };\n      timeline.to(progress, {\n        t: 1,\n        duration: duration / 1000,\n        ease: 'power3.out',\n        onUpdate: () => {\n          const k = progress.t;\n          // combine ease with extra spins\n          const spinFactor = 1 - Math.pow(1 - k, 3);\n          const currentX = rotStart.x + (rotEnd.x - rotStart.x) * k + totalSpins * Math.PI * 2 * (1 - (1 - k));\n          const currentY = rotStart.y + (rotEnd.y - rotStart.y) * k + totalSpins * Math.PI * 2 * (1 - (1 - k));\n          const currentZ = rotStart.z + (rotEnd.z - rotStart.z) * k + totalSpins * Math.PI * 2 * (1 - (1 - k));\n          cube.rotation.set(currentX, currentY, currentZ);\n        }\n      });\n\n      // small multi-bounce sequence on completion (scale + tilt)\n      timeline.to(cube.scale, { x: 1.08, y: 0.90, z: 0.9, duration: 0.07, ease: 'power2.out' }, '>-0.05');\n      timeline.to(cube.scale, { x: 0.95, y: 1.07, z: 0.95, duration: 0.06, ease: 'power2.in' });\n      timeline.to(cube.scale, { x: 1.03, y: 0.98, z: 1.02, duration: 0.05, ease: 'power2.out' });\n      timeline.to(cube.scale, { x: 1, y: 1, z: 1, duration: 0.04, ease: 'power2.out' });\n    }, [duration, onRoll, spinOnly, size]);\n\n    useImperativeHandle(ref, () => ({\n      roll: () => rollInternal(),\n      rollTo: (face: number) => rollInternal(Math.max(1, Math.min(6, face))),\n    }), [rollInternal]);\n\n    // click to roll\n    useEffect(() => {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n      const handler = () => rollInternal();\n      canvas.addEventListener('click', handler);\n      return () => canvas.removeEventListener('click', handler);\n    }, [rollInternal]);\n\n    // auto-roll when requested by corruption system\n    useEffect(() => {\n      const handler = (ev: any) => {\n        console.log('ðŸŽ² DICE: Received auto-roll request', ev.detail);\n        lastRequestRef.current = ev.detail; // store player/targetUid\n        rollInternal();\n      };\n      window.addEventListener('pc:ui_request_dice_roll', handler as EventListener);\n      return () => window.removeEventListener('pc:ui_request_dice_roll', handler as EventListener);\n    }, [rollInternal]);\n\n    // listen for engine-calculated dice result to display exact value\n    useEffect(() => {\n      const handler = (ev: any) => {\n        const { roll } = ev.detail || {};\n        if (roll && typeof roll === 'number' && roll >= 1 && roll <= 6) {\n          console.log('ðŸŽ² DICE: Engine calculated roll received:', roll, '- displaying exact value');\n          lastRequestRef.current = ev.detail; // store player/targetUid\n          rollInternal(roll); // roll to exact face\n        }\n      };\n      window.addEventListener('pc:engine_dice_result', handler as EventListener);\n      return () => window.removeEventListener('pc:engine_dice_result', handler as EventListener);\n    }, [rollInternal]);\n\n    // dispatch dice result including player info\n    const enhancedOnRoll = useCallback((face:number)=>{\n      onRoll?.(face);\n      try {\n        const det = lastRequestRef.current || {};\n        window.dispatchEvent(new CustomEvent('pc:dice_result', { detail: { roll: face, player: det.player, targetUid: det.targetUid } }));\n      } catch(e){ console.error('dice_result dispatch error',e); }\n    },[onRoll]);\n\n    return <canvas ref={canvasRef} width={size} height={size} className={className} style={{ cursor: 'pointer' }} />;\n  });\n\nexport default Dice3D;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}