{"ast":null,"code":"import { getStrongestGovernment } from './targets';\nimport { registerTrap } from './traps';\nimport { logAP, logDraw, logDiscardRandom, logDeactivateRandom, logBuffStrongest, logShield, logDeactivateCard, logOpportunist } from './logs';\nimport { getGlobalRNG } from '../services/rng';\n\n// Helper function to check if a government card is authoritarian\nfunction isAuthoritarianGovernment(card) {\n  // Authoritarian governments: Putin, Xi Jinping, Erdogan, etc.\n  const authoritarianNames = ['Vladimir Putin', 'Xi Jinping', 'Recep Tayyip Erdogan', 'Kim Jong-un', 'Bashar al-Assad', 'Alexander Lukashenko', 'Nicolás Maduro', 'Daniel Ortega'];\n  return authoritarianNames.includes(card.name);\n}\n// Helper to find strongest government uid for new intents\nfunction strongestGovernmentUid(state, p) {\n  var _state$board$p;\n  const govRow = (_state$board$p = state.board[p]) === null || _state$board$p === void 0 ? void 0 : _state$board$p.aussen;\n  if (!govRow || govRow.length === 0) return null;\n  const alive = govRow.filter(g => !g.deactivated);\n  if (!alive.length) return null;\n  const sorted = alive.slice().sort((a, b) => b.influence + (b.tempBuffs || 0) - (b.tempDebuffs || 0) - (a.influence + (a.tempBuffs || 0) - (a.tempDebuffs || 0)));\n  return sorted[0].uid;\n}\nfunction other(p) {\n  return p === 1 ? 2 : 1;\n}\nfunction logPush(state, msg) {\n  state.log.push(msg);\n}\nfunction strongestGov(state, p) {\n  const row = state.board[p].aussen;\n  if (!row.length) return null;\n  const alive = row.filter(c => !c.deactivated);\n  if (alive.length === 0) return null;\n  return alive.slice().sort((a, b) => b.influence + (b.tempBuffs || 0) - (b.tempDebuffs || 0) - (a.influence + (a.tempBuffs || 0) - (a.tempDebuffs || 0)))[0];\n}\nfunction publicNames(state, p) {\n  return state.board[p].innen.map(c => c.name);\n}\nfunction hasPublic(state, p, name) {\n  return publicNames(state, p).includes(name);\n}\nfunction findCardByUidOnBoard(state, uid) {\n  for (const p of [1, 2]) {\n    for (const lane of ['innen', 'aussen', 'sofort']) {\n      const arr = state.board[p][lane];\n      const hit = arr.find(c => c.uid === uid);\n      if (hit) return hit;\n    }\n  }\n  return null;\n}\nexport function resolveQueue(state, events) {\n  const rng = getGlobalRNG();\n\n  // Single pass FIFO\n  while (events.length) {\n    const ev = events.shift();\n    switch (ev.type) {\n      case 'LOG':\n        {\n          logPush(state, ev.msg);\n          break;\n        }\n      case 'ADD_AP':\n        {\n          const cur = state.actionPoints[ev.player];\n          const next = Math.max(0, cur + ev.amount);\n          state.actionPoints[ev.player] = next;\n          logPush(state, logAP(ev.player, cur, next));\n          break;\n        }\n      case 'DRAW_CARDS':\n        {\n          for (let i = 0; i < ev.amount; i++) {\n            const top = state.decks[ev.player].shift();\n            if (top) {\n              state.hands[ev.player].push(top);\n              logPush(state, logDraw(ev.player, top.name));\n            }\n          }\n          break;\n        }\n      case 'DISCARD_RANDOM_FROM_HAND':\n        {\n          const hand = state.hands[ev.player];\n          for (let i = 0; i < ev.amount && hand.length > 0; i++) {\n            const idx = rng.randomInt(hand.length);\n            const [card] = hand.splice(idx, 1);\n            state.discard.push(card);\n            logPush(state, logDiscardRandom(ev.player, card.name));\n          }\n          break;\n        }\n      case 'DEACTIVATE_RANDOM_HAND':\n        {\n          // Deaktivieren von Handkarten (nicht entfernen)\n          const hand = state.hands[ev.player];\n          const activeCards = hand.filter(c => !c.deactivated);\n          for (let i = 0; i < ev.amount && activeCards.length > 0; i++) {\n            const card = rng.pick(activeCards);\n            if (card) {\n              card.deactivated = true;\n              logPush(state, logDeactivateRandom(ev.player, card.name));\n              // Entferne aus activeCards für nächste Iteration\n              const idx = activeCards.indexOf(card);\n              if (idx > -1) activeCards.splice(idx, 1);\n            }\n          }\n          break;\n        }\n\n      // Legacy cases - removed\n      // SET_DISCOUNT and REFUND_NEXT_INITIATIVE are no longer supported\n      // Use ADD_AP instead\n\n      case 'GRANT_SHIELD':\n        {\n          if (!state.shields) state.shields = new Set();\n          const targetUid = ev.targetUid || 0;\n          state.shields.add(targetUid);\n          logPush(state, logShield(targetUid));\n          break;\n        }\n      case 'DEACTIVATE_CARD':\n        {\n          const card = findCardByUidOnBoard(state, ev.targetUid);\n          if (card) {\n            card.deactivated = true;\n            logPush(state, logDeactivateCard(card.name));\n          }\n          break;\n        }\n      case 'REACTIVATE_CARD':\n        {\n          const card = findCardByUidOnBoard(state, ev.targetUid);\n          if (card) {\n            card.deactivated = false;\n            logPush(state, `🔄 ${card.name} wurde reaktiviert`);\n          }\n          break;\n        }\n      case 'RETURN_TO_HAND':\n        {\n          const card = findCardByUidOnBoard(state, ev.targetUid);\n          if (card) {\n            // Remove from board\n            for (const p of [1, 2]) {\n              for (const lane of ['innen', 'aussen', 'sofort']) {\n                const idx = state.board[p][lane].findIndex(c => c.uid === ev.targetUid);\n                if (idx !== -1) {\n                  state.board[p][lane].splice(idx, 1);\n                  // Add to hand\n                  state.hands[ev.player].push(card);\n                  logPush(state, `🔄 ${card.name} wurde zur Hand zurückgegeben`);\n                  break;\n                }\n              }\n            }\n          }\n          break;\n        }\n      case 'CANCEL_CARD':\n        {\n          const card = findCardByUidOnBoard(state, ev.targetUid);\n          if (card) {\n            // Remove from board and add to discard\n            for (const p of [1, 2]) {\n              for (const lane of ['innen', 'aussen', 'sofort']) {\n                const idx = state.board[p][lane].findIndex(c => c.uid === ev.targetUid);\n                if (idx !== -1) {\n                  state.board[p][lane].splice(idx, 1);\n                  state.discard.push(card);\n                  logPush(state, `❌ ${card.name} wurde annulliert`);\n                  break;\n                }\n              }\n            }\n          }\n          break;\n        }\n      case 'REGISTER_TRAP':\n        {\n          registerTrap(state, ev.player, ev.key);\n          logPush(state, `Trap registered: ${ev.key} (P${ev.player})`);\n          break;\n        }\n      case 'BUFF_STRONGEST_GOV':\n      case 'ADJUST_INFLUENCE':\n        {\n          // Alias auf BUFF_STRONGEST_GOV\n          const player = ev.player;\n          const amount = ev.amount;\n          const tgt = getStrongestGovernment(state, player);\n          if (tgt) {\n            var _state$effectFlags$ot;\n            if (amount >= 0) {\n              tgt.tempBuffs = (tgt.tempBuffs || 0) + amount;\n            } else {\n              tgt.tempDebuffs = (tgt.tempDebuffs || 0) + Math.abs(amount);\n            }\n            logPush(state, logBuffStrongest(player, tgt.name, amount));\n\n            // Opportunist-Spiegelung (falls aktiv beim Gegner)\n            if ((_state$effectFlags$ot = state.effectFlags[other(player)]) !== null && _state$effectFlags$ot !== void 0 && _state$effectFlags$ot.opportunistActive && amount > 0) {\n              const mirror = {\n                type: 'BUFF_STRONGEST_GOV',\n                player: other(player),\n                amount\n              };\n              events.unshift(mirror);\n              logPush(state, logOpportunist(other(player), amount));\n            }\n          }\n          break;\n        }\n\n      // ===== New intent event handlers =====\n\n      case 'DEACTIVATE_STRONGEST_ENEMY_GOV':\n        {\n          const opp = ev.player === 1 ? 2 : 1;\n          const uid = strongestGovernmentUid(state, opp);\n          if (uid !== null) {\n            events.unshift({\n              type: 'DEACTIVATE_CARD',\n              player: opp,\n              targetUid: uid\n            });\n            events.unshift({\n              type: 'LOG',\n              msg: 'Party Offensive: strongest enemy Government deactivated.'\n            });\n          } else {\n            events.unshift({\n              type: 'LOG',\n              msg: 'Party Offensive: no enemy Government to deactivate.'\n            });\n          }\n          break;\n        }\n      case 'LOCK_OPPONENT_INITIATIVES_EOT':\n        {\n          const opp = ev.player === 1 ? 2 : 1;\n          state.effectFlags[opp].initiativesLocked = true;\n          events.unshift({\n            type: 'LOG',\n            msg: 'Opposition Blockade: opponent initiatives locked until end of turn.'\n          });\n          break;\n        }\n      case 'SET_DOUBLE_PUBLIC_AURA':\n        {\n          state.effectFlags[ev.player].doublePublicAura = true;\n          events.unshift({\n            type: 'LOG',\n            msg: 'Influencer Campaign: next Public aura will be doubled.'\n          });\n          break;\n        }\n      case 'SET_OPPORTUNIST_ACTIVE':\n        {\n          const {\n            player,\n            active\n          } = ev;\n          state.effectFlags[player].opportunistActive = active;\n          if (active) {\n            events.unshift({\n              type: 'LOG',\n              msg: 'Opportunist: AP effects will be mirrored until end of turn.'\n            });\n          }\n          break;\n        }\n      case 'GOVERNMENT_CARD_PLAYED':\n        {\n          const f = state.effectFlags[ev.player];\n          // Greta Thunberg AP on first government card\n          if (f.gretaFirstGovAp) {\n            const cur = state.actionPoints[ev.player];\n            state.actionPoints[ev.player] = cur + 1;\n            f.gretaFirstGovAp = false;\n            logPush(state, 'Greta Thunberg: +1 AP on first government card played.');\n          }\n\n          // Check for George Soros AP bonus (when opponent gets authoritarian government)\n          const otherPlayer = ev.player === 1 ? 2 : 1;\n          const otherF = state.effectFlags[otherPlayer];\n          if (otherF.sorosAuthoritarianAp) {\n            // Check if the played card is authoritarian\n            const playedCard = state.permanentSlots[ev.player].government;\n            if (playedCard && isAuthoritarianGovernment(playedCard)) {\n              const cur = state.actionPoints[otherPlayer];\n              state.actionPoints[otherPlayer] = cur + 1;\n              otherF.sorosAuthoritarianAp = false;\n              logPush(state, `George Soros: +1 AP (opponent played authoritarian government: ${playedCard.name}).`);\n            }\n          }\n          break;\n        }\n      case 'INITIATIVE_ACTIVATED':\n        {\n          // Existing logic plus new flag consumptions\n          const f = state.effectFlags[ev.player];\n          // Mark Zuckerberg AP once/turn\n          if (f.zuckOnceAp && !f.zuckSpent) {\n            const cur = state.actionPoints[ev.player];\n            state.actionPoints[ev.player] = cur + 1;\n            f.zuckSpent = true;\n            logPush(state, 'Mark Zuckerberg: +1 AP once per turn.');\n          }\n          // Elon Musk AP once/turn\n          if (f.elonOnceAp && !f.elonSpent) {\n            const cur = state.actionPoints[ev.player];\n            state.actionPoints[ev.player] = cur + 1;\n            f.elonSpent = true;\n            logPush(state, 'Elon Musk: +1 AP once per turn after initiative activation.');\n          }\n          // Bill Gates AP on next initiative\n          if (f.gatesNextInitiativeAp) {\n            const cur = state.actionPoints[ev.player];\n            state.actionPoints[ev.player] = cur + 1;\n            f.gatesNextInitiativeAp = false;\n            logPush(state, 'Bill Gates: +1 AP on initiative activation.');\n          }\n          if (f.aiWeiweiOnActivate) {\n            const top = state.decks[ev.player].shift();\n            if (top) state.hands[ev.player].push(top);\n            state.actionPoints[ev.player] += 1;\n            f.aiWeiweiOnActivate = false;\n            logPush(state, 'Ai Weiwei: drew 1 card and gained +1 AP.');\n          }\n          // Simplified AP system: No initiative-specific bonuses\n          // All AP bonuses are now immediate ADD_AP events\n          // Double Public Aura – note (consumption happens separately)\n          if (f.doublePublicAura) {\n            if (!state._effectQueue) state._effectQueue = [];\n            state._effectQueue.push({\n              type: 'LOG',\n              msg: 'Double Public Aura is armed.'\n            });\n          }\n          break;\n        }\n\n      // Simplified AP system: No initiative-specific bonuses\n      // All AP bonuses are now immediate ADD_AP events\n    }\n  }\n}","map":{"version":3,"names":["getStrongestGovernment","registerTrap","logAP","logDraw","logDiscardRandom","logDeactivateRandom","logBuffStrongest","logShield","logDeactivateCard","logOpportunist","getGlobalRNG","isAuthoritarianGovernment","card","authoritarianNames","includes","name","strongestGovernmentUid","state","p","_state$board$p","govRow","board","aussen","length","alive","filter","g","deactivated","sorted","slice","sort","a","b","influence","tempBuffs","tempDebuffs","uid","other","logPush","msg","log","push","strongestGov","row","c","publicNames","innen","map","hasPublic","findCardByUidOnBoard","lane","arr","hit","find","resolveQueue","events","rng","ev","shift","type","cur","actionPoints","player","next","Math","max","amount","i","top","decks","hands","hand","idx","randomInt","splice","discard","activeCards","pick","indexOf","shields","Set","targetUid","add","findIndex","key","tgt","_state$effectFlags$ot","abs","effectFlags","opportunistActive","mirror","unshift","opp","initiativesLocked","doublePublicAura","active","f","gretaFirstGovAp","otherPlayer","otherF","sorosAuthoritarianAp","playedCard","permanentSlots","government","zuckOnceAp","zuckSpent","elonOnceAp","elonSpent","gatesNextInitiativeAp","aiWeiweiOnActivate","_effectQueue"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/utils/queue.ts"],"sourcesContent":["import { GameState, Player, PoliticianCard, Card } from '../types/game';\r\nimport { EffectEvent } from '../types/effects';\r\nimport { getStrongestGovernment } from './targets';\r\nimport { AP_CAP, MAX_DISCOUNT, MAX_REFUND } from '../config/gameConstants';\r\nimport { registerTrap } from './traps';\r\nimport {\r\n  logAP, logDiscount, logRefund, logDraw, logDiscardRandom,\r\n  logDeactivateRandom, logBuffStrongest, logShield, logDeactivateCard,\r\n  logInitiativeAura, logAiWeiwei, logPlattformBonus, logOpportunist\r\n} from './logs';\r\nimport { getGlobalRNG } from '../services/rng';\r\n\r\n// Helper function to check if a government card is authoritarian\r\nfunction isAuthoritarianGovernment(card: Card): boolean {\r\n  // Authoritarian governments: Putin, Xi Jinping, Erdogan, etc.\r\n  const authoritarianNames = [\r\n    'Vladimir Putin',\r\n    'Xi Jinping', \r\n    'Recep Tayyip Erdogan',\r\n    'Kim Jong-un',\r\n    'Bashar al-Assad',\r\n    'Alexander Lukashenko',\r\n    'Nicolás Maduro',\r\n    'Daniel Ortega'\r\n  ];\r\n  return authoritarianNames.includes(card.name);\r\n}\r\n// Helper to find strongest government uid for new intents\r\nfunction strongestGovernmentUid(state: GameState, p: Player): number | null {\r\n  const govRow = state.board[p]?.aussen as PoliticianCard[];\r\n  if (!govRow || govRow.length === 0) return null;\r\n  const alive = govRow.filter(g => !(g as any).deactivated);\r\n  if (!alive.length) return null;\r\n  const sorted = alive.slice().sort((a,b) => (b.influence + (b.tempBuffs||0) - (b.tempDebuffs||0)) - (a.influence + (a.tempBuffs||0) - (a.tempDebuffs||0)));\r\n  return sorted[0].uid;\r\n}\r\n\r\nfunction other(p: Player): Player { return p === 1 ? 2 : 1; }\r\nfunction logPush(state: GameState, msg: string) { state.log.push(msg); }\r\n\r\nfunction strongestGov(state: GameState, p: Player): PoliticianCard | null {\r\n  const row = state.board[p].aussen as PoliticianCard[];\r\n  if (!row.length) return null;\r\n  const alive = row.filter(c => !c.deactivated);\r\n  if (alive.length === 0) return null;\r\n  return alive.slice().sort((a,b) => (b.influence + (b.tempBuffs||0) - (b.tempDebuffs||0)) - (a.influence + (a.tempBuffs||0) - (a.tempDebuffs||0)))[0];\r\n}\r\n\r\nfunction publicNames(state: GameState, p: Player): string[] {\r\n  return state.board[p].innen.map(c => c.name);\r\n}\r\n\r\nfunction hasPublic(state: GameState, p: Player, name: string): boolean {\r\n  return publicNames(state, p).includes(name);\r\n}\r\n\r\nfunction findCardByUidOnBoard(state: GameState, uid: number): Card | null {\r\n  for (const p of [1,2] as const) {\r\n    for (const lane of ['innen','aussen','sofort'] as const) {\r\n      const arr = state.board[p][lane];\r\n      const hit = arr.find(c => c.uid === uid);\r\n      if (hit) return hit;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function resolveQueue(state: GameState, events: EffectEvent[]) {\r\n  const rng = getGlobalRNG();\r\n\r\n  // Single pass FIFO\r\n  while (events.length) {\r\n    const ev = events.shift()!;\r\n\r\n    switch (ev.type) {\r\n      case 'LOG': {\r\n        logPush(state, ev.msg);\r\n        break;\r\n      }\r\n\r\n      case 'ADD_AP': {\r\n        const cur = state.actionPoints[ev.player];\r\n        const next = Math.max(0, cur + ev.amount);\r\n        state.actionPoints[ev.player] = next;\r\n        logPush(state, logAP(ev.player, cur, next));\r\n        break;\r\n      }\r\n\r\n      case 'DRAW_CARDS': {\r\n        for (let i = 0; i < ev.amount; i++) {\r\n          const top = state.decks[ev.player].shift();\r\n          if (top) {\r\n            state.hands[ev.player].push(top);\r\n            logPush(state, logDraw(ev.player, top.name));\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      case 'DISCARD_RANDOM_FROM_HAND': {\r\n        const hand = state.hands[ev.player];\r\n        for (let i = 0; i < ev.amount && hand.length > 0; i++) {\r\n          const idx = rng.randomInt(hand.length);\r\n          const [card] = hand.splice(idx, 1);\r\n          state.discard.push(card);\r\n          logPush(state, logDiscardRandom(ev.player, card.name));\r\n        }\r\n        break;\r\n      }\r\n\r\n      case 'DEACTIVATE_RANDOM_HAND': {\r\n        // Deaktivieren von Handkarten (nicht entfernen)\r\n        const hand = state.hands[ev.player];\r\n        const activeCards = hand.filter(c => !(c as any).deactivated);\r\n        for (let i = 0; i < ev.amount && activeCards.length > 0; i++) {\r\n          const card = rng.pick(activeCards);\r\n          if (card) {\r\n            (card as any).deactivated = true;\r\n            logPush(state, logDeactivateRandom(ev.player, card.name));\r\n            // Entferne aus activeCards für nächste Iteration\r\n            const idx = activeCards.indexOf(card);\r\n            if (idx > -1) activeCards.splice(idx, 1);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      // Legacy cases - removed\r\n      // SET_DISCOUNT and REFUND_NEXT_INITIATIVE are no longer supported\r\n      // Use ADD_AP instead\r\n\r\n      case 'GRANT_SHIELD': {\r\n        if (!state.shields) state.shields = new Set();\r\n        const targetUid = ev.targetUid || 0;\r\n        state.shields.add(targetUid);\r\n        logPush(state, logShield(targetUid));\r\n        break;\r\n      }\r\n\r\n      case 'DEACTIVATE_CARD': {\r\n        const card = findCardByUidOnBoard(state, ev.targetUid);\r\n        if (card) {\r\n          (card as any).deactivated = true;\r\n          logPush(state, logDeactivateCard(card.name));\r\n        }\r\n        break;\r\n      }\r\n\r\n      case 'REACTIVATE_CARD': {\r\n        const card = findCardByUidOnBoard(state, ev.targetUid);\r\n        if (card) {\r\n          (card as any).deactivated = false;\r\n          logPush(state, `🔄 ${card.name} wurde reaktiviert`);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case 'RETURN_TO_HAND': {\r\n        const card = findCardByUidOnBoard(state, ev.targetUid);\r\n        if (card) {\r\n          // Remove from board\r\n          for (const p of [1, 2] as const) {\r\n            for (const lane of ['innen', 'aussen', 'sofort'] as const) {\r\n              const idx = state.board[p][lane].findIndex(c => c.uid === ev.targetUid);\r\n              if (idx !== -1) {\r\n                state.board[p][lane].splice(idx, 1);\r\n                // Add to hand\r\n                state.hands[ev.player].push(card);\r\n                logPush(state, `🔄 ${card.name} wurde zur Hand zurückgegeben`);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      case 'CANCEL_CARD': {\r\n        const card = findCardByUidOnBoard(state, ev.targetUid);\r\n        if (card) {\r\n          // Remove from board and add to discard\r\n          for (const p of [1, 2] as const) {\r\n            for (const lane of ['innen', 'aussen', 'sofort'] as const) {\r\n              const idx = state.board[p][lane].findIndex(c => c.uid === ev.targetUid);\r\n              if (idx !== -1) {\r\n                state.board[p][lane].splice(idx, 1);\r\n                state.discard.push(card);\r\n                logPush(state, `❌ ${card.name} wurde annulliert`);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      case 'REGISTER_TRAP': {\r\n        registerTrap(state, ev.player, (ev as any).key);\r\n        logPush(state, `Trap registered: ${(ev as any).key} (P${ev.player})`);\r\n        break;\r\n      }\r\n\r\n      case 'BUFF_STRONGEST_GOV':\r\n      case 'ADJUST_INFLUENCE': { // Alias auf BUFF_STRONGEST_GOV\r\n        const player = ev.player;\r\n        const amount = (ev as any).amount;\r\n        const tgt = getStrongestGovernment(state, player);\r\n        if (tgt) {\r\n          if (amount >= 0) {\r\n            (tgt as PoliticianCard).tempBuffs = ((tgt as PoliticianCard).tempBuffs || 0) + amount;\r\n          } else {\r\n            (tgt as PoliticianCard).tempDebuffs = ((tgt as PoliticianCard).tempDebuffs || 0) + Math.abs(amount);\r\n          }\r\n          logPush(state, logBuffStrongest(player, tgt.name, amount));\r\n\r\n          // Opportunist-Spiegelung (falls aktiv beim Gegner)\r\n          if (state.effectFlags[other(player)]?.opportunistActive && amount > 0) {\r\n            const mirror = { type: 'BUFF_STRONGEST_GOV', player: other(player), amount } as EffectEvent;\r\n            events.unshift(mirror);\r\n            logPush(state, logOpportunist(other(player), amount));\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      // ===== New intent event handlers =====\r\n\r\n      case 'DEACTIVATE_STRONGEST_ENEMY_GOV': {\r\n        const opp: Player = ev.player === 1 ? 2 : 1;\r\n        const uid = strongestGovernmentUid(state, opp);\r\n        if (uid !== null) {\r\n          events.unshift({ type: 'DEACTIVATE_CARD', player: opp, targetUid: uid });\r\n          events.unshift({ type: 'LOG', msg: 'Party Offensive: strongest enemy Government deactivated.' });\r\n        } else {\r\n          events.unshift({ type: 'LOG', msg: 'Party Offensive: no enemy Government to deactivate.' });\r\n        }\r\n        break;\r\n      }\r\n\r\n      case 'LOCK_OPPONENT_INITIATIVES_EOT': {\r\n        const opp: Player = ev.player === 1 ? 2 : 1;\r\n        state.effectFlags[opp].initiativesLocked = true;\r\n        events.unshift({ type: 'LOG', msg: 'Opposition Blockade: opponent initiatives locked until end of turn.' });\r\n        break;\r\n      }\r\n\r\n      case 'SET_DOUBLE_PUBLIC_AURA': {\r\n        state.effectFlags[ev.player].doublePublicAura = true;\r\n        events.unshift({ type: 'LOG', msg: 'Influencer Campaign: next Public aura will be doubled.' });\r\n        break;\r\n      }\r\n\r\n      case 'SET_OPPORTUNIST_ACTIVE': {\r\n        const { player, active } = ev as { type: 'SET_OPPORTUNIST_ACTIVE'; player: Player; active: boolean };\r\n        state.effectFlags[player].opportunistActive = active;\r\n        if (active) {\r\n          events.unshift({ type: 'LOG', msg: 'Opportunist: AP effects will be mirrored until end of turn.' });\r\n        }\r\n        break;\r\n      }\r\n\r\n      case 'GOVERNMENT_CARD_PLAYED': {\r\n        const f = state.effectFlags[ev.player];\r\n        // Greta Thunberg AP on first government card\r\n        if (f.gretaFirstGovAp) {\r\n          const cur = state.actionPoints[ev.player];\r\n          state.actionPoints[ev.player] = cur + 1;\r\n          f.gretaFirstGovAp = false;\r\n          logPush(state, 'Greta Thunberg: +1 AP on first government card played.');\r\n        }\r\n        \r\n        // Check for George Soros AP bonus (when opponent gets authoritarian government)\r\n        const otherPlayer = ev.player === 1 ? 2 : 1;\r\n        const otherF = state.effectFlags[otherPlayer];\r\n        if (otherF.sorosAuthoritarianAp) {\r\n          // Check if the played card is authoritarian\r\n          const playedCard = state.permanentSlots[ev.player].government;\r\n          if (playedCard && isAuthoritarianGovernment(playedCard)) {\r\n            const cur = state.actionPoints[otherPlayer];\r\n            state.actionPoints[otherPlayer] = cur + 1;\r\n            otherF.sorosAuthoritarianAp = false;\r\n            logPush(state, `George Soros: +1 AP (opponent played authoritarian government: ${playedCard.name}).`);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      case 'INITIATIVE_ACTIVATED': {\r\n        // Existing logic plus new flag consumptions\r\n        const f = state.effectFlags[ev.player];\r\n        // Mark Zuckerberg AP once/turn\r\n        if (f.zuckOnceAp && !f.zuckSpent) {\r\n          const cur = state.actionPoints[ev.player];\r\n          state.actionPoints[ev.player] = cur + 1;\r\n          f.zuckSpent = true;\r\n          logPush(state, 'Mark Zuckerberg: +1 AP once per turn.');\r\n        }\r\n        // Elon Musk AP once/turn\r\n        if (f.elonOnceAp && !f.elonSpent) {\r\n          const cur = state.actionPoints[ev.player];\r\n          state.actionPoints[ev.player] = cur + 1;\r\n          f.elonSpent = true;\r\n          logPush(state, 'Elon Musk: +1 AP once per turn after initiative activation.');\r\n        }\r\n        // Bill Gates AP on next initiative\r\n        if (f.gatesNextInitiativeAp) {\r\n          const cur = state.actionPoints[ev.player];\r\n          state.actionPoints[ev.player] = cur + 1;\r\n          f.gatesNextInitiativeAp = false;\r\n          logPush(state, 'Bill Gates: +1 AP on initiative activation.');\r\n        }\r\n        if (f.aiWeiweiOnActivate) {\r\n          const top = state.decks[ev.player].shift();\r\n          if (top) state.hands[ev.player].push(top);\r\n          state.actionPoints[ev.player] += 1;\r\n          f.aiWeiweiOnActivate = false;\r\n          logPush(state, 'Ai Weiwei: drew 1 card and gained +1 AP.');\r\n        }\r\n        // Simplified AP system: No initiative-specific bonuses\r\n        // All AP bonuses are now immediate ADD_AP events\r\n        // Double Public Aura – note (consumption happens separately)\r\n        if (f.doublePublicAura) {\r\n          if (!state._effectQueue) state._effectQueue = [];\r\n          state._effectQueue.push({ type: 'LOG', msg: 'Double Public Aura is armed.' });\r\n        }\r\n        break;\r\n      }\r\n\r\n      // Simplified AP system: No initiative-specific bonuses\r\n      // All AP bonuses are now immediate ADD_AP events\r\n\r\n\r\n    }\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}