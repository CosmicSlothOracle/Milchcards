{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nimport { createDefaultEffectFlags } from '../types/game';\nimport { Pols, Specials, PRESET_DECKS } from '../data/gameData';\nimport { sumRow, shuffle, makePolInstance, makeSpecInstance, buildDeckFromEntries, drawCards, drawCardsAtRoundEnd, tryApplyNegativeEffect, adjustInfluence, findCardLocation, sumGovernmentInfluenceWithAuras, EffectQueueManager, ActiveAbilitiesManager } from '../utils/gameUtils';\nimport { getCardDetails } from '../data/cardDetails';\nimport { useGameActions } from './useGameActions';\nimport { useGameAI } from './useGameAI';\nimport { useGameEffects } from './useGameEffects';\nimport { applyStartOfTurnHooks } from '../utils/startOfTurnHooks';\nimport { emptyBoard } from '../state/board';\nconst initialGameState = {\n  round: 1,\n  current: 1,\n  passed: {\n    1: false,\n    2: false\n  },\n  actionPoints: {\n    1: 2,\n    2: 2\n  },\n  actionsUsed: {\n    1: 0,\n    2: 0\n  },\n  decks: {\n    1: [],\n    2: []\n  },\n  hands: {\n    1: [],\n    2: []\n  },\n  traps: {\n    1: [],\n    2: []\n  },\n  board: emptyBoard(),\n  permanentSlots: {\n    1: {\n      government: null,\n      public: null,\n      initiativePermanent: null,\n      initiativePermanent: null\n    },\n    2: {\n      government: null,\n      public: null,\n      initiativePermanent: null,\n      initiativePermanent: null\n    }\n  },\n  discard: [],\n  log: [],\n  activeRefresh: {\n    1: 0,\n    2: 0\n  },\n  roundsWon: {\n    1: 0,\n    2: 0\n  },\n  gameWinner: null,\n  effectFlags: {\n    1: createDefaultEffectFlags(),\n    2: createDefaultEffectFlags()\n  },\n  effectQueue: EffectQueueManager.initializeQueue(),\n  activeAbilities: {\n    1: [],\n    2: []\n  },\n  pendingAbilitySelect: undefined,\n  aiEnabled: {\n    1: false,\n    2: false\n  }\n};\nexport function useGameState() {\n  _s();\n  const [gameState, setGameState] = useState(initialGameState);\n  const [selectedHandIndex, setSelectedHandIndex] = useState(null);\n  const log = useCallback(msg => {\n    const timestamp = new Date().toLocaleTimeString('de-DE', {\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit'\n    });\n    const logEntry = `[${timestamp}] ${msg}`;\n    console.log(logEntry); // Also log to console for debugging\n\n    setGameState(prev => ({\n      ...prev,\n      log: [...prev.log, logEntry]\n    }));\n  }, []);\n\n  // Enhanced logging functions for different types of events\n  const logUIInteraction = useCallback((action, details) => {\n    log(`🎯 UI: ${action} - ${details}`);\n  }, [log]);\n  const logGameStateChange = useCallback((change, details) => {\n    log(`🔄 STATE: ${change} - ${details}`);\n  }, [log]);\n  const logAIAction = useCallback((action, details) => {\n    log(`🤖 KI: ${action} - ${details}`);\n  }, [log]);\n  const logCardEffect = useCallback((cardName, effect) => {\n    log(`✨ EFFEKT: ${cardName} - ${effect}`);\n  }, [log]);\n  const logIntervention = useCallback((interventionName, trigger) => {\n    log(`💥 INTERVENTION: ${interventionName} ausgelöst durch ${trigger}`);\n  }, [log]);\n\n  // New detailed logging functions for debugging\n  const logFunctionCall = useCallback((functionName, params, context) => {\n    const paramStr = typeof params === 'object' ? JSON.stringify(params, null, 2) : String(params);\n    log(`🔧 CALL: ${functionName}(${paramStr}) - ${context}`);\n  }, [log]);\n  const logDataFlow = useCallback((from, to, data, action) => {\n    const dataStr = typeof data === 'object' ? JSON.stringify(data, null, 2) : String(data);\n    log(`📊 FLOW: ${from} → ${to} | ${action} | Data: ${dataStr}`);\n  }, [log]);\n  const logConditionCheck = useCallback((condition, result, context) => {\n    log(`🔍 CHECK: ${condition} = ${result} - ${context}`);\n  }, [log]);\n  const logError = useCallback((error, context) => {\n    log(`❌ ERROR: ${error} - ${context}`);\n  }, [log]);\n  const logWarning = useCallback((warning, context) => {\n    log(`⚠️ WARN: ${warning} - ${context}`);\n  }, [log]);\n\n  // Nach Queue-Auflösung: Hand-Arrays immutabel neu zuweisen → Canvas & UI bekommen die neuen UIDs\n  const afterQueueResolved = useCallback(() => {\n    setGameState(s => {\n      var _version;\n      const n = {\n        ...s\n      };\n      n.hands = {\n        1: [...s.hands[1]],\n        2: [...s.hands[2]]\n      };\n      // optional: version bump für Canvas\n      n._version = ((_version = s._version) !== null && _version !== void 0 ? _version : 0) + 1;\n      return n;\n    });\n  }, []);\n\n  // Import functionality from separated hooks\n  const gameActions = useGameActions(gameState, setGameState, log, afterQueueResolved);\n  const gameAI = useGameAI(gameState, setGameState, log);\n  const gameEffects = useGameEffects(gameState, setGameState, log);\n  const dealStartingHands = useCallback(() => {\n    console.log('[DIAG] dealStartingHands called');\n    function buildDeck() {\n      const polPool = [...Pols];\n      const specPool = [...Specials];\n      shuffle(polPool);\n      shuffle(specPool);\n      const deck = [];\n      polPool.slice(0, 14).forEach(p => deck.push(makePolInstance(p)));\n\n      // prefer more useful/implemented specials\n      const implFirst = ['media', 'pledge', 'pledge2', 'sanctions', 'dnc1', 'dnc2', 'dnc3', 'reshuffle', 'mission', 'trap_fakenews', 'trap_protest', 'trap_scandal'];\n      const srt = specPool.slice().sort((a, b) => implFirst.indexOf(a.impl) - implFirst.indexOf(b.impl));\n      srt.slice(0, 11).forEach(s => deck.push(makeSpecInstance(s)));\n      return shuffle(deck).slice(0, 25);\n    }\n    const deck1 = buildDeck();\n    const deck2 = buildDeck();\n    console.log('[DIAG] built decks lengths', deck1.length, deck2.length);\n    setGameState(prev => ({\n      ...prev,\n      decks: {\n        1: deck1,\n        2: deck2\n      },\n      hands: {\n        1: deck1.splice(0, 5),\n        2: deck2.splice(0, 5)\n      }\n    }));\n    console.log('[DIAG] setGameState after deal: hands[1].length', deck1.length >= 5 ? 5 : deck1.length);\n  }, []);\n  const startNewGame = useCallback(() => {\n    setGameState({\n      ...initialGameState,\n      round: 1,\n      current: 1,\n      passed: {\n        1: false,\n        2: false\n      },\n      actionPoints: {\n        1: 2,\n        2: 2\n      },\n      actionsUsed: {\n        1: 0,\n        2: 0\n      },\n      board: emptyBoard(),\n      traps: {\n        1: [],\n        2: []\n      },\n      permanentSlots: {\n        1: {\n          government: null,\n          public: null,\n          initiativePermanent: null\n        },\n        2: {\n          government: null,\n          public: null,\n          initiativePermanent: null\n        }\n      },\n      // instantSlot wird nicht mehr verwendet - Sofort-Initiativen gehen in board[player].sofort\n      discard: [],\n      log: [],\n      activeRefresh: {\n        1: 0,\n        2: 0\n      }\n    });\n    dealStartingHands();\n  }, [dealStartingHands]);\n  const startMatchWithDecks = useCallback((p1DeckEntries, p2DeckEntries) => {\n    console.log('🔧 DEBUG: startMatchWithDecks called - activating AI for player 2');\n    // Automatically enable AI for player 2 when starting with decks\n    console.log('🔧 DEBUG: About to call gameAI.setAiEnabled(true)');\n    gameAI.setAiEnabled(true);\n    console.log('🔧 DEBUG: About to call gameAI.setAiPreset(AUTORITAERER_REALIST)');\n    gameAI.setAiPreset('AUTORITAERER_REALIST');\n    console.log('🔧 DEBUG: AI setup completed');\n    console.log('[DIAG] startMatchWithDecks - p1DeckEntries', p1DeckEntries.length, 'p2DeckEntries', p2DeckEntries.length);\n    console.log('[DIAG] startMatchWithDecks - sample entries:', p1DeckEntries.slice(0, 2), p2DeckEntries.slice(0, 2));\n    const p1Cards = buildDeckFromEntries(p1DeckEntries);\n    const p2Cards = buildDeckFromEntries(p2DeckEntries);\n    const d1 = [...p1Cards];\n    const d2 = [...p2Cards];\n    const h1 = d1.splice(0, Math.min(5, d1.length));\n    const h2 = d2.splice(0, Math.min(5, d2.length));\n    console.log('[DIAG] startMatchWithDecks - p1Cards', p1Cards.length, 'p2Cards', p2Cards.length);\n    console.log('[DIAG] startMatchWithDecks - h1', h1.length, 'h2', h2.length);\n    console.log('[DIAG] startMatchWithDecks - sample cards:', p1Cards.slice(0, 2), p2Cards.slice(0, 2));\n    setGameState({\n      ...initialGameState,\n      round: 1,\n      current: 1,\n      passed: {\n        1: false,\n        2: false\n      },\n      decks: {\n        1: d1,\n        2: d2\n      },\n      hands: {\n        1: h1,\n        2: h2\n      },\n      board: emptyBoard(),\n      traps: {\n        1: [],\n        2: []\n      },\n      permanentSlots: {\n        1: {\n          government: null,\n          public: null,\n          initiativePermanent: null\n        },\n        2: {\n          government: null,\n          public: null,\n          initiativePermanent: null\n        }\n      },\n      // instantSlot wird nicht mehr verwendet - Sofort-Initiativen gehen in board[player].sofort\n      discard: [],\n      log: [`Match gestartet. P1 und P2 erhalten je ${h1.length}/${h2.length} Startkarten.`],\n      activeRefresh: {\n        1: 0,\n        2: 0\n      }\n    });\n    console.log('[DIAG] setGameState called in startMatchWithDecks');\n  }, [gameAI]);\n  const startMatchVsAI = useCallback((p1DeckEntries, presetKey = 'AUTORITAERER_REALIST') => {\n    const p2DeckEntries = PRESET_DECKS[presetKey];\n    gameAI.setAiEnabled(true);\n    gameAI.setAiPreset(presetKey);\n    gameActions.startMatchWithDecks(p1DeckEntries, p2DeckEntries);\n  }, [gameAI, gameActions]);\n\n  // Prüfe ob der Zug automatisch gewechselt werden soll\n  const shouldAdvanceTurn = useCallback((gameState, player) => {\n    // Wenn Spieler gepasst hat\n    if (gameState.passed[player]) return true;\n\n    // Wenn keine AP mehr verfügbar sind\n    if (gameState.actionPoints[player] <= 0) return true;\n\n    // Wenn 2 Aktionen verwendet wurden\n    // if (gameState.actionsUsed[player] >= 2) return true;\n\n    return false;\n  }, []);\n\n  // Karten-Effekte implementieren\n  const executeCardEffect = useCallback((card, player, state, logFunc) => {\n    let newState = {\n      ...state\n    };\n    logFunctionCall('executeCardEffect', {\n      card: card.name,\n      player,\n      type: card.kind\n    }, 'Starting card effect execution');\n    if (card.kind === 'spec') {\n      const specCard = card;\n\n      // === SOFORT-INITIATIVEN ===\n      if (specCard.name === 'Shadow Lobbying') {\n        var _newState$effectFlags;\n        logCardEffect(specCard.name, 'Öffentlichkeits-Effekte zählen doppelt diese Runde');\n        const flags = {\n          ...((_newState$effectFlags = newState.effectFlags) === null || _newState$effectFlags === void 0 ? void 0 : _newState$effectFlags[player]),\n          publicEffectDoubled: true\n        };\n        newState.effectFlags = {\n          ...newState.effectFlags,\n          [player]: flags\n        };\n        logDataFlow('effectFlags', 'newState', {\n          player,\n          publicEffectDoubled: true\n        }, 'Shadow Lobbying flag set');\n      } else if (specCard.name === 'Spin Doctor') {\n        const govCards = newState.board[player].aussen.filter(c => c.kind === 'pol');\n        logDataFlow('board analysis', 'govCards', {\n          count: govCards.length,\n          cards: govCards.map(c => c.name)\n        }, 'Finding government cards');\n        if (govCards.length > 0) {\n          const targetCard = govCards[0];\n          const oldInfluence = targetCard.influence;\n          adjustInfluence(targetCard, 2, 'Spin Doctor');\n          const newInfluence = targetCard.influence;\n          logCardEffect(specCard.name, `${targetCard.name} erhält +2 Einfluss (${oldInfluence} → ${newInfluence})`);\n          logDataFlow('influence adjustment', 'targetCard', {\n            card: targetCard.name,\n            old: oldInfluence,\n            new: newInfluence,\n            change: 2\n          }, 'Spin Doctor effect applied');\n        } else {\n          logWarning('No government cards found', 'Spin Doctor effect has no target');\n        }\n      } else if (specCard.name === 'Digitaler Wahlkampf') {\n        logCardEffect(specCard.name, 'Ziehe 2 Karten, nächste Initiative -1 AP');\n        const {\n          newHands,\n          newDecks\n        } = drawCards(player, 2, newState, logFunc);\n        newState = {\n          ...newState,\n          hands: newHands,\n          decks: newDecks\n        };\n\n        // Simplified AP system: No discounts\n        logDataFlow('effectFlags', 'newState', {\n          player\n        }, 'Platform effect applied');\n      } else if (specCard.name === 'Partei-Offensive') {\n        const opponent = player === 1 ? 2 : 1;\n        const oppGovCards = newState.board[opponent].aussen.filter(c => c.kind === 'pol' && !c.deactivated);\n        logDataFlow('opponent analysis', 'oppGovCards', {\n          opponent,\n          count: oppGovCards.length,\n          cards: oppGovCards.map(c => c.name)\n        }, 'Finding active opponent government cards');\n        if (oppGovCards.length > 0) {\n          const targetCard = oppGovCards[0];\n          targetCard.deactivated = true;\n          logCardEffect(specCard.name, `${targetCard.name} wird deaktiviert (bis Rundenende)`);\n          logDataFlow('card deactivation', 'targetCard', {\n            card: targetCard.name,\n            deactivated: true\n          }, 'Partei-Offensive effect applied');\n        } else {\n          logWarning('No active opponent government cards found', 'Partei-Offensive effect has no target');\n        }\n      } else if (specCard.name === 'Oppositionsblockade') {\n        const opponent = player === 1 ? 2 : 1;\n        const oppHand = newState.hands[opponent];\n        logDataFlow('opponent hand', 'analysis', {\n          opponent,\n          handSize: oppHand.length,\n          cards: oppHand.map(c => c.name)\n        }, 'Analyzing opponent hand');\n        if (oppHand.length > 0) {\n          const discardedCard = oppHand[Math.floor(Math.random() * oppHand.length)];\n          const newOppHand = oppHand.filter(c => c !== discardedCard);\n          newState.hands = {\n            ...newState.hands,\n            [opponent]: newOppHand\n          };\n          logCardEffect(specCard.name, `Gegner verliert ${discardedCard.name} aus der Hand`);\n          logDataFlow('card discard', 'opponent hand', {\n            card: discardedCard.name,\n            newHandSize: newOppHand.length\n          }, 'Oppositionsblockade effect applied');\n        } else {\n          logWarning('Opponent hand is empty', 'Oppositionsblockade effect has no target');\n        }\n      } else if (specCard.name === 'Opportunist') {\n        const opponent = player === 1 ? 2 : 1;\n        const oppBoard = newState.board[opponent];\n        const totalOppInfluence = sumRow([...oppBoard.innen, ...oppBoard.aussen]);\n        logDataFlow('opponent board analysis', 'influence calculation', {\n          opponent,\n          innen: oppBoard.innen.map(c => ({\n            name: c.name,\n            influence: c.kind === 'pol' ? c.influence : 0\n          })),\n          aussen: oppBoard.aussen.map(c => ({\n            name: c.name,\n            influence: c.kind === 'pol' ? c.influence : 0\n          })),\n          totalInfluence: totalOppInfluence\n        }, 'Calculating opponent total influence');\n        if (totalOppInfluence > 10) {\n          const {\n            newHands,\n            newDecks\n          } = drawCards(player, 1, newState, logFunc);\n          newState = {\n            ...newState,\n            hands: newHands,\n            decks: newDecks\n          };\n          logCardEffect(specCard.name, `Gegner hat ${totalOppInfluence} Einfluss (>10) - ziehe 1 Karte`);\n        } else {\n          logCardEffect(specCard.name, `Gegner hat ${totalOppInfluence} Einfluss (≤10) - kein Effekt`);\n        }\n      } else if (specCard.name === 'Think-tank') {\n        const {\n          newHands,\n          newDecks\n        } = drawCards(player, 1, newState, logFunc);\n        newState = {\n          ...newState,\n          hands: newHands,\n          decks: newDecks\n        };\n        logCardEffect(specCard.name, 'Ziehe 1 Karte');\n      } else if (specCard.name === 'Influencer-Kampagne') {\n        const publicCards = newState.board[player].innen.filter(c => c.kind === 'pol');\n        logDataFlow('public cards analysis', 'influence boost', {\n          count: publicCards.length,\n          cards: publicCards.map(c => c.name)\n        }, 'Finding public cards for influence boost');\n        publicCards.forEach(card => {\n          const oldInfluence = card.influence;\n          adjustInfluence(card, 1, 'Influencer-Kampagne');\n          const newInfluence = card.influence;\n          logCardEffect(specCard.name, `${card.name} erhält +1 Einfluss (${oldInfluence} → ${newInfluence})`);\n        });\n        if (publicCards.length === 0) {\n          logWarning('No public cards found', 'Influencer-Kampagne effect has no targets');\n        }\n      } else if (specCard.name === 'Systemrelevant') {\n        const opponent = player === 1 ? 2 : 1;\n        const oppGovCards = newState.board[opponent].aussen.filter(c => c.kind === 'pol');\n        logDataFlow('opponent government analysis', 'systemrelevant effect', {\n          count: oppGovCards.length,\n          cards: oppGovCards.map(c => c.name)\n        }, 'Finding opponent government cards');\n        if (oppGovCards.length > 0) {\n          const targetCard = oppGovCards[0];\n          const oldInfluence = targetCard.influence;\n          adjustInfluence(targetCard, -2, 'Systemrelevant');\n          const newInfluence = targetCard.influence;\n          logCardEffect(specCard.name, `${targetCard.name} verliert 2 Einfluss (${oldInfluence} → ${newInfluence})`);\n          logDataFlow('influence reduction', 'targetCard', {\n            card: targetCard.name,\n            old: oldInfluence,\n            new: newInfluence,\n            change: -2\n          }, 'Systemrelevant effect applied');\n        } else {\n          logWarning('No opponent government cards found', 'Systemrelevant effect has no target');\n        }\n      } else if (specCard.name === 'Symbolpolitik') {\n        const {\n          newHands,\n          newDecks\n        } = drawCards(player, 1, newState, logFunc);\n        newState = {\n          ...newState,\n          hands: newHands,\n          decks: newDecks\n        };\n        newState.actionPoints = {\n          ...newState.actionPoints,\n          [player]: Math.min(2, newState.actionPoints[player] + 1)\n        };\n        const oldAP = state.actionPoints[player];\n        const newAP = newState.actionPoints[player];\n        logCardEffect(specCard.name, `Ziehe 1 Karte, erhalte +1 AP (${oldAP} → ${newAP})`);\n        logDataFlow('AP gain', 'player', {\n          player,\n          old: oldAP,\n          new: newAP,\n          change: 1\n        }, 'Symbolpolitik effect applied');\n      } else if (specCard.name === 'Alexei Navalny') {\n        logCardEffect(specCard.name, 'Ziehe 1 Karte');\n        const {\n          newHands,\n          newDecks\n        } = drawCards(player, 1, newState, logFunc);\n        newState = {\n          ...newState,\n          hands: newHands,\n          decks: newDecks\n        };\n      } else if (specCard.name === 'Mukesh Ambani') {\n        logCardEffect(specCard.name, 'Ziehe 1 Karte');\n        const {\n          newHands,\n          newDecks\n        } = drawCards(player, 1, newState, logFunc);\n        newState = {\n          ...newState,\n          hands: newHands,\n          decks: newDecks\n        };\n      }\n\n      // Oligarch-Effekte\n      else if (['Elon Musk', 'Bill Gates', 'George Soros', 'Warren Buffett', 'Mukesh Ambani', 'Jeff Bezos', 'Alisher Usmanov', 'Gautam Adani', 'Jack Ma', 'Zhang Yiming', 'Roman Abramovich'].includes(specCard.name)) {\n        logCardEffect(specCard.name, 'Ziehe 1 Karte (Oligarch-Effekt)');\n        const {\n          newHands,\n          newDecks\n        } = drawCards(player, 1, newState, logFunc);\n        newState = {\n          ...newState,\n          hands: newHands,\n          decks: newDecks\n        };\n      }\n    }\n\n    // === DAUERHAFTE INITIATIVEN ===\n    if (card.kind === 'spec' && card.type === 'Dauerhaft-Initiative') {\n      const specCard = card;\n      if (specCard.name === 'Algorithmischer Diskurs') {\n        logCardEffect(specCard.name, 'Dauerhafte Initiative: Alle Medien-Karten geben +1 Einfluss');\n        // This effect will be applied in applyStartOfTurnHooks\n      } else if (specCard.name === 'Alternative Fakten') {\n        logCardEffect(specCard.name, 'Dauerhafte Initiative: Alle Oligarchen geben +1 Einfluss');\n        // This effect will be applied in applyStartOfTurnHooks\n      }\n    }\n\n    // === POLITIKER-KARTEN ===\n    else if (card.kind === 'pol') {\n      const polCard = card;\n      logCardEffect(polCard.name, `Politiker platziert - Basis-Einfluss: ${polCard.influence}`);\n    }\n    logDataFlow('executeCardEffect', 'newState', {\n      card: card.name,\n      effectsApplied: true\n    }, 'Card effect execution completed');\n    return newState;\n  }, [logFunctionCall, logCardEffect, logDataFlow, logWarning]);\n  const nextTurn = useCallback(() => {\n    logFunctionCall('nextTurn', {}, 'Starting turn change');\n    setGameState(prev => {\n      var _prev$aiEnabled$, _prev$aiEnabled, _prev$aiEnabled$2, _prev$aiEnabled2, _prev$aiEnabled$3, _prev$aiEnabled3;\n      logDataFlow('UI', 'nextTurn', {\n        current: prev.current,\n        passed: prev.passed\n      }, 'Turn change request');\n\n      // if both passed -> resolve round\n      logConditionCheck('both players passed', prev.passed[1] && prev.passed[2], 'Round end check');\n      if (prev.passed[1] && prev.passed[2]) {\n        logFunctionCall('resolveRound', {\n          round: prev.round\n        }, 'Both players passed - resolving round');\n        return resolveRound(prev);\n      }\n      const newCurrent = prev.current === 1 ? 2 : 1;\n      logDataFlow('turn change', 'newCurrent', {\n        old: prev.current,\n        new: newCurrent\n      }, 'Player switch');\n\n      // Reset AP for the new current player\n      const newActionPoints = {\n        ...prev.actionPoints\n      };\n      newActionPoints[newCurrent] = 2;\n      logDataFlow('AP reset', 'newCurrent', {\n        player: newCurrent,\n        oldAP: prev.actionPoints[newCurrent],\n        newAP: newActionPoints[newCurrent],\n        oldActions: 0,\n        newActions: 0\n      }, 'Resource reset for new player');\n\n      // Apply start-of-turn hooks for the new current player\n      const newState = {\n        ...prev,\n        current: newCurrent,\n        actionPoints: newActionPoints\n      };\n\n      // Log turn change\n      log(`Spieler ${newCurrent} ist am Zug (2 AP verfügbar)`);\n      logGameStateChange('turn change', `Player ${newCurrent} turn started`);\n      logFunctionCall('applyStartOfTurnHooks', {\n        player: newCurrent\n      }, 'Applying start-of-turn effects');\n      applyStartOfTurnHooks(newState, newCurrent, log);\n\n      // Check if AI should take turn\n      logConditionCheck('AI turn', newCurrent === 2 && ((_prev$aiEnabled$ = (_prev$aiEnabled = prev.aiEnabled) === null || _prev$aiEnabled === void 0 ? void 0 : _prev$aiEnabled[2]) !== null && _prev$aiEnabled$ !== void 0 ? _prev$aiEnabled$ : false), 'AI turn check');\n      if (newCurrent === 2 && ((_prev$aiEnabled$2 = (_prev$aiEnabled2 = prev.aiEnabled) === null || _prev$aiEnabled2 === void 0 ? void 0 : _prev$aiEnabled2[2]) !== null && _prev$aiEnabled$2 !== void 0 ? _prev$aiEnabled$2 : false)) {\n        logFunctionCall('runAITurn', {\n          player: newCurrent\n        }, 'Triggering AI turn');\n        // Use setTimeout to avoid state update conflicts\n        setTimeout(() => {\n          logAIAction('AI turn triggered', 'Starting AI turn execution');\n          gameAI.runAITurn();\n        }, 100);\n      }\n      logDataFlow('nextTurn', 'finalState', {\n        current: newState.current,\n        ap: newState.actionPoints[newCurrent],\n        aiEnabled: (_prev$aiEnabled$3 = (_prev$aiEnabled3 = prev.aiEnabled) === null || _prev$aiEnabled3 === void 0 ? void 0 : _prev$aiEnabled3[2]) !== null && _prev$aiEnabled$3 !== void 0 ? _prev$aiEnabled$3 : false\n      }, 'Turn change completed');\n      return newState;\n    });\n\n    // Nach Zugwechsel ebenfalls spiegeln (z. B. Auto-Draw am EoT)\n    afterQueueResolved();\n  }, [logFunctionCall, logDataFlow, logConditionCheck, logGameStateChange, gameAI, log, logAIAction, afterQueueResolved]);\n\n  // Automatischer Zugwechsel basierend auf AP\n  const checkAndAdvanceTurn = useCallback(gameState => {\n    const currentPlayer = gameState.current;\n    if (shouldAdvanceTurn(gameState, currentPlayer)) {\n      // Nur wechseln wenn der andere Spieler nicht auch fertig ist\n      const otherPlayer = currentPlayer === 1 ? 2 : 1;\n      if (!shouldAdvanceTurn(gameState, otherPlayer) || gameState.passed[otherPlayer]) {\n        nextTurn();\n      }\n    }\n  }, [shouldAdvanceTurn, nextTurn]);\n  const scores = useCallback(state => {\n    // Einheitliche Berechnung über Utils-Helfer\n    const s1 = sumGovernmentInfluenceWithAuras(state, 1);\n    const s2 = sumGovernmentInfluenceWithAuras(state, 2);\n    return [s1, s2];\n  }, []);\n  const resolveRound = useCallback(state => {\n    const [s1, s2] = scores(state);\n    let winner = 1;\n    let note = '';\n    if (s1 > s2) winner = 1;else if (s2 > s1) winner = 2;else {\n      // Gleichstand -> erster Pass gewinnt\n      winner = state.passed[1] && !state.passed[2] ? 1 : 2;\n      note = ' (Gleichstand – früherer Pass)';\n    }\n    log(`Runde ${state.round} endet: P1 ${s1} : P2 ${s2}. Gewinner: P${winner}${note}.`);\n\n    // Rundensieg zählen\n    const newRoundsWon = {\n      ...state.roundsWon\n    };\n    newRoundsWon[winner] += 1;\n\n    // Prüfe Best-of-3 Gewinner\n    let gameWinner = null;\n    if (newRoundsWon[1] >= 2) {\n      gameWinner = 1;\n      log(`🎉 SPIEL ENDE: Spieler 1 gewinnt das Spiel! (${newRoundsWon[1]}:${newRoundsWon[2]})`);\n    } else if (newRoundsWon[2] >= 2) {\n      gameWinner = 2;\n      log(`🎉 SPIEL ENDE: Spieler 2 gewinnt das Spiel! (${newRoundsWon[2]}:${newRoundsWon[1]})`);\n    }\n\n    // clear board (no carryover)\n    const newBoard = emptyBoard();\n    const newTraps = {\n      1: [],\n      2: []\n    };\n\n    // Verbesserte Karten-Nachzieh-Mechanik (ziehe bis Hand voll ist)\n    const {\n      newHands,\n      newDecks\n    } = drawCardsAtRoundEnd(state, log);\n    const newRound = state.round + 1;\n    const newPassed = {\n      1: false,\n      2: false\n    };\n    // alternate starter each round\n    const newCurrent = newRound % 2 === 1 ? 1 : 2;\n\n    // Wenn Spiel zu Ende, stoppe\n    if (gameWinner) {\n      return {\n        ...state,\n        roundsWon: newRoundsWon,\n        gameWinner\n      };\n    }\n    log(`Runde ${newRound} beginnt. P${newCurrent} startet.`);\n\n    // 🔥 CLUSTER 3: Reset temporäre Initiative-Boni am Rundenende\n    const newEffectFlags = {\n      1: {\n        ...state.effectFlags[1],\n        // Reset Cluster 3 Flags\n        scienceInitiativeBonus: false,\n        militaryInitiativePenalty: false,\n        healthInitiativeBonus: false,\n        cultureInitiativeBonus: false,\n        // Reset andere rundenbasierte Flags\n        markZuckerbergUsed: false,\n        opportunistActive: false,\n        publicEffectDoubled: false,\n        cannotPlayInitiatives: false,\n        nextCardProtected: false,\n        platformAfterInitiativeBonus: false,\n        interventionEffectReduced: false\n      },\n      2: {\n        ...state.effectFlags[2],\n        // Reset Cluster 3 Flags\n        scienceInitiativeBonus: false,\n        militaryInitiativePenalty: false,\n        healthInitiativeBonus: false,\n        cultureInitiativeBonus: false,\n        // Reset andere rundenbasierte Flags\n        markZuckerbergUsed: false,\n        opportunistActive: false,\n        publicEffectDoubled: false,\n        cannotPlayInitiatives: false,\n        nextCardProtected: false,\n        platformAfterInitiativeBonus: false,\n        interventionEffectReduced: false\n      }\n    };\n    return {\n      ...state,\n      round: newRound,\n      current: newCurrent,\n      passed: newPassed,\n      board: newBoard,\n      traps: newTraps,\n      hands: newHands,\n      decks: newDecks,\n      roundsWon: newRoundsWon,\n      effectFlags: newEffectFlags\n    };\n  }, [log, scores]);\n\n  // Einfache Interventionsauswertung für einige häufige Trigger\n  const evaluateInterventions = (prev, actingPlayer, event, tentativeBoard) => {\n    const opponent = actingPlayer === 1 ? 2 : 1;\n    const oppTraps = [...(prev.traps[opponent] || [])];\n    let board = tentativeBoard;\n    let trapsChanged = false;\n    for (let i = 0; i < oppTraps.length; i++) {\n      const trap = oppTraps[i];\n      if (trap.kind !== 'spec') continue;\n      const spec = trap;\n      const details = getCardDetails(spec.name);\n      const key = spec.key;\n\n      // Trigger: Karte gespielt\n      if (event.type === 'card_played' && event.card) {\n        const played = event.card;\n        const isMedia = ['Oprah Winfrey'].includes(played.name);\n        const isNGO = ['Bill Gates', 'Jennifer Doudna', 'Noam Chomsky'].includes(played.name);\n        const isPlatform = ['Mark Zuckerberg', 'Tim Cook', 'Jack Ma', 'Zhang Yiming'].includes(played.name);\n        const isDiplomat = ['Joschka Fischer', 'Sergey Lavrov', 'Ursula von der Leyen', 'Jens Stoltenberg', 'Hans Dietrich Genscher', 'Colin Powell', 'Condoleezza Rice', 'Christine Lagarde'].includes(played.name);\n        const isTier2Gov = played.T === 2 && event.lane === 'aussen';\n        const isTier1Gov = played.T === 1 && event.lane === 'aussen';\n        const isWeakGov = played.influence <= 5 && event.lane === 'aussen';\n        const isLowPowerGov = played.influence <= 4 && event.lane === 'aussen';\n\n        // Cancel Culture / Fake News-Kampagne\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Cancel Culture' || key === 'Cancel_Culture') && event.lane === 'innen') {\n          tryApplyNegativeEffect(played, () => {\n            played.deactivated = true;\n          }, prev.round);\n          oppTraps.splice(i, 1);\n          i--;\n          trapsChanged = true;\n          log(`Intervention ausgelöst: Cancel Culture → ${played.name} deaktiviert.`);\n          logIntervention('Cancel Culture', `Ausgelöst gegen ${played.name} in Öffentlichkeit`);\n          continue;\n        }\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Fake News-Kampagne' || key === 'Fake_News_Kampagne') && isMedia) {\n          tryApplyNegativeEffect(played, () => {\n            played.deactivated = true;\n          }, prev.round);\n          oppTraps.splice(i, 1);\n          i--;\n          trapsChanged = true;\n          log(`Intervention ausgelöst: Fake News-Kampagne → ${played.name} deaktiviert.`);\n          logIntervention('Fake News-Kampagne', `Ausgelöst gegen ${played.name} (Medien)`);\n          continue;\n        }\n\n        // Whistleblower (Tier 2 Regierung)\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Whistleblower' || key === 'Whistleblower') && isTier2Gov) {\n          tryApplyNegativeEffect(played, () => {\n            adjustInfluence(played, -2, 'Whistleblower');\n          }, prev.round);\n          oppTraps.splice(i, 1);\n          i--;\n          trapsChanged = true;\n          log(`Intervention ausgelöst: Whistleblower → ${played.name} -2 Einfluss.`);\n          continue;\n        }\n\n        // Berater-Affäre (Tier 1 Regierung)\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Berater-Affäre' || key === 'Berater_Affaere') && isTier1Gov) {\n          tryApplyNegativeEffect(played, () => {\n            adjustInfluence(played, -2, 'Berater-Affäre');\n          }, prev.round);\n          oppTraps.splice(i, 1);\n          i--;\n          trapsChanged = true;\n          log(`Intervention ausgelöst: Berater-Affäre → ${played.name} -2 Einfluss.`);\n          continue;\n        }\n\n        // Soft Power-Kollaps / Deepfake-Skandal (Diplomat)\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Soft Power-Kollaps' || key === 'Soft_Power_Kollaps') && isDiplomat) {\n          tryApplyNegativeEffect(played, () => {\n            adjustInfluence(played, -3, 'Soft Power-Kollaps');\n          }, prev.round);\n          oppTraps.splice(i, 1);\n          i--;\n          trapsChanged = true;\n          log(`Intervention ausgelöst: Soft Power-Kollaps → ${played.name} -3 Einfluss.`);\n          continue;\n        }\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Deepfake-Skandal' || key === 'Deepfake_Skandal') && isDiplomat) {\n          var _prev$effectFlags;\n          // Kein Einflusstransfer möglich - Flag setzen\n          const newFlags = {\n            ...((_prev$effectFlags = prev.effectFlags) === null || _prev$effectFlags === void 0 ? void 0 : _prev$effectFlags[actingPlayer]),\n            influenceTransferBlocked: true\n          };\n          prev.effectFlags = {\n            ...prev.effectFlags,\n            [actingPlayer]: newFlags\n          };\n          oppTraps.splice(i, 1);\n          i--;\n          trapsChanged = true;\n          log(`Intervention ausgelöst: Deepfake-Skandal → ${played.name} kann keinen Einfluss transferieren.`);\n          continue;\n        }\n\n        // Lobby Leak / Boykott-Kampagne (NGO/Bewegung)\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Lobby Leak' || key === 'Lobby_Leak') && isNGO) {\n          const hands = {\n            ...prev.hands\n          };\n          if (hands[actingPlayer].length > 0) {\n            hands[actingPlayer] = hands[actingPlayer].slice(1);\n            prev.hands = hands;\n          }\n          oppTraps.splice(i, 1);\n          i--;\n          trapsChanged = true;\n          log(`Intervention ausgelöst: Lobby Leak → P${actingPlayer} wirft 1 Karte ab.`);\n          continue;\n        }\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Boykott-Kampagne' || key === 'Boykott_Kampagne') && (isNGO || ['Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'].includes(played.name))) {\n          tryApplyNegativeEffect(played, () => {\n            played.deactivated = true;\n          }, prev.round);\n          oppTraps.splice(i, 1);\n          i--;\n          trapsChanged = true;\n          log(`Intervention ausgelöst: Boykott-Kampagne → ${played.name} deaktiviert.`);\n          continue;\n        }\n\n        // Cyber-Attacke (Plattform)\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Cyber-Attacke' || key === 'Cyber_Attacke') && isPlatform) {\n          const loc = findCardLocation(played, {\n            ...prev,\n            board\n          });\n          if (loc) {\n            const arr = [...board[loc.player][loc.lane]];\n            const idx = arr.findIndex(c => c.uid === played.uid);\n            if (idx >= 0) {\n              arr.splice(idx, 1);\n              board = {\n                ...board,\n                [loc.player]: {\n                  ...board[loc.player],\n                  [loc.lane]: arr\n                }\n              };\n            }\n          }\n          oppTraps.splice(i, 1);\n          i--;\n          trapsChanged = true;\n          log(`Intervention ausgelöst: Cyber-Attacke → ${played.name} zerstört.`);\n          continue;\n        }\n\n        // Bestechungsskandal 2.0 (schwache Regierung M≤5)\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Bestechungsskandal 2.0' || key === 'Bestechungsskandal_2_0') && isWeakGov) {\n          // Übernehme Karte bis Rundenende (vereinfacht: temporär deaktiviert)\n          tryApplyNegativeEffect(played, () => {\n            played.deactivated = true;\n          }, prev.round);\n          oppTraps.splice(i, 1);\n          i--;\n          trapsChanged = true;\n          log(`Intervention ausgelöst: Bestechungsskandal 2.0 → ${played.name} übernommen.`);\n          continue;\n        }\n\n        // Tunnelvision (M≤4 Regierung)\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Tunnelvision' || key === 'Tunnelvision') && isLowPowerGov) {\n          // Karte zählt nicht zur Runde (vereinfacht: -100% Einfluss)\n          tryApplyNegativeEffect(played, () => {\n            played.influence = 0;\n          }, prev.round);\n          oppTraps.splice(i, 1);\n          i--;\n          trapsChanged = true;\n          log(`Intervention ausgelöst: Tunnelvision → ${played.name} zählt nicht zur Runde.`);\n          continue;\n        }\n      }\n\n      // Trigger: Board-Zustand\n      if (event.type === 'board_state_check') {\n        var _event$card, _event$card2;\n        const actingPlayerGovCount = tentativeBoard[actingPlayer].aussen.length;\n        const actingPlayerPubCount = tentativeBoard[actingPlayer].innen.length;\n\n        // Strategische Enthüllung (>2 Regierungskarten)\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Strategische Enthüllung' || key === 'Strategische_Enthuellung') && actingPlayerGovCount > 2) {\n          // Eine Regierungskarte zurück auf Hand (vereinfacht: entferne erste)\n          const govCards = [...tentativeBoard[actingPlayer].aussen];\n          if (govCards.length > 0) {\n            govCards.pop(); // Entferne letzte\n            board = {\n              ...board,\n              [actingPlayer]: {\n                ...board[actingPlayer],\n                aussen: govCards\n              }\n            };\n          }\n          oppTraps.splice(i, 1);\n          i--;\n          trapsChanged = true;\n          log(`Intervention ausgelöst: Strategische Enthüllung → Regierungskarte zurück.`);\n          continue;\n        }\n\n        // Grassroots-Widerstand (>2 Öffentlichkeitskarten)\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Grassroots-Widerstand' || key === 'Grassroots_Widerstand') && actingPlayerPubCount > 2) {\n          const pubCards = tentativeBoard[actingPlayer].innen.filter(c => c.kind === 'pol');\n          if (pubCards.length > 0) {\n            tryApplyNegativeEffect(pubCards[0], () => {\n              pubCards[0].deactivated = true;\n            }, prev.round);\n          }\n          oppTraps.splice(i, 1);\n          i--;\n          trapsChanged = true;\n          log(`Intervention ausgelöst: Grassroots-Widerstand → Öffentlichkeitskarte deaktiviert.`);\n          continue;\n        }\n\n        // Parlament geschlossen (≥2 Regierungskarten)\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Parlament geschlossen' || key === 'Parlament_geschlossen') && actingPlayerGovCount >= 2) {\n          var _prev$effectFlags2;\n          // Blockiere weitere Regierungskarten (Flag für diesen Zug)\n          const newFlags = {\n            ...((_prev$effectFlags2 = prev.effectFlags) === null || _prev$effectFlags2 === void 0 ? void 0 : _prev$effectFlags2[actingPlayer]),\n            cannotPlayMoreGovernment: true\n          };\n          prev.effectFlags = {\n            ...prev.effectFlags,\n            [actingPlayer]: newFlags\n          };\n          oppTraps.splice(i, 1);\n          i--;\n          trapsChanged = true;\n          log(`Intervention ausgelöst: Parlament geschlossen → keine weiteren Regierungskarten.`);\n          continue;\n        }\n\n        // Interne Fraktionskämpfe (große Initiative 3-4 HP)\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Interne Fraktionskämpfe' || key === 'Interne_Fraktionskaempfe') && event.type === 'card_played' && ((_event$card = event.card) === null || _event$card === void 0 ? void 0 : _event$card.kind) === 'spec') {\n          const specCard = event.card;\n          const isLargeInitiative = specCard.type === 'Sofort-Initiative' && specCard.bp >= 3;\n          if (isLargeInitiative) {\n            // Initiative annullieren (vereinfacht: Karte zurück auf Hand)\n            const hands = {\n              ...prev.hands\n            };\n            hands[actingPlayer].push(event.card);\n            prev.hands = hands;\n            oppTraps.splice(i, 1);\n            i--;\n            trapsChanged = true;\n            log(`Intervention ausgelöst: Interne Fraktionskämpfe → ${event.card.name} wird annulliert.`);\n            continue;\n          }\n        }\n\n        // Massenproteste (2 Regierungskarten in der Runde)\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Massenproteste' || key === 'Massenproteste') && event.type === 'card_played' && event.lane === 'aussen') {\n          // Vereinfacht: Beide Regierungskarten -1 Einfluss\n          const govCards = board[actingPlayer].aussen.filter(c => c.kind === 'pol');\n          if (govCards.length >= 2) {\n            adjustInfluence(govCards[0], -1, 'Massenproteste');\n            adjustInfluence(govCards[1], -1, 'Massenproteste');\n            oppTraps.splice(i, 1);\n            i--;\n            trapsChanged = true;\n            log(`Intervention ausgelöst: Massenproteste → ${govCards[0].name} und ${govCards[1].name} -1 Einfluss.`);\n            continue;\n          }\n        }\n\n        // \"Unabhängige\" Untersuchung (gegen Intervention)\n        if (((details === null || details === void 0 ? void 0 : details.name) === '\"Unabhängige\" Untersuchung' || key === 'Unabhaengige_Untersuchung') && event.type === 'card_played' && ((_event$card2 = event.card) === null || _event$card2 === void 0 ? void 0 : _event$card2.kind) === 'spec') {\n          const specCard = event.card;\n          if (specCard.type === 'Intervention') {\n            // Intervention annullieren (vereinfacht: Karte zurück auf Hand)\n            const hands = {\n              ...prev.hands\n            };\n            hands[actingPlayer].push(event.card);\n            prev.hands = hands;\n            oppTraps.splice(i, 1);\n            i--;\n            trapsChanged = true;\n            log(`Intervention ausgelöst: \"Unabhängige\" Untersuchung → ${event.card.name} wird annulliert.`);\n            continue;\n          }\n        }\n\n        // Maulwurf (kopiere schwächere Regierungskarte des Gegners)\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Maulwurf' || key === 'Maulwurf') && event.type === 'card_played' && event.lane === 'aussen') {\n          const oppGovCards = board[opponent].aussen.filter(c => c.kind === 'pol');\n          if (oppGovCards.length > 0) {\n            // Finde schwächste Regierungskarte\n            const weakestCard = oppGovCards.reduce((weakest, current) => current.influence < weakest.influence ? current : weakest);\n            // Kopie erstellen (vereinfacht: gleiche Karte auf eigene Hand)\n            const hands = {\n              ...prev.hands\n            };\n            const copyCard = {\n              ...weakestCard,\n              uid: Date.now() + Math.random()\n            };\n            hands[opponent].push(copyCard);\n            prev.hands = hands;\n            oppTraps.splice(i, 1);\n            i--;\n            trapsChanged = true;\n            log(`Intervention ausgelöst: Maulwurf → Kopie von ${weakestCard.name} auf Hand.`);\n            continue;\n          }\n        }\n\n        // Skandalspirale (Initiative + Öffentlichkeitskarte)\n        if (((details === null || details === void 0 ? void 0 : details.name) === 'Skandalspirale' || key === 'Skandalspirale') && event.type === 'card_played') {\n          // Vereinfacht: Prüfe ob Initiative und Öffentlichkeitskarte in dieser Runde gespielt wurden\n          const recentCards = board[actingPlayer].innen.concat(board[actingPlayer].aussen);\n          const hasInitiative = recentCards.some(c => c.kind === 'spec' && c.type === 'Sofort-Initiative');\n          const hasPublic = recentCards.some(c => c.kind === 'spec' && c.type === 'Öffentlichkeitskarte');\n          if (hasInitiative && hasPublic) {\n            // Eine der beiden Karten annullieren (vereinfacht: letzte Öffentlichkeitskarte)\n            const pubCards = board[actingPlayer].innen.filter(c => c.kind === 'spec' && c.type === 'Öffentlichkeitskarte');\n            if (pubCards.length > 0) {\n              const lastPubCard = pubCards[pubCards.length - 1];\n              const arr = [...board[actingPlayer].innen];\n              const idx = arr.findIndex(c => c.uid === lastPubCard.uid);\n              if (idx >= 0) {\n                arr.splice(idx, 1);\n                board = {\n                  ...board,\n                  [actingPlayer]: {\n                    ...board[actingPlayer],\n                    innen: arr\n                  }\n                };\n              }\n            }\n            oppTraps.splice(i, 1);\n            i--;\n            trapsChanged = true;\n            log(`Intervention ausgelöst: Skandalspirale → Öffentlichkeitskarte annulliert.`);\n            continue;\n          }\n        }\n\n        // Satire-Show (bei mehr Einfluss als Gegner)\n        if ((details === null || details === void 0 ? void 0 : details.name) === 'Satire-Show' || key === 'Satire_Show') {\n          const playerInfluence = sumRow([...board[opponent].aussen]);\n          const opponentInfluence = sumRow([...board[actingPlayer].aussen]);\n          if (opponentInfluence > playerInfluence) {\n            const oppGovCards = board[opponent].aussen.filter(c => c.kind === 'pol');\n            if (oppGovCards.length > 0) {\n              // Erste Regierungskarte -2 Einfluss\n              adjustInfluence(oppGovCards[0], -2, 'Satire-Show');\n              oppTraps.splice(i, 1);\n              i--;\n              trapsChanged = true;\n              log(`Intervention ausgelöst: Satire-Show → ${oppGovCards[0].name} -2 Einfluss.`);\n              continue;\n            }\n          }\n        }\n      }\n    }\n    if (trapsChanged) {\n      const newTraps = {\n        ...prev.traps,\n        [opponent]: oppTraps\n      };\n      return [board, newTraps];\n    }\n    return [null, null];\n  };\n\n  // Zentrale Effekt-Queue Verarbeitung\n  const processEffectQueue = useCallback(state => {\n    if (!state.effectQueue || state.effectQueue.items.length === 0) {\n      return state;\n    }\n    const [newQueue, newState] = EffectQueueManager.processQueue(state.effectQueue, state, log);\n    return {\n      ...newState,\n      effectQueue: newQueue\n    };\n  }, [log]);\n\n  // Berechne Einfluss mit dauerhaften Auren-Effekten\n  const sumRowWithAuras = (state, player) => {\n    const govCards = state.board[player].aussen.filter(c => c.kind === 'pol');\n    const opponent = player === 1 ? 2 : 1;\n    let total = 0;\n\n    // 🔍 DEBUG: Log welche Regierungskarten gefunden wurden\n    console.log(`🔍 sumRowWithAuras P${player}: Gefunden ${govCards.length} Regierungskarten:`, govCards.map(c => `${c.name}[${c.influence}I]`).join(', '));\n    govCards.forEach(card => {\n      let influence = card.influence;\n\n      // Dauerhafte Auren anwenden\n      const govSlot = state.permanentSlots[player].government;\n      const pubSlot = state.permanentSlots[player].public;\n\n      // Koalitionszwang: Tier 2 Regierungskarten +1 Einfluss\n      if ((govSlot === null || govSlot === void 0 ? void 0 : govSlot.kind) === 'spec' && govSlot.name === 'Koalitionszwang') {\n        if (card.T === 2) influence += 1;\n      }\n\n      // Napoleon Komplex: Tier 1 Regierungskarten +1 Einfluss\n      if ((govSlot === null || govSlot === void 0 ? void 0 : govSlot.kind) === 'spec' && govSlot.name === 'Napoleon Komplex') {\n        if (card.T === 1) influence += 1;\n      }\n\n      // Zivilgesellschaft: Bewegung-Karten +1 Einfluss\n      if ((pubSlot === null || pubSlot === void 0 ? void 0 : pubSlot.kind) === 'spec' && pubSlot.name === 'Zivilgesellschaft') {\n        const bewegungNames = ['Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'];\n        const hasBewegung = state.board[player].innen.some(c => c.kind === 'spec' && c.type === 'Öffentlichkeitskarte' && bewegungNames.includes(c.name));\n        if (hasBewegung) influence += 1;\n      }\n\n      // 🔥 JOSCHKA FISCHER NGO-BOOST: +1 Einfluss wenn NGO auf dem Board liegt\n      if (card.name === 'Joschka Fischer' && card.effect === 'ngo_boost') {\n        const hasNgoCard = state.board[player].innen.some(c => c.kind === 'spec' && c.type === 'Öffentlichkeitskarte' && c.tag === 'NGO');\n        if (hasNgoCard) {\n          influence += 1;\n          // Log nur beim ersten Mal, um Spam zu vermeiden\n          if (!card._ngoBoostLogged) {\n            console.log(`🔥 JOSCHKA FISCHER KONTINUIERLICHER NGO-BOOST: +1 Einfluss`);\n            card._ngoBoostLogged = true;\n          }\n        } else {\n          card._ngoBoostLogged = false;\n        }\n      }\n\n      // Milchglas Transparenz: +1 Einfluss wenn keine NGO/Bewegung liegt\n      if ((govSlot === null || govSlot === void 0 ? void 0 : govSlot.kind) === 'spec' && govSlot.name === 'Milchglas Transparenz') {\n        const ngoMovementNames = ['Jennifer Doudna', 'Noam Chomsky', 'Bill Gates', 'Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'];\n        const hasNgoMovement = state.board[player].innen.some(c => c.kind === 'spec' && c.type === 'Öffentlichkeitskarte' && ngoMovementNames.includes(c.name));\n        if (!hasNgoMovement) influence += 1;\n      }\n\n      // Alternative Fakten: Gegner-Interventionen -1 Wirkung\n      const oppPubSlot = state.permanentSlots[opponent].public;\n      if ((oppPubSlot === null || oppPubSlot === void 0 ? void 0 : oppPubSlot.kind) === 'spec' && oppPubSlot.name === 'Alternative Fakten') {\n        // Reduziere Effekt von Interventionen (vereinfacht: -1 Einfluss weniger)\n        // Wird in der Intervention-Auswertung berücksichtigt\n      }\n      total += influence;\n    });\n\n    // 🔍 DEBUG: Final influence calculation\n    console.log(`🎯 sumRowWithAuras P${player}: Gesamt-Einfluss = ${total}`);\n    return total;\n  };\n\n  // playCard is now handled by useGameActions hook\n\n  // runAITurn is now handled by useGameAI hook - removed duplicate implementation\n\n  const applyStartOfTurnHooksLegacy = useCallback((player, state) => {\n    logFunctionCall('applyStartOfTurnHooksLegacy', {\n      player,\n      round: state.round\n    }, 'Starting legacy turn hooks');\n    const pool = [...state.board[player].innen, ...state.board[player].aussen];\n    pool.forEach(c => {\n      if (c.kind === 'pol') {\n        const polCard = c;\n        if (polCard._pledgeDown && polCard._pledgeDown.round === state.round) {\n          const oldInfluence = polCard.influence;\n          adjustInfluence(polCard, polCard._pledgeDown.amount, 'Wahlversprechen');\n          const newInfluence = polCard.influence;\n          log(`Wahlversprechen Abzug auf ${polCard.name}: ${oldInfluence} → ${newInfluence}`);\n          polCard._pledgeDown = null;\n        }\n        // reset once-per-round flags\n        polCard._hypedRoundFlag = false;\n      }\n    });\n\n    // Apply permanent initiative effects\n    const govSlot = state.permanentSlots[player].government;\n    const pubSlot = state.permanentSlots[player].public;\n    if (govSlot && govSlot.kind === 'spec') {\n      const govInitiative = govSlot;\n      logFunctionCall('applyPermanentInitiative', {\n        slot: 'government',\n        initiative: govInitiative.name\n      }, 'Processing government permanent initiative');\n      if (govInitiative.name === 'Alternative Fakten') {\n        // Alle Oligarchen geben +1 Einfluss\n        const oligarchCards = pool.filter(c => c.kind === 'pol' && ['Elon Musk', 'Bill Gates', 'George Soros', 'Warren Buffett', 'Mukesh Ambani', 'Jeff Bezos', 'Alisher Usmanov', 'Gautam Adani', 'Jack Ma', 'Zhang Yiming', 'Roman Abramovich'].includes(c.name));\n        logDataFlow('board analysis', 'oligarch cards', {\n          count: oligarchCards.length,\n          cards: oligarchCards.map(c => ({\n            name: c.name,\n            influence: c.kind === 'pol' ? c.influence : 0\n          }))\n        }, 'Finding oligarch cards for Alternative Fakten effect');\n        let totalInfluenceGained = 0;\n        oligarchCards.forEach(card => {\n          const oldInfluence = card.influence;\n          adjustInfluence(card, 1, 'Alternative Fakten');\n          const newInfluence = card.influence;\n          totalInfluenceGained += 1;\n          logCardEffect('Alternative Fakten', `${card.name} erhält +1 Einfluss (${oldInfluence} → ${newInfluence})`);\n        });\n        if (oligarchCards.length > 0) {\n          logCardEffect('Alternative Fakten', `${oligarchCards.length} Oligarchen gefunden - ${totalInfluenceGained} Punkte zum Gesamteinfluss hinzugefügt`);\n        } else {\n          logWarning('No oligarch cards found', 'Alternative Fakten effect has no targets');\n        }\n      }\n    }\n    if (pubSlot && pubSlot.kind === 'spec') {\n      const pubInitiative = pubSlot;\n      logFunctionCall('applyPermanentInitiative', {\n        slot: 'public',\n        initiative: pubInitiative.name\n      }, 'Processing public permanent initiative');\n      if (pubInitiative.name === 'Algorithmischer Diskurs') {\n        // Alle Medien-Karten geben +1 Einfluss\n        const mediaCards = pool.filter(c => c.kind === 'pol' && ['Oprah Winfrey', 'Mark Zuckerberg', 'Tim Cook', 'Sam Altman'].includes(c.name));\n        logDataFlow('board analysis', 'media cards', {\n          count: mediaCards.length,\n          cards: mediaCards.map(c => ({\n            name: c.name,\n            influence: c.kind === 'pol' ? c.influence : 0\n          }))\n        }, 'Finding media cards for Algorithmischer Diskurs effect');\n        let totalInfluenceGained = 0;\n        mediaCards.forEach(card => {\n          const oldInfluence = card.influence;\n          adjustInfluence(card, 1, 'Algorithmischer Diskurs');\n          const newInfluence = card.influence;\n          totalInfluenceGained += 1;\n          logCardEffect('Algorithmischer Diskurs', `${card.name} erhält +1 Einfluss (${oldInfluence} → ${newInfluence})`);\n        });\n        if (mediaCards.length > 0) {\n          logCardEffect('Algorithmischer Diskurs', `${mediaCards.length} Medien-Karten gefunden - ${totalInfluenceGained} Punkte zum Gesamteinfluss hinzugefügt`);\n        } else {\n          logWarning('No media cards found', 'Algorithmischer Diskurs effect has no targets');\n        }\n      }\n    }\n\n    // Legacy flags reset is replaced by the new applyStartOfTurnHooks implementation\n\n    logFunctionCall('applyStartOfTurnHooksLegacy', {\n      player\n    }, 'Legacy turn hooks completed');\n  }, [logFunctionCall, logDataFlow, logCardEffect, logWarning]);\n\n  // Helper: Leadership vorhanden?\n  const hasLeadershipCard = (player, state) => {\n    const gov = state.board[player].aussen;\n    const names = ['Justin Trudeau'];\n    return gov.some(c => c.kind === 'pol' && names.includes(c.name) && !c.deactivated);\n  };\n\n  // Helper: Bewegung vorhanden? (Öffentlichkeitsreihe)\n  const hasMovementCard = (player, state) => {\n    const pub = state.board[player].innen;\n    const names = ['Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'];\n    return pub.some(c => c.kind === 'pol' && names.includes(c.name) && !c.deactivated);\n  };\n\n  // Helper: Plattform vorhanden? (Öffentlichkeitsreihe)\n  const hasPlatformCard = (player, state) => {\n    const pub = state.board[player].innen;\n    const names = ['Mark Zuckerberg', 'Tim Cook', 'Jack Ma', 'Zhang Yiming'];\n    return pub.some(c => c.kind === 'pol' && names.includes(c.name) && !c.deactivated);\n  };\n\n  // Helper: Diplomat vorhanden? (Regierungsreihe)\n  const hasDiplomatCard = (player, state) => {\n    const gov = state.board[player].aussen;\n    const names = ['Joschka Fischer', 'Sergey Lavrov', 'Ursula von der Leyen', 'Jens Stoltenberg', 'Horst Köhler', 'Walter Scheel', 'Hans Dietrich Genscher', 'Colin Powell', 'Condoleezza Rice', 'Christine Lagarde'];\n    return gov.some(c => c.kind === 'pol' && names.includes(c.name) && !c.deactivated);\n  };\n\n  // Helper: Einfluss-Transfer durch Dauerhaft-Initiativen blockiert? (Koalitionszwang, Napoleon Komplex)\n  const hasInfluenceTransferBlock = (player, state) => {\n    const govSlot = state.permanentSlots[player].government;\n    if (!govSlot || govSlot.kind !== 'spec') return false;\n    const spec = govSlot;\n    return ['Koalitionszwang', 'Napoleon Komplex'].includes(spec.name);\n  };\n\n  // Helper: Kann Spieler mehrere Interventionen spielen? (Putin-Fähigkeit)\n  const canPlayMultipleInterventions = (player, state) => {\n    const govCards = state.board[player].aussen.filter(c => c.kind === 'pol');\n    return govCards.some(c => c.name === 'Vladimir Putin' && !c.deactivated);\n  };\n  const selectHandCard = useCallback(index => {\n    setSelectedHandIndex(index);\n  }, []);\n  const passTurn = useCallback(player => {\n    setGameState(prev => {\n      if (prev.current !== player) return prev;\n      const newState = {\n        ...prev,\n        passed: {\n          ...prev.passed,\n          [player]: true\n        }\n      };\n      log(`Spieler ${player} passt.`);\n\n      // If both players have passed, resolve the round\n      if (newState.passed[1] && newState.passed[2]) {\n        return resolveRound(newState);\n      }\n      return newState;\n    });\n  }, [log, resolveRound]);\n\n  // Diplomat-Einfluss-Transfer Funktion\n  const transferInfluence = useCallback((player, fromCardUid, toCardUid, amount) => {\n    setGameState(prev => {\n      var _prev$effectFlags3;\n      if (prev.current !== player) return prev;\n      const flags = (_prev$effectFlags3 = prev.effectFlags) === null || _prev$effectFlags3 === void 0 ? void 0 : _prev$effectFlags3[player];\n      if (!flags || flags.diplomatInfluenceTransferUsed || flags.influenceTransferBlocked) return prev;\n      if (!hasDiplomatCard(player, prev)) return prev;\n\n      // Finde beide Karten in der Regierungsreihe\n      const govCards = prev.board[player].aussen;\n      const fromCard = govCards.find(c => c.uid === fromCardUid && c.kind === 'pol');\n      const toCard = govCards.find(c => c.uid === toCardUid && c.kind === 'pol');\n      if (!fromCard || !toCard || fromCard.influence < amount) return prev;\n\n      // Transfer durchführen\n      adjustInfluence(fromCard, -amount, 'Diplomat-Transfer');\n      adjustInfluence(toCard, amount, 'Diplomat-Transfer');\n\n      // Flag setzen\n      const newFlags = {\n        ...flags,\n        diplomatInfluenceTransferUsed: true\n      };\n      const newEffectFlags = {\n        ...prev.effectFlags,\n        [player]: newFlags\n      };\n      log(`P${player} transferiert ${amount} Einfluss von ${fromCard.name} zu ${toCard.name} (Diplomat).`);\n      return {\n        ...prev,\n        effectFlags: newEffectFlags\n      };\n    });\n  }, [log]);\n\n  // Active Abilities Management\n  const getActiveAbilities = useCallback(player => {\n    return ActiveAbilitiesManager.getAvailableAbilities(player, gameState);\n  }, []);\n  const useActiveAbility = useCallback((abilityId, targetCardUid) => {\n    setGameState(prev => {\n      const player = prev.current;\n      const abilities = ActiveAbilitiesManager.getAvailableAbilities(player, prev);\n      const ability = abilities.find(a => a.id === abilityId);\n      if (!ability || !ActiveAbilitiesManager.canUseAbility(ability, player, prev)) {\n        return prev;\n      }\n\n      // Finde Actor Card\n      const allCards = [...prev.board[player].innen, ...prev.board[player].aussen].filter(c => c.kind === 'pol');\n      const actorCard = allCards.find(c => ability.id.includes(c.uid.toString()));\n      if (!actorCard) return prev;\n\n      // Finde Target Card wenn nötig\n      let targetCard;\n      if (targetCardUid) {\n        const allTargets = [...prev.board[1].innen, ...prev.board[1].aussen, ...prev.board[2].innen, ...prev.board[2].aussen].filter(c => c.kind === 'pol');\n        targetCard = allTargets.find(c => c.uid === targetCardUid);\n      }\n      const select = {\n        type: ability.type,\n        actorCard,\n        actorPlayer: player,\n        targetCard\n      };\n      const newState = ActiveAbilitiesManager.executeAbility(ability, select, prev);\n      log(`${actorCard.name} nutzt ${ability.name}${targetCard ? ` auf ${targetCard.name}` : ''}.`);\n      return newState;\n    });\n  }, [gameState, log]);\n\n  // Reset aktive Fähigkeiten zu Rundenbeginn\n  const resetActiveAbilities = useCallback(state => {\n    const newState = {\n      ...state\n    };\n\n    // Reset _activeUsed für alle Politikerkarten\n    [1, 2].forEach(player => {\n      const allCards = [...newState.board[player].innen, ...newState.board[player].aussen].filter(c => c.kind === 'pol');\n      allCards.forEach(card => {\n        card._activeUsed = false;\n      });\n    });\n    return newState;\n  }, []);\n\n  // Putin Doppelte Interventionen\n  const executePutinDoubleIntervention = useCallback(interventionCardIds => {\n    setGameState(prev => {\n      const player = prev.current;\n      const newState = ActiveAbilitiesManager.executePutinDoubleIntervention(prev, player, interventionCardIds, log);\n      return newState;\n    });\n  }, [log]);\n\n  // Check ob Putin Doppel-Intervention verfügbar ist\n  const canUsePutinDoubleIntervention = useCallback(player => {\n    const board = gameState.board[player];\n    const allCards = [...board.innen, ...board.aussen].filter(c => c.kind === 'pol');\n    const putin = allCards.find(c => c.name === 'Vladimir Putin');\n    if (!putin || putin.deactivated || putin._activeUsed) return false;\n    const interventions = gameState.hands[player].filter(c => c.kind === 'spec');\n    return interventions.length >= 2;\n  }, [gameState]);\n\n  // Manual turn advancement for testing\n  const manualAdvanceTurn = useCallback(() => {\n    console.log('🔧 DEBUG: Manual turn advancement triggered');\n    log('🔧 DEBUG: Manual turn advancement triggered');\n    nextTurn();\n  }, [nextTurn, log]);\n  return {\n    gameState,\n    selectedHandIndex,\n    log,\n    startNewGame,\n    selectHandCard: setSelectedHandIndex,\n    scores,\n    manualAdvanceTurn,\n    // Manual turn advancement for testing\n\n    // Core game state functions\n    dealStartingHands,\n    resolveRound,\n    nextTurn: gameActions.nextTurn,\n    endTurn: gameActions.endTurn,\n    checkAndAdvanceTurn,\n    shouldAdvanceTurn,\n    // Helper functions kept for compatibility\n    hasLeadershipCard,\n    hasMovementCard,\n    hasPlatformCard,\n    hasDiplomatCard,\n    hasInfluenceTransferBlock,\n    canPlayMultipleInterventions,\n    sumRowWithAuras,\n    applyStartOfTurnHooksLegacy,\n    // Functions that were migrated to separate hooks\n    passTurn: gameActions.passTurn,\n    transferInfluence,\n    getActiveAbilities,\n    useActiveAbility,\n    resetActiveAbilities,\n    executePutinDoubleIntervention,\n    canUsePutinDoubleIntervention,\n    // Delegate primary functionality to separated hooks\n    startMatchWithDecks: gameActions.startMatchWithDecks,\n    startMatchVsAI: gameActions.startMatchVsAI,\n    playCard: gameActions.playCard,\n    activateInstantInitiative: gameActions.activateInstantInitiative,\n    // AI functionality\n    runAITurn: gameAI.runAITurn,\n    aiEnabled: gameAI.aiEnabled,\n    setAiEnabled: gameAI.setAiEnabled,\n    aiPreset: gameAI.aiPreset,\n    setAiPreset: gameAI.setAiPreset,\n    // Effects functionality\n    executeCardEffect,\n    processEffectQueue,\n    afterQueueResolved\n  };\n}\n_s(useGameState, \"fDGYkmFjbjRemXOCqVmccBw85Xs=\", false, function () {\n  return [useGameActions, useGameAI, useGameEffects];\n});","map":{"version":3,"names":["useState","useCallback","createDefaultEffectFlags","Pols","Specials","PRESET_DECKS","sumRow","shuffle","makePolInstance","makeSpecInstance","buildDeckFromEntries","drawCards","drawCardsAtRoundEnd","tryApplyNegativeEffect","adjustInfluence","findCardLocation","sumGovernmentInfluenceWithAuras","EffectQueueManager","ActiveAbilitiesManager","getCardDetails","useGameActions","useGameAI","useGameEffects","applyStartOfTurnHooks","emptyBoard","initialGameState","round","current","passed","actionPoints","actionsUsed","decks","hands","traps","board","permanentSlots","government","public","initiativePermanent","discard","log","activeRefresh","roundsWon","gameWinner","effectFlags","effectQueue","initializeQueue","activeAbilities","pendingAbilitySelect","undefined","aiEnabled","useGameState","_s","gameState","setGameState","selectedHandIndex","setSelectedHandIndex","msg","timestamp","Date","toLocaleTimeString","hour","minute","second","logEntry","console","prev","logUIInteraction","action","details","logGameStateChange","change","logAIAction","logCardEffect","cardName","effect","logIntervention","interventionName","trigger","logFunctionCall","functionName","params","context","paramStr","JSON","stringify","String","logDataFlow","from","to","data","dataStr","logConditionCheck","condition","result","logError","error","logWarning","warning","afterQueueResolved","s","_version","n","gameActions","gameAI","gameEffects","dealStartingHands","buildDeck","polPool","specPool","deck","slice","forEach","p","push","implFirst","srt","sort","a","b","indexOf","impl","deck1","deck2","length","splice","startNewGame","startMatchWithDecks","p1DeckEntries","p2DeckEntries","setAiEnabled","setAiPreset","p1Cards","p2Cards","d1","d2","h1","Math","min","h2","startMatchVsAI","presetKey","shouldAdvanceTurn","player","executeCardEffect","card","state","logFunc","newState","name","type","kind","specCard","_newState$effectFlags","flags","publicEffectDoubled","govCards","aussen","filter","c","count","cards","map","targetCard","oldInfluence","influence","newInfluence","old","new","newHands","newDecks","opponent","oppGovCards","deactivated","oppHand","handSize","discardedCard","floor","random","newOppHand","newHandSize","oppBoard","totalOppInfluence","innen","totalInfluence","publicCards","oldAP","newAP","includes","polCard","effectsApplied","nextTurn","_prev$aiEnabled$","_prev$aiEnabled","_prev$aiEnabled$2","_prev$aiEnabled2","_prev$aiEnabled$3","_prev$aiEnabled3","resolveRound","newCurrent","newActionPoints","oldActions","newActions","setTimeout","runAITurn","ap","checkAndAdvanceTurn","currentPlayer","otherPlayer","scores","s1","s2","winner","note","newRoundsWon","newBoard","newTraps","newRound","newPassed","newEffectFlags","scienceInitiativeBonus","militaryInitiativePenalty","healthInitiativeBonus","cultureInitiativeBonus","markZuckerbergUsed","opportunistActive","cannotPlayInitiatives","nextCardProtected","platformAfterInitiativeBonus","interventionEffectReduced","evaluateInterventions","actingPlayer","event","tentativeBoard","oppTraps","trapsChanged","i","trap","spec","key","played","isMedia","isNGO","isPlatform","isDiplomat","isTier2Gov","T","lane","isTier1Gov","isWeakGov","isLowPowerGov","_prev$effectFlags","newFlags","influenceTransferBlocked","loc","arr","idx","findIndex","uid","_event$card","_event$card2","actingPlayerGovCount","actingPlayerPubCount","pop","pubCards","_prev$effectFlags2","cannotPlayMoreGovernment","isLargeInitiative","bp","weakestCard","reduce","weakest","copyCard","now","recentCards","concat","hasInitiative","some","hasPublic","lastPubCard","playerInfluence","opponentInfluence","processEffectQueue","items","newQueue","processQueue","sumRowWithAuras","total","join","govSlot","pubSlot","bewegungNames","hasBewegung","hasNgoCard","tag","_ngoBoostLogged","ngoMovementNames","hasNgoMovement","oppPubSlot","applyStartOfTurnHooksLegacy","pool","_pledgeDown","amount","_hypedRoundFlag","govInitiative","slot","initiative","oligarchCards","totalInfluenceGained","pubInitiative","mediaCards","hasLeadershipCard","gov","names","hasMovementCard","pub","hasPlatformCard","hasDiplomatCard","hasInfluenceTransferBlock","canPlayMultipleInterventions","selectHandCard","index","passTurn","transferInfluence","fromCardUid","toCardUid","_prev$effectFlags3","diplomatInfluenceTransferUsed","fromCard","find","toCard","getActiveAbilities","getAvailableAbilities","useActiveAbility","abilityId","targetCardUid","abilities","ability","id","canUseAbility","allCards","actorCard","toString","allTargets","select","actorPlayer","executeAbility","resetActiveAbilities","_activeUsed","executePutinDoubleIntervention","interventionCardIds","canUsePutinDoubleIntervention","putin","interventions","manualAdvanceTurn","endTurn","playCard","activateInstantInitiative","aiPreset"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/hooks/useGameState.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\r\nimport { GameState, Card, PoliticianCard, SpecialCard, Player, BuilderEntry, createDefaultEffectFlags } from '../types/game';\r\nimport { Pols, Specials, PRESET_DECKS } from '../data/gameData';\r\nimport {\r\n  sumRow,\r\n  shuffle,\r\n  makePolInstance,\r\n  makeSpecInstance,\r\n  buildDeckFromEntries,\r\n  drawCards,\r\n  drawCardsAtRoundEnd,\r\n  tryApplyNegativeEffect,\r\n  adjustInfluence,\r\n  findCardLocation,\r\n  sumGovernmentInfluenceWithAuras,\r\n  EffectQueueManager,\r\n  ActiveAbilitiesManager\r\n} from '../utils/gameUtils';\r\nimport { getCardDetails } from '../data/cardDetails';\r\nimport { useGameActions } from './useGameActions';\r\nimport { useGameAI } from './useGameAI';\r\nimport { useGameEffects } from './useGameEffects';\r\nimport { applyStartOfTurnHooks } from '../utils/startOfTurnHooks';\r\nimport { emptyBoard, emptyBoardSide, ensureSofortBoard } from '../state/board';\r\n\r\nconst initialGameState: GameState = {\r\n  round: 1,\r\n  current: 1,\r\n  passed: { 1: false, 2: false },\r\n  actionPoints: { 1: 2, 2: 2 },\r\n  actionsUsed: { 1: 0, 2: 0 },\r\n  decks: { 1: [], 2: [] },\r\n  hands: { 1: [], 2: [] },\r\n  traps: { 1: [], 2: [] },\r\n  board: emptyBoard(),\r\n  permanentSlots: {\r\n    1: { government: null, public: null, initiativePermanent: null, initiativePermanent: null },\r\n    2: { government: null, public: null, initiativePermanent: null, initiativePermanent: null },\r\n  },\r\n  discard: [],\r\n  log: [],\r\n  activeRefresh: { 1: 0, 2: 0 },\r\n  roundsWon: { 1: 0, 2: 0 },\r\n  gameWinner: null,\r\n  effectFlags: {\r\n    1: createDefaultEffectFlags(),\r\n    2: createDefaultEffectFlags()\r\n  },\r\n  effectQueue: EffectQueueManager.initializeQueue(),\r\n  activeAbilities: {\r\n    1: [],\r\n    2: []\r\n  },\r\n  pendingAbilitySelect: undefined,\r\n  aiEnabled: { 1: false, 2: false },\r\n};\r\n\r\nexport function useGameState() {\r\n  const [gameState, setGameState] = useState<GameState>(initialGameState);\r\n  const [selectedHandIndex, setSelectedHandIndex] = useState<number | null>(null);\r\n\r\n  const log = useCallback((msg: string) => {\r\n    const timestamp = new Date().toLocaleTimeString('de-DE', {\r\n      hour: '2-digit',\r\n      minute: '2-digit',\r\n      second: '2-digit'\r\n    });\r\n    const logEntry = `[${timestamp}] ${msg}`;\r\n\r\n    console.log(logEntry); // Also log to console for debugging\r\n\r\n    setGameState(prev => ({\r\n      ...prev,\r\n      log: [...prev.log, logEntry]\r\n    }));\r\n  }, []);\r\n\r\n  // Enhanced logging functions for different types of events\r\n  const logUIInteraction = useCallback((action: string, details: string) => {\r\n    log(`🎯 UI: ${action} - ${details}`);\r\n  }, [log]);\r\n\r\n  const logGameStateChange = useCallback((change: string, details: string) => {\r\n    log(`🔄 STATE: ${change} - ${details}`);\r\n  }, [log]);\r\n\r\n  const logAIAction = useCallback((action: string, details: string) => {\r\n    log(`🤖 KI: ${action} - ${details}`);\r\n  }, [log]);\r\n\r\n  const logCardEffect = useCallback((cardName: string, effect: string) => {\r\n    log(`✨ EFFEKT: ${cardName} - ${effect}`);\r\n  }, [log]);\r\n\r\n  const logIntervention = useCallback((interventionName: string, trigger: string) => {\r\n    log(`💥 INTERVENTION: ${interventionName} ausgelöst durch ${trigger}`);\r\n  }, [log]);\r\n\r\n  // New detailed logging functions for debugging\r\n  const logFunctionCall = useCallback((functionName: string, params: any, context: string) => {\r\n    const paramStr = typeof params === 'object' ? JSON.stringify(params, null, 2) : String(params);\r\n    log(`🔧 CALL: ${functionName}(${paramStr}) - ${context}`);\r\n  }, [log]);\r\n\r\n  const logDataFlow = useCallback((from: string, to: string, data: any, action: string) => {\r\n    const dataStr = typeof data === 'object' ? JSON.stringify(data, null, 2) : String(data);\r\n    log(`📊 FLOW: ${from} → ${to} | ${action} | Data: ${dataStr}`);\r\n  }, [log]);\r\n\r\n  const logConditionCheck = useCallback((condition: string, result: boolean, context: string) => {\r\n    log(`🔍 CHECK: ${condition} = ${result} - ${context}`);\r\n  }, [log]);\r\n\r\n  const logError = useCallback((error: string, context: string) => {\r\n    log(`❌ ERROR: ${error} - ${context}`);\r\n  }, [log]);\r\n\r\n  const logWarning = useCallback((warning: string, context: string) => {\r\n    log(`⚠️ WARN: ${warning} - ${context}`);\r\n  }, [log]);\r\n\r\n  // Nach Queue-Auflösung: Hand-Arrays immutabel neu zuweisen → Canvas & UI bekommen die neuen UIDs\r\n  const afterQueueResolved = useCallback(() => {\r\n    setGameState(s => {\r\n      const n = { ...s };\r\n      n.hands = {\r\n        1: [...s.hands[1]],\r\n        2: [...s.hands[2]],\r\n      } as any;\r\n      // optional: version bump für Canvas\r\n      (n as any)._version = ((s as any)._version ?? 0) + 1;\r\n      return n;\r\n    });\r\n  }, []);\r\n\r\n  // Import functionality from separated hooks\r\n  const gameActions = useGameActions(gameState, setGameState, log, afterQueueResolved);\r\n  const gameAI = useGameAI(gameState, setGameState, log);\r\n  const gameEffects = useGameEffects(gameState, setGameState, log);\r\n\r\n  const dealStartingHands = useCallback(() => {\r\n    console.log('[DIAG] dealStartingHands called');\r\n    function buildDeck(): Card[] {\r\n      const polPool = [...Pols];\r\n      const specPool = [...Specials];\r\n      shuffle(polPool);\r\n      shuffle(specPool);\r\n      const deck: Card[] = [];\r\n      polPool.slice(0, 14).forEach(p => deck.push(makePolInstance(p)));\r\n\r\n      // prefer more useful/implemented specials\r\n      const implFirst = ['media', 'pledge', 'pledge2', 'sanctions', 'dnc1', 'dnc2', 'dnc3', 'reshuffle', 'mission', 'trap_fakenews', 'trap_protest', 'trap_scandal'];\r\n      const srt = specPool.slice().sort((a, b) => implFirst.indexOf(a.impl) - implFirst.indexOf(b.impl));\r\n      srt.slice(0, 11).forEach(s => deck.push(makeSpecInstance(s)));\r\n      return shuffle(deck).slice(0, 25);\r\n    }\r\n\r\n    const deck1 = buildDeck();\r\n    const deck2 = buildDeck();\r\n\r\n    console.log('[DIAG] built decks lengths', deck1.length, deck2.length);\r\n\r\n    setGameState(prev => ({\r\n      ...prev,\r\n      decks: { 1: deck1, 2: deck2 },\r\n      hands: {\r\n        1: deck1.splice(0, 5),\r\n        2: deck2.splice(0, 5)\r\n      }\r\n    }));\r\n    console.log('[DIAG] setGameState after deal: hands[1].length', (deck1.length >= 5 ? 5 : deck1.length));\r\n  }, []);\r\n\r\n  const startNewGame = useCallback(() => {\r\n    setGameState({\r\n      ...initialGameState,\r\n      round: 1,\r\n      current: 1,\r\n      passed: { 1: false, 2: false },\r\n      actionPoints: { 1: 2, 2: 2 },\r\n      actionsUsed: { 1: 0, 2: 0 },\r\n      board: emptyBoard(),\r\n      traps: { 1: [], 2: [] },\r\n      permanentSlots: {\r\n        1: { government: null, public: null, initiativePermanent: null },\r\n        2: { government: null, public: null, initiativePermanent: null },\r\n      },\r\n      // instantSlot wird nicht mehr verwendet - Sofort-Initiativen gehen in board[player].sofort\r\n      discard: [],\r\n      log: [],\r\n      activeRefresh: { 1: 0, 2: 0 },\r\n    });\r\n    dealStartingHands();\r\n  }, [dealStartingHands]);\r\n\r\n  const startMatchWithDecks = useCallback((p1DeckEntries: BuilderEntry[], p2DeckEntries: BuilderEntry[]) => {\r\n    console.log('🔧 DEBUG: startMatchWithDecks called - activating AI for player 2');\r\n    // Automatically enable AI for player 2 when starting with decks\r\n    console.log('🔧 DEBUG: About to call gameAI.setAiEnabled(true)');\r\n    gameAI.setAiEnabled(true);\r\n    console.log('🔧 DEBUG: About to call gameAI.setAiPreset(AUTORITAERER_REALIST)');\r\n    gameAI.setAiPreset('AUTORITAERER_REALIST');\r\n    console.log('🔧 DEBUG: AI setup completed');\r\n\r\n    console.log('[DIAG] startMatchWithDecks - p1DeckEntries', p1DeckEntries.length, 'p2DeckEntries', p2DeckEntries.length);\r\n    console.log('[DIAG] startMatchWithDecks - sample entries:', p1DeckEntries.slice(0, 2), p2DeckEntries.slice(0, 2));\r\n\r\n    const p1Cards = buildDeckFromEntries(p1DeckEntries);\r\n    const p2Cards = buildDeckFromEntries(p2DeckEntries);\r\n\r\n    const d1 = [...p1Cards];\r\n    const d2 = [...p2Cards];\r\n    const h1 = d1.splice(0, Math.min(5, d1.length));\r\n    const h2 = d2.splice(0, Math.min(5, d2.length));\r\n\r\n    console.log('[DIAG] startMatchWithDecks - p1Cards', p1Cards.length, 'p2Cards', p2Cards.length);\r\n    console.log('[DIAG] startMatchWithDecks - h1', h1.length, 'h2', h2.length);\r\n    console.log('[DIAG] startMatchWithDecks - sample cards:', p1Cards.slice(0, 2), p2Cards.slice(0, 2));\r\n\r\n    setGameState({\r\n      ...initialGameState,\r\n      round: 1,\r\n      current: 1,\r\n      passed: { 1: false, 2: false },\r\n      decks: { 1: d1, 2: d2 },\r\n      hands: { 1: h1, 2: h2 },\r\n      board: emptyBoard(),\r\n      traps: { 1: [], 2: [] },\r\n      permanentSlots: {\r\n        1: { government: null, public: null, initiativePermanent: null },\r\n        2: { government: null, public: null, initiativePermanent: null },\r\n      },\r\n      // instantSlot wird nicht mehr verwendet - Sofort-Initiativen gehen in board[player].sofort\r\n      discard: [],\r\n      log: [`Match gestartet. P1 und P2 erhalten je ${h1.length}/${h2.length} Startkarten.`],\r\n      activeRefresh: { 1: 0, 2: 0 },\r\n    });\r\n    console.log('[DIAG] setGameState called in startMatchWithDecks');\r\n  }, [gameAI]);\r\n\r\n  const startMatchVsAI = useCallback((p1DeckEntries: BuilderEntry[], presetKey: keyof typeof PRESET_DECKS = 'AUTORITAERER_REALIST') => {\r\n    const p2DeckEntries = PRESET_DECKS[presetKey] as BuilderEntry[];\r\n    gameAI.setAiEnabled(true);\r\n    gameAI.setAiPreset(presetKey);\r\n    gameActions.startMatchWithDecks(p1DeckEntries, p2DeckEntries);\r\n  }, [gameAI, gameActions]);\r\n\r\n  // Prüfe ob der Zug automatisch gewechselt werden soll\r\n  const shouldAdvanceTurn = useCallback((gameState: GameState, player: Player): boolean => {\r\n    // Wenn Spieler gepasst hat\r\n    if (gameState.passed[player]) return true;\r\n\r\n    // Wenn keine AP mehr verfügbar sind\r\n    if (gameState.actionPoints[player] <= 0) return true;\r\n\r\n    // Wenn 2 Aktionen verwendet wurden\r\n    // if (gameState.actionsUsed[player] >= 2) return true;\r\n\r\n    return false;\r\n  }, []);\r\n\r\n  // Karten-Effekte implementieren\r\n  const executeCardEffect = useCallback((\r\n    card: Card,\r\n    player: Player,\r\n    state: GameState,\r\n    logFunc: (msg: string) => void\r\n  ): GameState => {\r\n    let newState = { ...state };\r\n\r\n    logFunctionCall('executeCardEffect', { card: card.name, player, type: card.kind }, 'Starting card effect execution');\r\n\r\n    if (card.kind === 'spec') {\r\n      const specCard = card as SpecialCard;\r\n\r\n      // === SOFORT-INITIATIVEN ===\r\n      if (specCard.name === 'Shadow Lobbying') {\r\n        logCardEffect(specCard.name, 'Öffentlichkeits-Effekte zählen doppelt diese Runde');\r\n        const flags = { ...newState.effectFlags?.[player], publicEffectDoubled: true };\r\n        newState.effectFlags = { ...newState.effectFlags, [player]: flags } as GameState['effectFlags'];\r\n        logDataFlow('effectFlags', 'newState', { player, publicEffectDoubled: true }, 'Shadow Lobbying flag set');\r\n      }\r\n      else if (specCard.name === 'Spin Doctor') {\r\n        const govCards = newState.board[player].aussen.filter(c => c.kind === 'pol') as PoliticianCard[];\r\n        logDataFlow('board analysis', 'govCards', { count: govCards.length, cards: govCards.map(c => c.name) }, 'Finding government cards');\r\n\r\n        if (govCards.length > 0) {\r\n          const targetCard = govCards[0];\r\n          const oldInfluence = targetCard.influence;\r\n          adjustInfluence(targetCard, 2, 'Spin Doctor');\r\n          const newInfluence = targetCard.influence;\r\n\r\n          logCardEffect(specCard.name, `${targetCard.name} erhält +2 Einfluss (${oldInfluence} → ${newInfluence})`);\r\n          logDataFlow('influence adjustment', 'targetCard', { card: targetCard.name, old: oldInfluence, new: newInfluence, change: 2 }, 'Spin Doctor effect applied');\r\n        } else {\r\n          logWarning('No government cards found', 'Spin Doctor effect has no target');\r\n        }\r\n      }\r\n      else if (specCard.name === 'Digitaler Wahlkampf') {\r\n        logCardEffect(specCard.name, 'Ziehe 2 Karten, nächste Initiative -1 AP');\r\n        const { newHands, newDecks } = drawCards(player, 2, newState, logFunc);\r\n        newState = { ...newState, hands: newHands, decks: newDecks };\r\n\r\n        // Simplified AP system: No discounts\r\n        logDataFlow('effectFlags', 'newState', { player }, 'Platform effect applied');\r\n      }\r\n      else if (specCard.name === 'Partei-Offensive') {\r\n        const opponent: Player = player === 1 ? 2 : 1;\r\n        const oppGovCards = newState.board[opponent].aussen.filter(c => c.kind === 'pol' && !(c as PoliticianCard).deactivated) as PoliticianCard[];\r\n        logDataFlow('opponent analysis', 'oppGovCards', { opponent, count: oppGovCards.length, cards: oppGovCards.map(c => c.name) }, 'Finding active opponent government cards');\r\n\r\n        if (oppGovCards.length > 0) {\r\n          const targetCard = oppGovCards[0];\r\n          targetCard.deactivated = true;\r\n          logCardEffect(specCard.name, `${targetCard.name} wird deaktiviert (bis Rundenende)`);\r\n          logDataFlow('card deactivation', 'targetCard', { card: targetCard.name, deactivated: true }, 'Partei-Offensive effect applied');\r\n        } else {\r\n          logWarning('No active opponent government cards found', 'Partei-Offensive effect has no target');\r\n        }\r\n      }\r\n      else if (specCard.name === 'Oppositionsblockade') {\r\n        const opponent: Player = player === 1 ? 2 : 1;\r\n        const oppHand = newState.hands[opponent];\r\n        logDataFlow('opponent hand', 'analysis', { opponent, handSize: oppHand.length, cards: oppHand.map(c => c.name) }, 'Analyzing opponent hand');\r\n\r\n        if (oppHand.length > 0) {\r\n          const discardedCard = oppHand[Math.floor(Math.random() * oppHand.length)];\r\n          const newOppHand = oppHand.filter(c => c !== discardedCard);\r\n          newState.hands = { ...newState.hands, [opponent]: newOppHand };\r\n\r\n          logCardEffect(specCard.name, `Gegner verliert ${discardedCard.name} aus der Hand`);\r\n          logDataFlow('card discard', 'opponent hand', { card: discardedCard.name, newHandSize: newOppHand.length }, 'Oppositionsblockade effect applied');\r\n        } else {\r\n          logWarning('Opponent hand is empty', 'Oppositionsblockade effect has no target');\r\n        }\r\n      }\r\n      else if (specCard.name === 'Opportunist') {\r\n        const opponent: Player = player === 1 ? 2 : 1;\r\n        const oppBoard = newState.board[opponent];\r\n        const totalOppInfluence = sumRow([...oppBoard.innen, ...oppBoard.aussen]);\r\n\r\n        logDataFlow('opponent board analysis', 'influence calculation', {\r\n          opponent,\r\n          innen: oppBoard.innen.map(c => ({ name: c.name, influence: c.kind === 'pol' ? (c as any).influence : 0 })),\r\n          aussen: oppBoard.aussen.map(c => ({ name: c.name, influence: c.kind === 'pol' ? (c as any).influence : 0 })),\r\n          totalInfluence: totalOppInfluence\r\n        }, 'Calculating opponent total influence');\r\n\r\n        if (totalOppInfluence > 10) {\r\n          const { newHands, newDecks } = drawCards(player, 1, newState, logFunc);\r\n          newState = { ...newState, hands: newHands, decks: newDecks };\r\n          logCardEffect(specCard.name, `Gegner hat ${totalOppInfluence} Einfluss (>10) - ziehe 1 Karte`);\r\n        } else {\r\n          logCardEffect(specCard.name, `Gegner hat ${totalOppInfluence} Einfluss (≤10) - kein Effekt`);\r\n        }\r\n      }\r\n      else if (specCard.name === 'Think-tank') {\r\n        const { newHands, newDecks } = drawCards(player, 1, newState, logFunc);\r\n        newState = { ...newState, hands: newHands, decks: newDecks };\r\n        logCardEffect(specCard.name, 'Ziehe 1 Karte');\r\n      }\r\n      else if (specCard.name === 'Influencer-Kampagne') {\r\n        const publicCards = newState.board[player].innen.filter(c => c.kind === 'pol') as PoliticianCard[];\r\n        logDataFlow('public cards analysis', 'influence boost', { count: publicCards.length, cards: publicCards.map(c => c.name) }, 'Finding public cards for influence boost');\r\n\r\n        publicCards.forEach(card => {\r\n          const oldInfluence = card.influence;\r\n          adjustInfluence(card, 1, 'Influencer-Kampagne');\r\n          const newInfluence = card.influence;\r\n          logCardEffect(specCard.name, `${card.name} erhält +1 Einfluss (${oldInfluence} → ${newInfluence})`);\r\n        });\r\n\r\n        if (publicCards.length === 0) {\r\n          logWarning('No public cards found', 'Influencer-Kampagne effect has no targets');\r\n        }\r\n      }\r\n      else if (specCard.name === 'Systemrelevant') {\r\n        const opponent: Player = player === 1 ? 2 : 1;\r\n        const oppGovCards = newState.board[opponent].aussen.filter(c => c.kind === 'pol') as PoliticianCard[];\r\n        logDataFlow('opponent government analysis', 'systemrelevant effect', { count: oppGovCards.length, cards: oppGovCards.map(c => c.name) }, 'Finding opponent government cards');\r\n\r\n        if (oppGovCards.length > 0) {\r\n          const targetCard = oppGovCards[0];\r\n          const oldInfluence = targetCard.influence;\r\n          adjustInfluence(targetCard, -2, 'Systemrelevant');\r\n          const newInfluence = targetCard.influence;\r\n\r\n          logCardEffect(specCard.name, `${targetCard.name} verliert 2 Einfluss (${oldInfluence} → ${newInfluence})`);\r\n          logDataFlow('influence reduction', 'targetCard', { card: targetCard.name, old: oldInfluence, new: newInfluence, change: -2 }, 'Systemrelevant effect applied');\r\n        } else {\r\n          logWarning('No opponent government cards found', 'Systemrelevant effect has no target');\r\n        }\r\n      }\r\n      else if (specCard.name === 'Symbolpolitik') {\r\n        const { newHands, newDecks } = drawCards(player, 1, newState, logFunc);\r\n        newState = { ...newState, hands: newHands, decks: newDecks };\r\n\r\n        newState.actionPoints = {\r\n          ...newState.actionPoints,\r\n          [player]: Math.min(2, newState.actionPoints[player] + 1)\r\n        };\r\n\r\n        const oldAP = state.actionPoints[player];\r\n        const newAP = newState.actionPoints[player];\r\n        logCardEffect(specCard.name, `Ziehe 1 Karte, erhalte +1 AP (${oldAP} → ${newAP})`);\r\n        logDataFlow('AP gain', 'player', { player, old: oldAP, new: newAP, change: 1 }, 'Symbolpolitik effect applied');\r\n      }\r\n      else if (specCard.name === 'Alexei Navalny') {\r\n        logCardEffect(specCard.name, 'Ziehe 1 Karte');\r\n        const { newHands, newDecks } = drawCards(player, 1, newState, logFunc);\r\n        newState = { ...newState, hands: newHands, decks: newDecks };\r\n      }\r\n      else if (specCard.name === 'Mukesh Ambani') {\r\n        logCardEffect(specCard.name, 'Ziehe 1 Karte');\r\n        const { newHands, newDecks } = drawCards(player, 1, newState, logFunc);\r\n        newState = { ...newState, hands: newHands, decks: newDecks };\r\n      }\r\n\r\n      // Oligarch-Effekte\r\n      else if (['Elon Musk', 'Bill Gates', 'George Soros', 'Warren Buffett', 'Mukesh Ambani', 'Jeff Bezos', 'Alisher Usmanov', 'Gautam Adani', 'Jack Ma', 'Zhang Yiming', 'Roman Abramovich'].includes(specCard.name)) {\r\n        logCardEffect(specCard.name, 'Ziehe 1 Karte (Oligarch-Effekt)');\r\n        const { newHands, newDecks } = drawCards(player, 1, newState, logFunc);\r\n        newState = { ...newState, hands: newHands, decks: newDecks };\r\n      }\r\n    }\r\n\r\n    // === DAUERHAFTE INITIATIVEN ===\r\n    if (card.kind === 'spec' && (card as SpecialCard).type === 'Dauerhaft-Initiative') {\r\n      const specCard = card as SpecialCard;\r\n\r\n      if (specCard.name === 'Algorithmischer Diskurs') {\r\n        logCardEffect(specCard.name, 'Dauerhafte Initiative: Alle Medien-Karten geben +1 Einfluss');\r\n        // This effect will be applied in applyStartOfTurnHooks\r\n      }\r\n      else if (specCard.name === 'Alternative Fakten') {\r\n        logCardEffect(specCard.name, 'Dauerhafte Initiative: Alle Oligarchen geben +1 Einfluss');\r\n        // This effect will be applied in applyStartOfTurnHooks\r\n      }\r\n    }\r\n\r\n    // === POLITIKER-KARTEN ===\r\n    else if (card.kind === 'pol') {\r\n      const polCard = card as PoliticianCard;\r\n      logCardEffect(polCard.name, `Politiker platziert - Basis-Einfluss: ${polCard.influence}`);\r\n    }\r\n\r\n    logDataFlow('executeCardEffect', 'newState', { card: card.name, effectsApplied: true }, 'Card effect execution completed');\r\n    return newState;\r\n  }, [logFunctionCall, logCardEffect, logDataFlow, logWarning]);\r\n\r\n  const nextTurn = useCallback(() => {\r\n    logFunctionCall('nextTurn', {}, 'Starting turn change');\r\n\r\n    setGameState((prev): GameState => {\r\n      logDataFlow('UI', 'nextTurn', { current: prev.current, passed: prev.passed }, 'Turn change request');\r\n\r\n      // if both passed -> resolve round\r\n      logConditionCheck('both players passed', prev.passed[1] && prev.passed[2], 'Round end check');\r\n      if (prev.passed[1] && prev.passed[2]) {\r\n        logFunctionCall('resolveRound', { round: prev.round }, 'Both players passed - resolving round');\r\n        return resolveRound(prev);\r\n      }\r\n\r\n      const newCurrent: Player = prev.current === 1 ? 2 : 1;\r\n      logDataFlow('turn change', 'newCurrent', { old: prev.current, new: newCurrent }, 'Player switch');\r\n\r\n      // Reset AP for the new current player\r\n      const newActionPoints = { ...prev.actionPoints };\r\n      newActionPoints[newCurrent] = 2;\r\n\r\n      logDataFlow('AP reset', 'newCurrent', {\r\n        player: newCurrent,\r\n        oldAP: prev.actionPoints[newCurrent],\r\n        newAP: newActionPoints[newCurrent],\r\n        oldActions: 0,\r\n        newActions: 0\r\n      }, 'Resource reset for new player');\r\n\r\n      // Apply start-of-turn hooks for the new current player\r\n      const newState: GameState = {\r\n        ...prev,\r\n        current: newCurrent,\r\n        actionPoints: newActionPoints\r\n      };\r\n\r\n      // Log turn change\r\n      log(`Spieler ${newCurrent} ist am Zug (2 AP verfügbar)`);\r\n      logGameStateChange('turn change', `Player ${newCurrent} turn started`);\r\n\r\n      logFunctionCall('applyStartOfTurnHooks', { player: newCurrent }, 'Applying start-of-turn effects');\r\n      applyStartOfTurnHooks(newState, newCurrent, log);\r\n\r\n      // Check if AI should take turn\r\n      logConditionCheck('AI turn', newCurrent === 2 && (prev.aiEnabled?.[2] ?? false), 'AI turn check');\r\n      if (newCurrent === 2 && (prev.aiEnabled?.[2] ?? false)) {\r\n        logFunctionCall('runAITurn', { player: newCurrent }, 'Triggering AI turn');\r\n        // Use setTimeout to avoid state update conflicts\r\n        setTimeout(() => {\r\n          logAIAction('AI turn triggered', 'Starting AI turn execution');\r\n          gameAI.runAITurn();\r\n        }, 100);\r\n      }\r\n\r\n      logDataFlow('nextTurn', 'finalState', {\r\n        current: newState.current,\r\n        ap: newState.actionPoints[newCurrent],\r\n        aiEnabled: prev.aiEnabled?.[2] ?? false\r\n      }, 'Turn change completed');\r\n\r\n      return newState;\r\n    });\r\n\r\n    // Nach Zugwechsel ebenfalls spiegeln (z. B. Auto-Draw am EoT)\r\n    afterQueueResolved();\r\n  }, [logFunctionCall, logDataFlow, logConditionCheck, logGameStateChange, gameAI, log, logAIAction, afterQueueResolved]);\r\n\r\n  // Automatischer Zugwechsel basierend auf AP\r\n  const checkAndAdvanceTurn = useCallback((gameState: GameState) => {\r\n    const currentPlayer = gameState.current;\r\n    if (shouldAdvanceTurn(gameState, currentPlayer)) {\r\n      // Nur wechseln wenn der andere Spieler nicht auch fertig ist\r\n      const otherPlayer: Player = currentPlayer === 1 ? 2 : 1;\r\n      if (!shouldAdvanceTurn(gameState, otherPlayer) || gameState.passed[otherPlayer]) {\r\n        nextTurn();\r\n      }\r\n    }\r\n  }, [shouldAdvanceTurn, nextTurn]);\r\n\r\n  const scores = useCallback((state: GameState): [number, number] => {\r\n    // Einheitliche Berechnung über Utils-Helfer\r\n    const s1 = sumGovernmentInfluenceWithAuras(state, 1);\r\n    const s2 = sumGovernmentInfluenceWithAuras(state, 2);\r\n    return [s1, s2];\r\n  }, []);\r\n\r\n  const resolveRound = useCallback((state: GameState): GameState => {\r\n    const [s1, s2] = scores(state);\r\n    let winner: 1 | 2 = 1;\r\n    let note = '';\r\n\r\n    if (s1 > s2) winner = 1;\r\n    else if (s2 > s1) winner = 2;\r\n    else {\r\n      // Gleichstand -> erster Pass gewinnt\r\n      winner = state.passed[1] && !state.passed[2] ? 1 : 2;\r\n      note = ' (Gleichstand – früherer Pass)';\r\n    }\r\n\r\n    log(`Runde ${state.round} endet: P1 ${s1} : P2 ${s2}. Gewinner: P${winner}${note}.`);\r\n\r\n    // Rundensieg zählen\r\n    const newRoundsWon = { ...state.roundsWon };\r\n    newRoundsWon[winner] += 1;\r\n\r\n    // Prüfe Best-of-3 Gewinner\r\n    let gameWinner: 1 | 2 | null = null;\r\n    if (newRoundsWon[1] >= 2) {\r\n      gameWinner = 1;\r\n      log(`🎉 SPIEL ENDE: Spieler 1 gewinnt das Spiel! (${newRoundsWon[1]}:${newRoundsWon[2]})`);\r\n    } else if (newRoundsWon[2] >= 2) {\r\n      gameWinner = 2;\r\n      log(`🎉 SPIEL ENDE: Spieler 2 gewinnt das Spiel! (${newRoundsWon[2]}:${newRoundsWon[1]})`);\r\n    }\r\n\r\n    // clear board (no carryover)\r\n    const newBoard = emptyBoard();\r\n    const newTraps = { 1: [], 2: [] };\r\n\r\n    // Verbesserte Karten-Nachzieh-Mechanik (ziehe bis Hand voll ist)\r\n    const { newHands, newDecks } = drawCardsAtRoundEnd(state, log);\r\n\r\n    const newRound = state.round + 1;\r\n    const newPassed = { 1: false, 2: false };\r\n    // alternate starter each round\r\n    const newCurrent = (newRound % 2 === 1) ? 1 : 2;\r\n\r\n    // Wenn Spiel zu Ende, stoppe\r\n    if (gameWinner) {\r\n      return {\r\n        ...state,\r\n        roundsWon: newRoundsWon,\r\n        gameWinner,\r\n      };\r\n    }\r\n\r\n    log(`Runde ${newRound} beginnt. P${newCurrent} startet.`);\r\n\r\n    // 🔥 CLUSTER 3: Reset temporäre Initiative-Boni am Rundenende\r\n    const newEffectFlags = {\r\n      1: {\r\n        ...state.effectFlags[1],\r\n        // Reset Cluster 3 Flags\r\n        scienceInitiativeBonus: false,\r\n        militaryInitiativePenalty: false,\r\n        healthInitiativeBonus: false,\r\n        cultureInitiativeBonus: false,\r\n        // Reset andere rundenbasierte Flags\r\n        markZuckerbergUsed: false,\r\n        opportunistActive: false,\r\n        publicEffectDoubled: false,\r\n        cannotPlayInitiatives: false,\r\n        nextCardProtected: false,\r\n        platformAfterInitiativeBonus: false,\r\n        interventionEffectReduced: false,\r\n      },\r\n      2: {\r\n        ...state.effectFlags[2],\r\n        // Reset Cluster 3 Flags\r\n        scienceInitiativeBonus: false,\r\n        militaryInitiativePenalty: false,\r\n        healthInitiativeBonus: false,\r\n        cultureInitiativeBonus: false,\r\n        // Reset andere rundenbasierte Flags\r\n        markZuckerbergUsed: false,\r\n        opportunistActive: false,\r\n        publicEffectDoubled: false,\r\n        cannotPlayInitiatives: false,\r\n        nextCardProtected: false,\r\n        platformAfterInitiativeBonus: false,\r\n        interventionEffectReduced: false,\r\n      }\r\n    };\r\n\r\n    return {\r\n      ...state,\r\n      round: newRound,\r\n      current: newCurrent,\r\n      passed: newPassed,\r\n      board: newBoard,\r\n      traps: newTraps,\r\n      hands: newHands,\r\n      decks: newDecks,\r\n      roundsWon: newRoundsWon,\r\n      effectFlags: newEffectFlags,\r\n    };\r\n  }, [log, scores]);\r\n\r\n  // Einfache Interventionsauswertung für einige häufige Trigger\r\n  const evaluateInterventions = (\r\n    prev: GameState,\r\n    actingPlayer: Player,\r\n    event: any,\r\n    tentativeBoard: GameState['board']\r\n  ): [GameState['board'] | null, GameState['traps'] | null] => {\r\n    const opponent: Player = actingPlayer === 1 ? 2 : 1;\r\n    const oppTraps = [...(prev.traps[opponent] || [])];\r\n    let board = tentativeBoard;\r\n    let trapsChanged = false;\r\n\r\n    for (let i = 0; i < oppTraps.length; i++) {\r\n      const trap = oppTraps[i];\r\n      if (trap.kind !== 'spec') continue;\r\n      const spec = trap as SpecialCard;\r\n      const details = getCardDetails(spec.name);\r\n      const key = spec.key;\r\n\r\n      // Trigger: Karte gespielt\r\n      if (event.type === 'card_played' && (event.card as PoliticianCard)) {\r\n        const played = event.card as PoliticianCard;\r\n        const isMedia = ['Oprah Winfrey'].includes(played.name);\r\n        const isNGO = ['Bill Gates', 'Jennifer Doudna', 'Noam Chomsky'].includes(played.name);\r\n        const isPlatform = ['Mark Zuckerberg', 'Tim Cook', 'Jack Ma', 'Zhang Yiming'].includes(played.name);\r\n        const isDiplomat = ['Joschka Fischer', 'Sergey Lavrov', 'Ursula von der Leyen', 'Jens Stoltenberg', 'Hans Dietrich Genscher', 'Colin Powell', 'Condoleezza Rice', 'Christine Lagarde'].includes(played.name);\r\n        const isTier2Gov = (played.T === 2 && event.lane === 'aussen');\r\n        const isTier1Gov = (played.T === 1 && event.lane === 'aussen');\r\n        const isWeakGov = (played.influence <= 5 && event.lane === 'aussen');\r\n        const isLowPowerGov = (played.influence <= 4 && event.lane === 'aussen');\r\n\r\n        // Cancel Culture / Fake News-Kampagne\r\n        if ((details?.name === 'Cancel Culture' || key === 'Cancel_Culture') && event.lane === 'innen') {\r\n          tryApplyNegativeEffect(played, () => { played.deactivated = true; }, prev.round);\r\n          oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n          log(`Intervention ausgelöst: Cancel Culture → ${played.name} deaktiviert.`);\r\n          logIntervention('Cancel Culture', `Ausgelöst gegen ${played.name} in Öffentlichkeit`);\r\n          continue;\r\n        }\r\n        if ((details?.name === 'Fake News-Kampagne' || key === 'Fake_News_Kampagne') && isMedia) {\r\n          tryApplyNegativeEffect(played, () => { played.deactivated = true; }, prev.round);\r\n          oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n          log(`Intervention ausgelöst: Fake News-Kampagne → ${played.name} deaktiviert.`);\r\n          logIntervention('Fake News-Kampagne', `Ausgelöst gegen ${played.name} (Medien)`);\r\n          continue;\r\n        }\r\n\r\n        // Whistleblower (Tier 2 Regierung)\r\n        if ((details?.name === 'Whistleblower' || key === 'Whistleblower') && isTier2Gov) {\r\n          tryApplyNegativeEffect(played, () => { adjustInfluence(played, -2, 'Whistleblower'); }, prev.round);\r\n          oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n          log(`Intervention ausgelöst: Whistleblower → ${played.name} -2 Einfluss.`);\r\n          continue;\r\n        }\r\n\r\n        // Berater-Affäre (Tier 1 Regierung)\r\n        if ((details?.name === 'Berater-Affäre' || key === 'Berater_Affaere') && isTier1Gov) {\r\n          tryApplyNegativeEffect(played, () => { adjustInfluence(played, -2, 'Berater-Affäre'); }, prev.round);\r\n          oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n          log(`Intervention ausgelöst: Berater-Affäre → ${played.name} -2 Einfluss.`);\r\n          continue;\r\n        }\r\n\r\n        // Soft Power-Kollaps / Deepfake-Skandal (Diplomat)\r\n        if ((details?.name === 'Soft Power-Kollaps' || key === 'Soft_Power_Kollaps') && isDiplomat) {\r\n          tryApplyNegativeEffect(played, () => { adjustInfluence(played, -3, 'Soft Power-Kollaps'); }, prev.round);\r\n          oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n          log(`Intervention ausgelöst: Soft Power-Kollaps → ${played.name} -3 Einfluss.`);\r\n          continue;\r\n        }\r\n        if ((details?.name === 'Deepfake-Skandal' || key === 'Deepfake_Skandal') && isDiplomat) {\r\n          // Kein Einflusstransfer möglich - Flag setzen\r\n          const newFlags = { ...prev.effectFlags?.[actingPlayer], influenceTransferBlocked: true };\r\n          prev.effectFlags = { ...prev.effectFlags, [actingPlayer]: newFlags } as GameState['effectFlags'];\r\n          oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n          log(`Intervention ausgelöst: Deepfake-Skandal → ${played.name} kann keinen Einfluss transferieren.`);\r\n          continue;\r\n        }\r\n\r\n        // Lobby Leak / Boykott-Kampagne (NGO/Bewegung)\r\n        if ((details?.name === 'Lobby Leak' || key === 'Lobby_Leak') && isNGO) {\r\n          const hands = { ...prev.hands } as GameState['hands'];\r\n          if (hands[actingPlayer].length > 0) {\r\n            hands[actingPlayer] = hands[actingPlayer].slice(1);\r\n            prev.hands = hands;\r\n          }\r\n          oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n          log(`Intervention ausgelöst: Lobby Leak → P${actingPlayer} wirft 1 Karte ab.`);\r\n          continue;\r\n        }\r\n        if ((details?.name === 'Boykott-Kampagne' || key === 'Boykott_Kampagne') && (isNGO || ['Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'].includes(played.name))) {\r\n          tryApplyNegativeEffect(played, () => { played.deactivated = true; }, prev.round);\r\n          oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n          log(`Intervention ausgelöst: Boykott-Kampagne → ${played.name} deaktiviert.`);\r\n          continue;\r\n        }\r\n\r\n        // Cyber-Attacke (Plattform)\r\n        if ((details?.name === 'Cyber-Attacke' || key === 'Cyber_Attacke') && isPlatform) {\r\n          const loc = findCardLocation(played as any, { ...prev, board } as GameState);\r\n          if (loc) {\r\n            const arr = [...board[loc.player][loc.lane]];\r\n            const idx = arr.findIndex(c => c.uid === played.uid);\r\n            if (idx >= 0) {\r\n              arr.splice(idx, 1);\r\n              board = {\r\n                ...board,\r\n                [loc.player]: {\r\n                  ...board[loc.player],\r\n                  [loc.lane]: arr\r\n                }\r\n              } as GameState['board'];\r\n            }\r\n          }\r\n          oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n          log(`Intervention ausgelöst: Cyber-Attacke → ${played.name} zerstört.`);\r\n          continue;\r\n        }\r\n\r\n        // Bestechungsskandal 2.0 (schwache Regierung M≤5)\r\n        if ((details?.name === 'Bestechungsskandal 2.0' || key === 'Bestechungsskandal_2_0') && isWeakGov) {\r\n          // Übernehme Karte bis Rundenende (vereinfacht: temporär deaktiviert)\r\n          tryApplyNegativeEffect(played, () => { played.deactivated = true; }, prev.round);\r\n          oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n          log(`Intervention ausgelöst: Bestechungsskandal 2.0 → ${played.name} übernommen.`);\r\n          continue;\r\n        }\r\n\r\n        // Tunnelvision (M≤4 Regierung)\r\n        if ((details?.name === 'Tunnelvision' || key === 'Tunnelvision') && isLowPowerGov) {\r\n          // Karte zählt nicht zur Runde (vereinfacht: -100% Einfluss)\r\n          tryApplyNegativeEffect(played, () => { played.influence = 0; }, prev.round);\r\n          oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n          log(`Intervention ausgelöst: Tunnelvision → ${played.name} zählt nicht zur Runde.`);\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Trigger: Board-Zustand\r\n      if (event.type === 'board_state_check') {\r\n        const actingPlayerGovCount = tentativeBoard[actingPlayer].aussen.length;\r\n        const actingPlayerPubCount = tentativeBoard[actingPlayer].innen.length;\r\n\r\n        // Strategische Enthüllung (>2 Regierungskarten)\r\n        if ((details?.name === 'Strategische Enthüllung' || key === 'Strategische_Enthuellung') && actingPlayerGovCount > 2) {\r\n          // Eine Regierungskarte zurück auf Hand (vereinfacht: entferne erste)\r\n          const govCards = [...tentativeBoard[actingPlayer].aussen];\r\n          if (govCards.length > 0) {\r\n            govCards.pop(); // Entferne letzte\r\n            board = { ...board, [actingPlayer]: { ...board[actingPlayer], aussen: govCards } } as GameState['board'];\r\n          }\r\n          oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n          log(`Intervention ausgelöst: Strategische Enthüllung → Regierungskarte zurück.`);\r\n          continue;\r\n        }\r\n\r\n        // Grassroots-Widerstand (>2 Öffentlichkeitskarten)\r\n        if ((details?.name === 'Grassroots-Widerstand' || key === 'Grassroots_Widerstand') && actingPlayerPubCount > 2) {\r\n          const pubCards = tentativeBoard[actingPlayer].innen.filter(c => c.kind === 'pol') as PoliticianCard[];\r\n          if (pubCards.length > 0) {\r\n            tryApplyNegativeEffect(pubCards[0], () => { pubCards[0].deactivated = true; }, prev.round);\r\n          }\r\n          oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n          log(`Intervention ausgelöst: Grassroots-Widerstand → Öffentlichkeitskarte deaktiviert.`);\r\n          continue;\r\n        }\r\n\r\n        // Parlament geschlossen (≥2 Regierungskarten)\r\n        if ((details?.name === 'Parlament geschlossen' || key === 'Parlament_geschlossen') && actingPlayerGovCount >= 2) {\r\n          // Blockiere weitere Regierungskarten (Flag für diesen Zug)\r\n          const newFlags = { ...prev.effectFlags?.[actingPlayer], cannotPlayMoreGovernment: true };\r\n          prev.effectFlags = { ...prev.effectFlags, [actingPlayer]: newFlags } as GameState['effectFlags'];\r\n          oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n          log(`Intervention ausgelöst: Parlament geschlossen → keine weiteren Regierungskarten.`);\r\n          continue;\r\n        }\r\n\r\n        // Interne Fraktionskämpfe (große Initiative 3-4 HP)\r\n        if ((details?.name === 'Interne Fraktionskämpfe' || key === 'Interne_Fraktionskaempfe') && event.type === 'card_played' && event.card?.kind === 'spec') {\r\n          const specCard = event.card as SpecialCard;\r\n          const isLargeInitiative = specCard.type === 'Sofort-Initiative' && (specCard.bp >= 3);\r\n          if (isLargeInitiative) {\r\n            // Initiative annullieren (vereinfacht: Karte zurück auf Hand)\r\n            const hands = { ...prev.hands } as GameState['hands'];\r\n            hands[actingPlayer].push(event.card);\r\n            prev.hands = hands;\r\n            oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n            log(`Intervention ausgelöst: Interne Fraktionskämpfe → ${event.card.name} wird annulliert.`);\r\n            continue;\r\n          }\r\n        }\r\n\r\n        // Massenproteste (2 Regierungskarten in der Runde)\r\n        if ((details?.name === 'Massenproteste' || key === 'Massenproteste') && event.type === 'card_played' && event.lane === 'aussen') {\r\n          // Vereinfacht: Beide Regierungskarten -1 Einfluss\r\n          const govCards = board[actingPlayer].aussen.filter(c => c.kind === 'pol') as PoliticianCard[];\r\n          if (govCards.length >= 2) {\r\n            adjustInfluence(govCards[0], -1, 'Massenproteste');\r\n            adjustInfluence(govCards[1], -1, 'Massenproteste');\r\n            oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n            log(`Intervention ausgelöst: Massenproteste → ${govCards[0].name} und ${govCards[1].name} -1 Einfluss.`);\r\n            continue;\r\n          }\r\n        }\r\n\r\n        // \"Unabhängige\" Untersuchung (gegen Intervention)\r\n        if ((details?.name === '\"Unabhängige\" Untersuchung' || key === 'Unabhaengige_Untersuchung') && event.type === 'card_played' && event.card?.kind === 'spec') {\r\n          const specCard = event.card as SpecialCard;\r\n          if (specCard.type === 'Intervention') {\r\n            // Intervention annullieren (vereinfacht: Karte zurück auf Hand)\r\n            const hands = { ...prev.hands } as GameState['hands'];\r\n            hands[actingPlayer].push(event.card);\r\n            prev.hands = hands;\r\n            oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n            log(`Intervention ausgelöst: \"Unabhängige\" Untersuchung → ${event.card.name} wird annulliert.`);\r\n            continue;\r\n          }\r\n        }\r\n\r\n        // Maulwurf (kopiere schwächere Regierungskarte des Gegners)\r\n        if ((details?.name === 'Maulwurf' || key === 'Maulwurf') && event.type === 'card_played' && event.lane === 'aussen') {\r\n          const oppGovCards = board[opponent].aussen.filter(c => c.kind === 'pol') as PoliticianCard[];\r\n          if (oppGovCards.length > 0) {\r\n            // Finde schwächste Regierungskarte\r\n            const weakestCard = oppGovCards.reduce((weakest, current) =>\r\n              (current.influence < weakest.influence) ? current : weakest\r\n            );\r\n            // Kopie erstellen (vereinfacht: gleiche Karte auf eigene Hand)\r\n            const hands = { ...prev.hands } as GameState['hands'];\r\n            const copyCard = { ...weakestCard, uid: Date.now() + Math.random() };\r\n            hands[opponent].push(copyCard);\r\n            prev.hands = hands;\r\n            oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n            log(`Intervention ausgelöst: Maulwurf → Kopie von ${weakestCard.name} auf Hand.`);\r\n            continue;\r\n          }\r\n        }\r\n\r\n        // Skandalspirale (Initiative + Öffentlichkeitskarte)\r\n        if ((details?.name === 'Skandalspirale' || key === 'Skandalspirale') && event.type === 'card_played') {\r\n          // Vereinfacht: Prüfe ob Initiative und Öffentlichkeitskarte in dieser Runde gespielt wurden\r\n          const recentCards = board[actingPlayer].innen.concat(board[actingPlayer].aussen);\r\n          const hasInitiative = recentCards.some(c => c.kind === 'spec' && (c as SpecialCard).type === 'Sofort-Initiative');\r\n          const hasPublic = recentCards.some(c => c.kind === 'spec' && (c as SpecialCard).type === 'Öffentlichkeitskarte');\r\n          if (hasInitiative && hasPublic) {\r\n            // Eine der beiden Karten annullieren (vereinfacht: letzte Öffentlichkeitskarte)\r\n            const pubCards = board[actingPlayer].innen.filter(c => c.kind === 'spec' && (c as SpecialCard).type === 'Öffentlichkeitskarte');\r\n            if (pubCards.length > 0) {\r\n              const lastPubCard = pubCards[pubCards.length - 1];\r\n              const arr = [...board[actingPlayer].innen];\r\n              const idx = arr.findIndex(c => c.uid === lastPubCard.uid);\r\n              if (idx >= 0) {\r\n                arr.splice(idx, 1);\r\n                board = {\r\n                  ...board,\r\n                  [actingPlayer]: { ...board[actingPlayer], innen: arr }\r\n                } as GameState['board'];\r\n              }\r\n            }\r\n            oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n            log(`Intervention ausgelöst: Skandalspirale → Öffentlichkeitskarte annulliert.`);\r\n            continue;\r\n          }\r\n        }\r\n\r\n        // Satire-Show (bei mehr Einfluss als Gegner)\r\n        if ((details?.name === 'Satire-Show' || key === 'Satire_Show')) {\r\n          const playerInfluence = sumRow([...board[opponent].aussen]);\r\n          const opponentInfluence = sumRow([...board[actingPlayer].aussen]);\r\n          if (opponentInfluence > playerInfluence) {\r\n            const oppGovCards = board[opponent].aussen.filter(c => c.kind === 'pol') as PoliticianCard[];\r\n            if (oppGovCards.length > 0) {\r\n              // Erste Regierungskarte -2 Einfluss\r\n              adjustInfluence(oppGovCards[0], -2, 'Satire-Show');\r\n              oppTraps.splice(i, 1); i--; trapsChanged = true;\r\n              log(`Intervention ausgelöst: Satire-Show → ${oppGovCards[0].name} -2 Einfluss.`);\r\n              continue;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (trapsChanged) {\r\n      const newTraps = { ...prev.traps, [opponent]: oppTraps } as GameState['traps'];\r\n      return [board, newTraps];\r\n    }\r\n    return [null, null];\r\n  };\r\n\r\n  // Zentrale Effekt-Queue Verarbeitung\r\n  const processEffectQueue = useCallback((state: GameState): GameState => {\r\n    if (!state.effectQueue || state.effectQueue.items.length === 0) {\r\n      return state;\r\n    }\r\n\r\n    const [newQueue, newState] = EffectQueueManager.processQueue(\r\n      state.effectQueue,\r\n      state,\r\n      log\r\n    );\r\n\r\n    return {\r\n      ...newState,\r\n      effectQueue: newQueue\r\n    };\r\n  }, [log]);\r\n\r\n  // Berechne Einfluss mit dauerhaften Auren-Effekten\r\n  const sumRowWithAuras = (state: GameState, player: Player): number => {\r\n    const govCards = state.board[player].aussen.filter(c => c.kind === 'pol') as PoliticianCard[];\r\n    const opponent: Player = player === 1 ? 2 : 1;\r\n    let total = 0;\r\n\r\n    // 🔍 DEBUG: Log welche Regierungskarten gefunden wurden\r\n    console.log(`🔍 sumRowWithAuras P${player}: Gefunden ${govCards.length} Regierungskarten:`,\r\n      govCards.map(c => `${c.name}[${c.influence}I]`).join(', '));\r\n\r\n    govCards.forEach(card => {\r\n      let influence = card.influence;\r\n\r\n      // Dauerhafte Auren anwenden\r\n      const govSlot = state.permanentSlots[player].government;\r\n      const pubSlot = state.permanentSlots[player].public;\r\n\r\n      // Koalitionszwang: Tier 2 Regierungskarten +1 Einfluss\r\n      if (govSlot?.kind === 'spec' && (govSlot as SpecialCard).name === 'Koalitionszwang') {\r\n        if (card.T === 2) influence += 1;\r\n      }\r\n\r\n      // Napoleon Komplex: Tier 1 Regierungskarten +1 Einfluss\r\n      if (govSlot?.kind === 'spec' && (govSlot as SpecialCard).name === 'Napoleon Komplex') {\r\n        if (card.T === 1) influence += 1;\r\n      }\r\n\r\n      // Zivilgesellschaft: Bewegung-Karten +1 Einfluss\r\n      if (pubSlot?.kind === 'spec' && (pubSlot as SpecialCard).name === 'Zivilgesellschaft') {\r\n        const bewegungNames = ['Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'];\r\n        const hasBewegung = state.board[player].innen.some(c => c.kind === 'spec' && (c as SpecialCard).type === 'Öffentlichkeitskarte' && bewegungNames.includes(c.name));\r\n        if (hasBewegung) influence += 1;\r\n      }\r\n\r\n      // 🔥 JOSCHKA FISCHER NGO-BOOST: +1 Einfluss wenn NGO auf dem Board liegt\r\n      if (card.name === 'Joschka Fischer' && (card as any).effect === 'ngo_boost') {\r\n        const hasNgoCard = state.board[player].innen.some(c =>\r\n          c.kind === 'spec' &&\r\n          (c as SpecialCard).type === 'Öffentlichkeitskarte' &&\r\n          (c as any).tag === 'NGO'\r\n        );\r\n        if (hasNgoCard) {\r\n          influence += 1;\r\n          // Log nur beim ersten Mal, um Spam zu vermeiden\r\n          if (!(card as any)._ngoBoostLogged) {\r\n            console.log(`🔥 JOSCHKA FISCHER KONTINUIERLICHER NGO-BOOST: +1 Einfluss`);\r\n            (card as any)._ngoBoostLogged = true;\r\n          }\r\n        } else {\r\n          (card as any)._ngoBoostLogged = false;\r\n        }\r\n      }\r\n\r\n      // Milchglas Transparenz: +1 Einfluss wenn keine NGO/Bewegung liegt\r\n      if (govSlot?.kind === 'spec' && (govSlot as SpecialCard).name === 'Milchglas Transparenz') {\r\n        const ngoMovementNames = ['Jennifer Doudna', 'Noam Chomsky', 'Bill Gates', 'Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'];\r\n        const hasNgoMovement = state.board[player].innen.some(c => c.kind === 'spec' && (c as SpecialCard).type === 'Öffentlichkeitskarte' && ngoMovementNames.includes(c.name));\r\n        if (!hasNgoMovement) influence += 1;\r\n      }\r\n\r\n      // Alternative Fakten: Gegner-Interventionen -1 Wirkung\r\n      const oppPubSlot = state.permanentSlots[opponent].public;\r\n      if (oppPubSlot?.kind === 'spec' && (oppPubSlot as SpecialCard).name === 'Alternative Fakten') {\r\n        // Reduziere Effekt von Interventionen (vereinfacht: -1 Einfluss weniger)\r\n        // Wird in der Intervention-Auswertung berücksichtigt\r\n      }\r\n\r\n      total += influence;\r\n    });\r\n\r\n    // 🔍 DEBUG: Final influence calculation\r\n    console.log(`🎯 sumRowWithAuras P${player}: Gesamt-Einfluss = ${total}`);\r\n    return total;\r\n  };\r\n\r\n  // playCard is now handled by useGameActions hook\r\n\r\n  // runAITurn is now handled by useGameAI hook - removed duplicate implementation\r\n\r\n  const applyStartOfTurnHooksLegacy = useCallback((player: Player, state: GameState) => {\r\n    logFunctionCall('applyStartOfTurnHooksLegacy', { player, round: state.round }, 'Starting legacy turn hooks');\r\n\r\n    const pool = [...state.board[player].innen, ...state.board[player].aussen];\r\n    pool.forEach(c => {\r\n        if (c.kind === 'pol') {\r\n        const polCard = c as PoliticianCard;\r\n        if (polCard._pledgeDown && polCard._pledgeDown.round === state.round) {\r\n          const oldInfluence = polCard.influence;\r\n          adjustInfluence(polCard, polCard._pledgeDown.amount, 'Wahlversprechen');\r\n          const newInfluence = polCard.influence;\r\n          log(`Wahlversprechen Abzug auf ${polCard.name}: ${oldInfluence} → ${newInfluence}`);\r\n          polCard._pledgeDown = null;\r\n        }\r\n        // reset once-per-round flags\r\n        polCard._hypedRoundFlag = false;\r\n      }\r\n    });\r\n\r\n    // Apply permanent initiative effects\r\n    const govSlot = state.permanentSlots[player].government;\r\n    const pubSlot = state.permanentSlots[player].public;\r\n\r\n    if (govSlot && govSlot.kind === 'spec') {\r\n      const govInitiative = govSlot as SpecialCard;\r\n      logFunctionCall('applyPermanentInitiative', { slot: 'government', initiative: govInitiative.name }, 'Processing government permanent initiative');\r\n\r\n      if (govInitiative.name === 'Alternative Fakten') {\r\n        // Alle Oligarchen geben +1 Einfluss\r\n        const oligarchCards = pool.filter(c =>\r\n          c.kind === 'pol' &&\r\n          ['Elon Musk', 'Bill Gates', 'George Soros', 'Warren Buffett', 'Mukesh Ambani', 'Jeff Bezos', 'Alisher Usmanov', 'Gautam Adani', 'Jack Ma', 'Zhang Yiming', 'Roman Abramovich'].includes(c.name)\r\n        ) as PoliticianCard[];\r\n\r\n        logDataFlow('board analysis', 'oligarch cards', {\r\n          count: oligarchCards.length,\r\n          cards: oligarchCards.map(c => ({ name: c.name, influence: c.kind === 'pol' ? (c as any).influence : 0 }))\r\n        }, 'Finding oligarch cards for Alternative Fakten effect');\r\n\r\n        let totalInfluenceGained = 0;\r\n        oligarchCards.forEach(card => {\r\n          const oldInfluence = card.influence;\r\n          adjustInfluence(card, 1, 'Alternative Fakten');\r\n          const newInfluence = card.influence;\r\n          totalInfluenceGained += 1;\r\n          logCardEffect('Alternative Fakten', `${card.name} erhält +1 Einfluss (${oldInfluence} → ${newInfluence})`);\r\n        });\r\n\r\n        if (oligarchCards.length > 0) {\r\n          logCardEffect('Alternative Fakten', `${oligarchCards.length} Oligarchen gefunden - ${totalInfluenceGained} Punkte zum Gesamteinfluss hinzugefügt`);\r\n        } else {\r\n          logWarning('No oligarch cards found', 'Alternative Fakten effect has no targets');\r\n        }\r\n      }\r\n    }\r\n\r\n    if (pubSlot && pubSlot.kind === 'spec') {\r\n      const pubInitiative = pubSlot as SpecialCard;\r\n      logFunctionCall('applyPermanentInitiative', { slot: 'public', initiative: pubInitiative.name }, 'Processing public permanent initiative');\r\n\r\n      if (pubInitiative.name === 'Algorithmischer Diskurs') {\r\n        // Alle Medien-Karten geben +1 Einfluss\r\n        const mediaCards = pool.filter(c =>\r\n          c.kind === 'pol' &&\r\n          ['Oprah Winfrey', 'Mark Zuckerberg', 'Tim Cook', 'Sam Altman'].includes(c.name)\r\n        ) as PoliticianCard[];\r\n\r\n        logDataFlow('board analysis', 'media cards', {\r\n          count: mediaCards.length,\r\n          cards: mediaCards.map(c => ({ name: c.name, influence: c.kind === 'pol' ? (c as any).influence : 0 }))\r\n        }, 'Finding media cards for Algorithmischer Diskurs effect');\r\n\r\n        let totalInfluenceGained = 0;\r\n        mediaCards.forEach(card => {\r\n          const oldInfluence = card.influence;\r\n          adjustInfluence(card, 1, 'Algorithmischer Diskurs');\r\n          const newInfluence = card.influence;\r\n          totalInfluenceGained += 1;\r\n          logCardEffect('Algorithmischer Diskurs', `${card.name} erhält +1 Einfluss (${oldInfluence} → ${newInfluence})`);\r\n        });\r\n\r\n        if (mediaCards.length > 0) {\r\n          logCardEffect('Algorithmischer Diskurs', `${mediaCards.length} Medien-Karten gefunden - ${totalInfluenceGained} Punkte zum Gesamteinfluss hinzugefügt`);\r\n        } else {\r\n          logWarning('No media cards found', 'Algorithmischer Diskurs effect has no targets');\r\n        }\r\n      }\r\n    }\r\n\r\n    // Legacy flags reset is replaced by the new applyStartOfTurnHooks implementation\r\n\r\n    logFunctionCall('applyStartOfTurnHooksLegacy', { player }, 'Legacy turn hooks completed');\r\n  }, [logFunctionCall, logDataFlow, logCardEffect, logWarning]);\r\n\r\n  // Helper: Leadership vorhanden?\r\n  const hasLeadershipCard = (player: Player, state: GameState): boolean => {\r\n    const gov = state.board[player].aussen;\r\n    const names = ['Justin Trudeau'];\r\n    return gov.some(c => c.kind === 'pol' && names.includes(c.name) && !(c as PoliticianCard).deactivated);\r\n  };\r\n\r\n  // Helper: Bewegung vorhanden? (Öffentlichkeitsreihe)\r\n  const hasMovementCard = (player: Player, state: GameState): boolean => {\r\n    const pub = state.board[player].innen;\r\n    const names = ['Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'];\r\n    return pub.some(c => c.kind === 'pol' && names.includes(c.name) && !(c as PoliticianCard).deactivated);\r\n  };\r\n\r\n  // Helper: Plattform vorhanden? (Öffentlichkeitsreihe)\r\n  const hasPlatformCard = (player: Player, state: GameState): boolean => {\r\n    const pub = state.board[player].innen;\r\n    const names = ['Mark Zuckerberg', 'Tim Cook', 'Jack Ma', 'Zhang Yiming'];\r\n    return pub.some(c => c.kind === 'pol' && names.includes(c.name) && !(c as PoliticianCard).deactivated);\r\n  };\r\n\r\n  // Helper: Diplomat vorhanden? (Regierungsreihe)\r\n  const hasDiplomatCard = (player: Player, state: GameState): boolean => {\r\n    const gov = state.board[player].aussen;\r\n    const names = ['Joschka Fischer', 'Sergey Lavrov', 'Ursula von der Leyen', 'Jens Stoltenberg', 'Horst Köhler', 'Walter Scheel', 'Hans Dietrich Genscher', 'Colin Powell', 'Condoleezza Rice', 'Christine Lagarde'];\r\n    return gov.some(c => c.kind === 'pol' && names.includes(c.name) && !(c as PoliticianCard).deactivated);\r\n  };\r\n\r\n  // Helper: Einfluss-Transfer durch Dauerhaft-Initiativen blockiert? (Koalitionszwang, Napoleon Komplex)\r\n  const hasInfluenceTransferBlock = (player: Player, state: GameState): boolean => {\r\n    const govSlot = state.permanentSlots[player].government;\r\n    if (!govSlot || govSlot.kind !== 'spec') return false;\r\n    const spec = govSlot as SpecialCard;\r\n    return ['Koalitionszwang', 'Napoleon Komplex'].includes(spec.name);\r\n  };\r\n\r\n  // Helper: Kann Spieler mehrere Interventionen spielen? (Putin-Fähigkeit)\r\n  const canPlayMultipleInterventions = (player: Player, state: GameState): boolean => {\r\n    const govCards = state.board[player].aussen.filter(c => c.kind === 'pol') as PoliticianCard[];\r\n    return govCards.some(c => c.name === 'Vladimir Putin' && !c.deactivated);\r\n  };\r\n\r\n  const selectHandCard = useCallback((index: number | null) => {\r\n    setSelectedHandIndex(index);\r\n  }, []);\r\n\r\n  const passTurn = useCallback((player: Player) => {\r\n    setGameState(prev => {\r\n      if (prev.current !== player) return prev;\r\n\r\n      const newState = { ...prev, passed: { ...prev.passed, [player]: true } };\r\n      log(`Spieler ${player} passt.`);\r\n\r\n      // If both players have passed, resolve the round\r\n      if (newState.passed[1] && newState.passed[2]) {\r\n        return resolveRound(newState);\r\n      }\r\n\r\n      return newState;\r\n    });\r\n  }, [log, resolveRound]);\r\n\r\n  // Diplomat-Einfluss-Transfer Funktion\r\n  const transferInfluence = useCallback((player: Player, fromCardUid: number, toCardUid: number, amount: number) => {\r\n    setGameState(prev => {\r\n      if (prev.current !== player) return prev;\r\n\r\n      const flags = prev.effectFlags?.[player];\r\n      if (!flags || flags.diplomatInfluenceTransferUsed || flags.influenceTransferBlocked) return prev;\r\n      if (!hasDiplomatCard(player, prev)) return prev;\r\n\r\n      // Finde beide Karten in der Regierungsreihe\r\n      const govCards = prev.board[player].aussen;\r\n      const fromCard = govCards.find(c => c.uid === fromCardUid && c.kind === 'pol') as PoliticianCard;\r\n      const toCard = govCards.find(c => c.uid === toCardUid && c.kind === 'pol') as PoliticianCard;\r\n\r\n      if (!fromCard || !toCard || fromCard.influence < amount) return prev;\r\n\r\n      // Transfer durchführen\r\n      adjustInfluence(fromCard, -amount, 'Diplomat-Transfer');\r\n      adjustInfluence(toCard, amount, 'Diplomat-Transfer');\r\n\r\n      // Flag setzen\r\n      const newFlags = { ...flags, diplomatInfluenceTransferUsed: true };\r\n      const newEffectFlags = { ...prev.effectFlags, [player]: newFlags } as GameState['effectFlags'];\r\n\r\n      log(`P${player} transferiert ${amount} Einfluss von ${fromCard.name} zu ${toCard.name} (Diplomat).`);\r\n\r\n      return {\r\n        ...prev,\r\n        effectFlags: newEffectFlags\r\n      };\r\n    });\r\n  }, [log]);\r\n\r\n  // Active Abilities Management\r\n  const getActiveAbilities = useCallback((player: Player) => {\r\n    return ActiveAbilitiesManager.getAvailableAbilities(player, gameState);\r\n  }, []);\r\n\r\n  const useActiveAbility = useCallback((abilityId: string, targetCardUid?: number) => {\r\n    setGameState(prev => {\r\n      const player = prev.current;\r\n      const abilities = ActiveAbilitiesManager.getAvailableAbilities(player, prev);\r\n      const ability = abilities.find(a => a.id === abilityId);\r\n\r\n      if (!ability || !ActiveAbilitiesManager.canUseAbility(ability, player, prev)) {\r\n        return prev;\r\n      }\r\n\r\n      // Finde Actor Card\r\n      const allCards = [...prev.board[player].innen, ...prev.board[player].aussen].filter(c => c.kind === 'pol') as PoliticianCard[];\r\n      const actorCard = allCards.find(c => ability.id.includes(c.uid.toString()));\r\n\r\n      if (!actorCard) return prev;\r\n\r\n      // Finde Target Card wenn nötig\r\n      let targetCard: PoliticianCard | undefined;\r\n      if (targetCardUid) {\r\n        const allTargets = [...prev.board[1].innen, ...prev.board[1].aussen, ...prev.board[2].innen, ...prev.board[2].aussen].filter(c => c.kind === 'pol') as PoliticianCard[];\r\n        targetCard = allTargets.find(c => c.uid === targetCardUid);\r\n      }\r\n\r\n      const select = {\r\n        type: ability.type,\r\n        actorCard,\r\n        actorPlayer: player,\r\n        targetCard\r\n      } as any;\r\n\r\n      const newState = ActiveAbilitiesManager.executeAbility(ability, select, prev);\r\n\r\n      log(`${actorCard.name} nutzt ${ability.name}${targetCard ? ` auf ${targetCard.name}` : ''}.`);\r\n\r\n      return newState;\r\n    });\r\n  }, [gameState, log]);\r\n\r\n  // Reset aktive Fähigkeiten zu Rundenbeginn\r\n  const resetActiveAbilities = useCallback((state: GameState): GameState => {\r\n    const newState = { ...state };\r\n\r\n    // Reset _activeUsed für alle Politikerkarten\r\n    [1, 2].forEach(player => {\r\n      const allCards = [...newState.board[player as Player].innen, ...newState.board[player as Player].aussen].filter(c => c.kind === 'pol') as PoliticianCard[];\r\n      allCards.forEach(card => {\r\n        card._activeUsed = false;\r\n      });\r\n    });\r\n\r\n    return newState;\r\n  }, []);\r\n\r\n  // Putin Doppelte Interventionen\r\n  const executePutinDoubleIntervention = useCallback((interventionCardIds: number[]) => {\r\n    setGameState(prev => {\r\n      const player = prev.current;\r\n      const newState = ActiveAbilitiesManager.executePutinDoubleIntervention(prev, player, interventionCardIds, log);\r\n      return newState;\r\n    });\r\n  }, [log]);\r\n\r\n  // Check ob Putin Doppel-Intervention verfügbar ist\r\n  const canUsePutinDoubleIntervention = useCallback((player: Player): boolean => {\r\n    const board = gameState.board[player];\r\n    const allCards = [...board.innen, ...board.aussen].filter(c => c.kind === 'pol') as PoliticianCard[];\r\n    const putin = allCards.find(c => c.name === 'Vladimir Putin');\r\n\r\n    if (!putin || putin.deactivated || putin._activeUsed) return false;\r\n\r\n    const interventions = gameState.hands[player].filter(c => c.kind === 'spec');\r\n    return interventions.length >= 2;\r\n  }, [gameState]);\r\n\r\n  // Manual turn advancement for testing\r\n  const manualAdvanceTurn = useCallback(() => {\r\n    console.log('🔧 DEBUG: Manual turn advancement triggered');\r\n    log('🔧 DEBUG: Manual turn advancement triggered');\r\n    nextTurn();\r\n  }, [nextTurn, log]);\r\n\r\n  return {\r\n    gameState,\r\n    selectedHandIndex,\r\n    log,\r\n    startNewGame,\r\n    selectHandCard: setSelectedHandIndex,\r\n    scores,\r\n    manualAdvanceTurn, // Manual turn advancement for testing\r\n\r\n    // Core game state functions\r\n    dealStartingHands,\r\n    resolveRound,\r\n    nextTurn: gameActions.nextTurn,\r\n    endTurn: gameActions.endTurn,\r\n    checkAndAdvanceTurn,\r\n    shouldAdvanceTurn,\r\n\r\n    // Helper functions kept for compatibility\r\n    hasLeadershipCard,\r\n    hasMovementCard,\r\n    hasPlatformCard,\r\n    hasDiplomatCard,\r\n    hasInfluenceTransferBlock,\r\n    canPlayMultipleInterventions,\r\n    sumRowWithAuras,\r\n    applyStartOfTurnHooksLegacy,\r\n\r\n    // Functions that were migrated to separate hooks\r\n    passTurn: gameActions.passTurn,\r\n    transferInfluence,\r\n    getActiveAbilities,\r\n    useActiveAbility,\r\n    resetActiveAbilities,\r\n    executePutinDoubleIntervention,\r\n    canUsePutinDoubleIntervention,\r\n\r\n    // Delegate primary functionality to separated hooks\r\n    startMatchWithDecks: gameActions.startMatchWithDecks,\r\n    startMatchVsAI: gameActions.startMatchVsAI,\r\n    playCard: gameActions.playCard,\r\n    activateInstantInitiative: gameActions.activateInstantInitiative,\r\n\r\n    // AI functionality\r\n    runAITurn: gameAI.runAITurn,\r\n    aiEnabled: gameAI.aiEnabled,\r\n    setAiEnabled: gameAI.setAiEnabled,\r\n    aiPreset: gameAI.aiPreset,\r\n    setAiPreset: gameAI.setAiPreset,\r\n\r\n    // Effects functionality\r\n    executeCardEffect,\r\n    processEffectQueue,\r\n    afterQueueResolved,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}