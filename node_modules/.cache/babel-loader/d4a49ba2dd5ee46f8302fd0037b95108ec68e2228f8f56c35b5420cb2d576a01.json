{"ast":null,"code":"import { CARD_BY_ID } from '../data/cards';\nexport function registerTrap(state, player, key) {\n  if (!state.traps) state.traps = {\n    1: [],\n    2: []\n  };\n  const list = state.traps[player];\n  if (!Array.isArray(list)) state.traps[player] = [];\n  state.traps[player].push({\n    owner: player,\n    key\n  });\n}\nexport function applyTrapsOnCardPlayed(state, playedBy, card, enqueue, log) {\n  var _state$traps, _state$effectFlags$pl, _cardDef$tags, _cardDef$tags2;\n  const opp = playedBy === 1 ? 2 : 1;\n  const traps = (_state$traps = state.traps) === null || _state$traps === void 0 ? void 0 : _state$traps[opp];\n  if (!traps || traps.length === 0) return;\n\n  // Diagnostics: log existing traps for opponent when a card is played\n  try {\n    const keys = traps.map(t => t.key).join(', ');\n    enqueue({\n      type: 'LOG',\n      msg: `DEBUG: applyTrapsOnCardPlayed opp=${opp} traps=[${keys}] playedCard=${card.name || card.key || 'unknown'}`\n    });\n  } catch (e) {}\n\n  // Hard rule: Opposition Blockade â€“ if current player is locked, cancel initiative card immediately\n  if ((card === null || card === void 0 ? void 0 : card.type) === 'initiative' && (_state$effectFlags$pl = state.effectFlags[playedBy]) !== null && _state$effectFlags$pl !== void 0 && _state$effectFlags$pl.initiativesLocked) {\n    if (card.uid != null) {\n      enqueue({\n        type: 'CANCEL_CARD',\n        player: playedBy,\n        targetUid: card.uid\n      });\n    }\n    enqueue({\n      type: 'LOG',\n      msg: 'Blocked: initiatives are locked (Opposition Blockade).'\n    });\n    return; // skip further trap processing\n  }\n\n  // Get card definition to access type and tags\n  const cardDef = CARD_BY_ID[card.key];\n  const isInitiative = (cardDef === null || cardDef === void 0 ? void 0 : cardDef.type) === 'initiative';\n  const isPublic = (cardDef === null || cardDef === void 0 ? void 0 : cardDef.type) === 'public';\n  const isGovernment = (cardDef === null || cardDef === void 0 ? void 0 : cardDef.type) === 'government';\n  const isMediaLike = (cardDef === null || cardDef === void 0 ? void 0 : (_cardDef$tags = cardDef.tags) === null || _cardDef$tags === void 0 ? void 0 : _cardDef$tags.includes('Media')) || (cardDef === null || cardDef === void 0 ? void 0 : (_cardDef$tags2 = cardDef.tags) === null || _cardDef$tags2 === void 0 ? void 0 : _cardDef$tags2.includes('Platform')) || (card === null || card === void 0 ? void 0 : card.tag) === 'Media'; // Fallback fÃ¼r Legacy-Karten\n\n  const consumed = [];\n  traps.forEach(t => {\n    switch (t.key) {\n      // bereits live benutzt\n      case 'trap.fake_news.deactivate_media':\n        if (isMediaLike && card.uid != null) {\n          enqueue({\n            type: 'DEACTIVATE_CARD',\n            player: opp,\n            targetUid: card.uid\n          });\n          log('Trap: Fake News â€“ deactivated media/platform card.');\n          consumed.push(t);\n        }\n        break;\n\n      // neu: Initiative canceln (sofort beim Ausspielen der Initiative)\n      case 'trap.legal_injunction.cancel_next_initiative':\n        if (isInitiative && card.uid != null) {\n          enqueue({\n            type: 'CANCEL_CARD',\n            player: opp,\n            targetUid: card.uid\n          });\n          log('Trap: Legal Injunction â€“ cancelled initiative.');\n          consumed.push(t);\n        }\n        break;\n\n      // neu: Karte zurÃ¼ck auf Hand (egal welcher Typ)\n      case 'trap.whistleblower.return_last_played':\n        if (card.uid != null) {\n          enqueue({\n            type: 'RETURN_TO_HAND',\n            player: playedBy,\n            targetUid: card.uid\n          });\n          log('Trap: Whistleblower â€“ returned played card to hand.');\n          consumed.push(t);\n        }\n        break;\n\n      // neu: Gegner discards 2 bei nÃ¤chstem Play\n      case 'trap.data_breach.opp_discard2':\n        enqueue({\n          type: 'DISCARD_RANDOM_FROM_HAND',\n          player: playedBy === 1 ? 2 : 1,\n          amount: 2\n        });\n        log('Trap: Data Breach â€“ opponent discards 2.');\n        consumed.push(t);\n        break;\n\n      // neu: Public deaktivieren\n      case 'trap.media_blackout.deactivate_public':\n        if (isPublic && card.uid != null) {\n          enqueue({\n            type: 'DEACTIVATE_CARD',\n            player: opp,\n            targetUid: card.uid\n          });\n          log('Trap: Media Blackout â€“ deactivated public card.');\n          consumed.push(t);\n        }\n        break;\n\n      // neu: AP -2 fÃ¼r Gegner beim nÃ¤chsten Play\n      case 'trap.budget_freeze.opp_ap_minus2':\n        enqueue({\n          type: 'ADD_AP',\n          player: playedBy,\n          amount: -2\n        });\n        log('Trap: Budget Freeze â€“ opponent AP -2.');\n        consumed.push(t);\n        break;\n\n      // neu: Government deaktivieren\n      case 'trap.sabotage.deactivate_gov':\n        if (isGovernment && card.uid != null) {\n          enqueue({\n            type: 'DEACTIVATE_CARD',\n            player: opp,\n            targetUid: card.uid\n          });\n          log('Trap: Sabotage â€“ deactivated government card.');\n          consumed.push(t);\n        }\n        break;\n\n      // Strategic Disclosure: Government-Karte zurÃ¼ckgeben\n      case 'trap.strategic_disclosure.return_gov':\n        if (isGovernment && card.uid != null) {\n          enqueue({\n            type: 'RETURN_TO_HAND',\n            player: playedBy,\n            targetUid: card.uid\n          });\n          log('Trap: Strategic Disclosure â€“ returned government card to hand.');\n          consumed.push(t);\n        }\n        break;\n      case 'trap.whistleblower.debuff_next_gov_minus2':\n        // Robust trigger: treat any played politician (pol) as government trigger\n        const playedIsPol = (card === null || card === void 0 ? void 0 : card.kind) === 'pol' || isGovernment;\n        if (!playedIsPol) {\n          // not a government/pol card â€” skip\n          enqueue({\n            type: 'LOG',\n            msg: `DEBUG: Whistleblower present but played card is not government/pol (${card.name || card.key})`\n          });\n          break;\n        }\n        if (card.uid == null) {\n          enqueue({\n            type: 'LOG',\n            msg: `DEBUG: Whistleblower cannot apply - target missing uid for ${card.name || card.key}`\n          });\n          break;\n        }\n\n        // Compute number of Activist cards on both players' boards (innen + aussen)\n        const cd = require('../data/cardDetails');\n        let activistCount = 0;\n        for (const p of [1, 2]) {\n          var _state$board$p, _state$board$p2;\n          const innen = ((_state$board$p = state.board[p]) === null || _state$board$p === void 0 ? void 0 : _state$board$p.innen) || [];\n          const aussen = ((_state$board$p2 = state.board[p]) === null || _state$board$p2 === void 0 ? void 0 : _state$board$p2.aussen) || [];\n          const all = [...innen, ...aussen];\n          for (const c of all) {\n            var _cd$getCardDetails, _cd$getCardDetails$ca;\n            if (!c) continue;\n            const subcats = (_cd$getCardDetails = cd.getCardDetails) === null || _cd$getCardDetails === void 0 ? void 0 : (_cd$getCardDetails$ca = _cd$getCardDetails.call(cd, c.name)) === null || _cd$getCardDetails$ca === void 0 ? void 0 : _cd$getCardDetails$ca.subcategories;\n            const legacyTag = c.tag === 'Activist' || c.tag === 'Aktivist' || c.tag === 'Activists' || c.tag === 'Movement';\n            if (Array.isArray(subcats) && subcats.includes('Activist') || legacyTag) {\n              // ignore deactivated public/pol cards\n              if (!c.deactivated) activistCount++;\n            }\n          }\n        }\n\n        // Base debuff -2 plus -1 per Activist (both boards), capped at -6 total\n        const totalDebuffMagnitude = Math.min(6, 2 + activistCount);\n        const amount = -totalDebuffMagnitude;\n        enqueue({\n          type: 'DEBUFF_CARD',\n          player: opp,\n          targetUid: card.uid,\n          amount\n        });\n        const debuffMsg = `Trap: Whistleblower â€“ government card gets ${amount} Influence (base -2 + activists ${activistCount}, capped at -6).`;\n        enqueue({\n          type: 'LOG',\n          msg: debuffMsg\n        });\n        // Immediate console log for better chronological trace before warnings\n        log(debuffMsg);\n        log(`ðŸŸ¢ trap.whistleblower triggered: applied ${amount} to uid ${card.uid} (activists=${activistCount})`);\n        consumed.push(t);\n        break;\n      default:\n        break;\n    }\n  });\n  if (consumed.length) {\n    // Build consumption indexes for robust removal\n    const consumedKeys = new Set(consumed.map(c => c.key).filter(Boolean));\n    // Also include base card keys (namespace + card) to catch visual trap card objects\n    // Example: 'trap.whistleblower.return_last_played' -> add 'trap.whistleblower'\n    for (const k of Array.from(consumedKeys)) {\n      if (typeof k === 'string') {\n        const parts = k.split('.');\n        if (parts.length >= 3) {\n          const baseKey = parts.slice(0, 2).join('.');\n          consumedKeys.add(baseKey);\n        }\n      }\n    }\n    const consumedUids = new Set(consumed.map(c => c.uid).filter(Boolean));\n    const consumedNames = new Set(consumed.map(c => c.name).filter(Boolean));\n    const consumedRefs = new Set(consumed);\n\n    // Remove consumed trap registrations and any visual trap card objects from both players' trap lists\n    for (const p of [1, 2]) {\n      const list = state.traps[p] || [];\n      state.traps[p] = list.filter(entry => {\n        if (!entry) return false;\n        // Direct reference match\n        if (consumedRefs.has(entry)) return false;\n        // registration object with key\n        if (entry.key && consumedKeys.has(entry.key)) return false;\n        // match by uid\n        if (entry.uid && consumedUids.has(entry.uid)) return false;\n        // match by name\n        if (entry.name && consumedNames.has(entry.name)) return false;\n\n        // If entry looks like a card object, also remove if its type explicitly indicates a trap\n        if (entry && entry.kind === 'spec') {\n          const typeStr = String(entry.type || '').toLowerCase();\n          if (typeStr.includes('trap')) return false;\n        }\n        return true;\n      });\n    }\n\n    // Ensure the visual trap card is removed from any board lanes if it was added there\n    try {\n      var _state$board;\n      const removeIfTrapOnBoard = arr => {\n        return arr.filter(c => {\n          if (!c) return true;\n          const key = c.key || c.name && String(c.name).toLowerCase().replace(/[^a-z0-9_.-]/g, '_');\n          const typeStr = String(c.type || '').toLowerCase();\n          if (typeStr.includes('trap')) return false;\n          if (key && consumedKeys.has(key)) return false;\n          return true;\n        });\n      };\n\n      // Remove from opponent board lanes (innen, aussen, sofort)\n      if ((_state$board = state.board) !== null && _state$board !== void 0 && _state$board[opp]) {\n        state.board[opp].innen = removeIfTrapOnBoard(state.board[opp].innen || []);\n        state.board[opp].aussen = removeIfTrapOnBoard(state.board[opp].aussen || []);\n        state.board[opp].sofort = removeIfTrapOnBoard(state.board[opp].sofort || []);\n      }\n      // Additionally, remove any consumed trap card objects from all board lanes and move them to discard\n      try {\n        for (const c of consumed) {\n          const cUid = c.uid;\n          const cKey = c.key || c.name;\n          for (const p of [1, 2]) {\n            for (const lane of ['innen', 'aussen', 'sofort']) {\n              const arr = state.board[p][lane];\n              const idx = arr.findIndex(card => card && (card.uid && cUid && card.uid === cUid || card.key && cKey && card.key === cKey || card.name && cKey && card.name === cKey));\n              if (idx !== -1) {\n                const [removed] = arr.splice(idx, 1);\n                state.discard = state.discard || [];\n                state.discard.push(removed);\n                enqueue({\n                  type: 'LOG',\n                  msg: `Trap consumed: removed ${removed && removed.name || cKey} from board and moved to discard.`\n                });\n              }\n            }\n          }\n        }\n      } catch (e) {}\n    } catch (e) {}\n  }\n}","map":{"version":3,"names":["CARD_BY_ID","registerTrap","state","player","key","traps","list","Array","isArray","push","owner","applyTrapsOnCardPlayed","playedBy","card","enqueue","log","_state$traps","_state$effectFlags$pl","_cardDef$tags","_cardDef$tags2","opp","length","keys","map","t","join","type","msg","name","e","effectFlags","initiativesLocked","uid","targetUid","cardDef","isInitiative","isPublic","isGovernment","isMediaLike","tags","includes","tag","consumed","forEach","amount","playedIsPol","kind","cd","require","activistCount","p","_state$board$p","_state$board$p2","innen","board","aussen","all","c","_cd$getCardDetails","_cd$getCardDetails$ca","subcats","getCardDetails","call","subcategories","legacyTag","deactivated","totalDebuffMagnitude","Math","min","debuffMsg","consumedKeys","Set","filter","Boolean","k","from","parts","split","baseKey","slice","add","consumedUids","consumedNames","consumedRefs","entry","has","typeStr","String","toLowerCase","_state$board","removeIfTrapOnBoard","arr","replace","sofort","cUid","cKey","lane","idx","findIndex","removed","splice","discard"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/utils/traps.ts"],"sourcesContent":["import type { GameState, Player, Card } from '../types/game';\r\nimport type { EffectEvent } from '../types/effects';\r\nimport { CARD_BY_ID } from '../data/cards';\r\n\r\nexport function registerTrap(state: GameState, player: Player, key: string) {\r\n  if (!state.traps) state.traps = { 1: [], 2: [] } as any;\r\n  const list = (state.traps as any)[player] as Array<{ owner: Player; key: string }>;\r\n  if (!Array.isArray(list)) (state.traps as any)[player] = [];\r\n  (state.traps as any)[player].push({ owner: player, key });\r\n}\r\n\r\nexport function applyTrapsOnCardPlayed(\r\n  state: GameState,\r\n  playedBy: Player,\r\n  card: Card,\r\n  enqueue: (e: EffectEvent) => void,\r\n  log: (m: string) => void\r\n) {\r\n  const opp: Player = playedBy === 1 ? 2 : 1;\r\n  const traps = (state.traps as any)?.[opp] as Array<{ owner: Player; key: string }> | undefined;\r\n  if (!traps || traps.length === 0) return;\r\n\r\n  // Diagnostics: log existing traps for opponent when a card is played\r\n  try {\r\n    const keys = traps.map(t => t.key).join(', ');\r\n    enqueue({ type: 'LOG', msg: `DEBUG: applyTrapsOnCardPlayed opp=${opp} traps=[${keys}] playedCard=${(card as any).name || (card as any).key || 'unknown'}` });\r\n  } catch (e) {}\r\n\r\n  // Hard rule: Opposition Blockade â€“ if current player is locked, cancel initiative card immediately\r\n  if ((card as any)?.type === 'initiative' && state.effectFlags[playedBy]?.initiativesLocked) {\r\n    if ((card as any).uid != null) {\r\n      enqueue({ type: 'CANCEL_CARD', player: playedBy, targetUid: (card as any).uid } as any);\r\n    }\r\n    enqueue({ type: 'LOG', msg: 'Blocked: initiatives are locked (Opposition Blockade).' });\r\n    return; // skip further trap processing\r\n  }\r\n\r\n  // Get card definition to access type and tags\r\n  const cardDef = CARD_BY_ID[card.key];\r\n  const isInitiative = cardDef?.type === 'initiative';\r\n  const isPublic = cardDef?.type === 'public';\r\n  const isGovernment = cardDef?.type === 'government';\r\n  const isMediaLike = cardDef?.tags?.includes('Media') ||\r\n                     cardDef?.tags?.includes('Platform') ||\r\n                     (card as any)?.tag === 'Media'; // Fallback fÃ¼r Legacy-Karten\r\n\r\n  const consumed: Array<{ key: string }> = [];\r\n  traps.forEach(t => {\r\n    switch (t.key) {\r\n      // bereits live benutzt\r\n      case 'trap.fake_news.deactivate_media':\r\n        if (isMediaLike && (card as any).uid != null) {\r\n          enqueue({ type: 'DEACTIVATE_CARD', player: opp, targetUid: (card as any).uid });\r\n          log('Trap: Fake News â€“ deactivated media/platform card.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // neu: Initiative canceln (sofort beim Ausspielen der Initiative)\r\n      case 'trap.legal_injunction.cancel_next_initiative':\r\n        if (isInitiative && (card as any).uid != null) {\r\n          enqueue({ type: 'CANCEL_CARD', player: opp, targetUid: (card as any).uid });\r\n          log('Trap: Legal Injunction â€“ cancelled initiative.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // neu: Karte zurÃ¼ck auf Hand (egal welcher Typ)\r\n      case 'trap.whistleblower.return_last_played':\r\n        if ((card as any).uid != null) {\r\n          enqueue({ type: 'RETURN_TO_HAND', player: playedBy, targetUid: (card as any).uid });\r\n          log('Trap: Whistleblower â€“ returned played card to hand.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // neu: Gegner discards 2 bei nÃ¤chstem Play\r\n      case 'trap.data_breach.opp_discard2':\r\n        enqueue({ type: 'DISCARD_RANDOM_FROM_HAND', player: playedBy === 1 ? 2 : 1, amount: 2 });\r\n        log('Trap: Data Breach â€“ opponent discards 2.');\r\n        consumed.push(t);\r\n        break;\r\n\r\n      // neu: Public deaktivieren\r\n      case 'trap.media_blackout.deactivate_public':\r\n        if (isPublic && (card as any).uid != null) {\r\n          enqueue({ type: 'DEACTIVATE_CARD', player: opp, targetUid: (card as any).uid });\r\n          log('Trap: Media Blackout â€“ deactivated public card.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // neu: AP -2 fÃ¼r Gegner beim nÃ¤chsten Play\r\n      case 'trap.budget_freeze.opp_ap_minus2':\r\n        enqueue({ type: 'ADD_AP', player: playedBy, amount: -2 });\r\n        log('Trap: Budget Freeze â€“ opponent AP -2.');\r\n        consumed.push(t);\r\n        break;\r\n\r\n      // neu: Government deaktivieren\r\n      case 'trap.sabotage.deactivate_gov':\r\n        if (isGovernment && (card as any).uid != null) {\r\n          enqueue({ type: 'DEACTIVATE_CARD', player: opp, targetUid: (card as any).uid });\r\n          log('Trap: Sabotage â€“ deactivated government card.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // Strategic Disclosure: Government-Karte zurÃ¼ckgeben\r\n      case 'trap.strategic_disclosure.return_gov':\r\n        if (isGovernment && (card as any).uid != null) {\r\n          enqueue({ type: 'RETURN_TO_HAND', player: playedBy, targetUid: (card as any).uid });\r\n          log('Trap: Strategic Disclosure â€“ returned government card to hand.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      case 'trap.whistleblower.debuff_next_gov_minus2':\r\n        // Robust trigger: treat any played politician (pol) as government trigger\r\n        const playedIsPol = (card as any)?.kind === 'pol' || isGovernment;\r\n        if (!playedIsPol) {\r\n          // not a government/pol card â€” skip\r\n          enqueue({ type: 'LOG', msg: `DEBUG: Whistleblower present but played card is not government/pol (${(card as any).name || (card as any).key})` });\r\n          break;\r\n        }\r\n        if ((card as any).uid == null) {\r\n          enqueue({ type: 'LOG', msg: `DEBUG: Whistleblower cannot apply - target missing uid for ${(card as any).name || (card as any).key}` });\r\n          break;\r\n        }\r\n\r\n        // Compute number of Activist cards on both players' boards (innen + aussen)\r\n        const cd = require('../data/cardDetails') as any;\r\n        let activistCount = 0;\r\n        for (const p of [1, 2] as const) {\r\n          const innen = state.board[p]?.innen || [];\r\n          const aussen = state.board[p]?.aussen || [];\r\n          const all = [...innen, ...aussen];\r\n          for (const c of all) {\r\n            if (!c) continue;\r\n            const subcats = cd.getCardDetails?.((c as any).name)?.subcategories as string[] | undefined;\r\n            const legacyTag = (c as any).tag === 'Activist' || (c as any).tag === 'Aktivist' || (c as any).tag === 'Activists' || (c as any).tag === 'Movement';\r\n            if ((Array.isArray(subcats) && subcats.includes('Activist')) || legacyTag) {\r\n              // ignore deactivated public/pol cards\r\n              if (!(c as any).deactivated) activistCount++;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Base debuff -2 plus -1 per Activist (both boards), capped at -6 total\r\n        const totalDebuffMagnitude = Math.min(6, 2 + activistCount);\r\n        const amount = -totalDebuffMagnitude;\r\n\r\n        enqueue({ type: 'DEBUFF_CARD', player: opp, targetUid: (card as any).uid, amount } as any);\r\n        const debuffMsg = `Trap: Whistleblower â€“ government card gets ${amount} Influence (base -2 + activists ${activistCount}, capped at -6).`;\r\n        enqueue({ type: 'LOG', msg: debuffMsg });\r\n        // Immediate console log for better chronological trace before warnings\r\n        log(debuffMsg);\r\n        log(`ðŸŸ¢ trap.whistleblower triggered: applied ${amount} to uid ${(card as any).uid} (activists=${activistCount})`);\r\n        consumed.push(t);\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  });\r\n\r\n  if (consumed.length) {\r\n    // Build consumption indexes for robust removal\r\n    const consumedKeys = new Set(consumed.map(c => (c as any).key).filter(Boolean));\r\n    // Also include base card keys (namespace + card) to catch visual trap card objects\r\n    // Example: 'trap.whistleblower.return_last_played' -> add 'trap.whistleblower'\r\n    for (const k of Array.from(consumedKeys)) {\r\n      if (typeof k === 'string') {\r\n        const parts = k.split('.');\r\n        if (parts.length >= 3) {\r\n          const baseKey = parts.slice(0, 2).join('.');\r\n          consumedKeys.add(baseKey);\r\n        }\r\n      }\r\n    }\r\n    const consumedUids = new Set(consumed.map(c => (c as any).uid).filter(Boolean));\r\n    const consumedNames = new Set(consumed.map(c => (c as any).name).filter(Boolean));\r\n    const consumedRefs = new Set(consumed);\r\n\r\n    // Remove consumed trap registrations and any visual trap card objects from both players' trap lists\r\n    for (const p of [1, 2] as const) {\r\n      const list = (state.traps as any)[p] || [];\r\n      (state.traps as any)[p] = list.filter((entry: any) => {\r\n        if (!entry) return false;\r\n        // Direct reference match\r\n        if (consumedRefs.has(entry)) return false;\r\n        // registration object with key\r\n        if (entry.key && consumedKeys.has(entry.key)) return false;\r\n        // match by uid\r\n        if ((entry as any).uid && consumedUids.has((entry as any).uid)) return false;\r\n        // match by name\r\n        if ((entry as any).name && consumedNames.has((entry as any).name)) return false;\r\n\r\n        // If entry looks like a card object, also remove if its type explicitly indicates a trap\r\n        if (entry && entry.kind === 'spec') {\r\n          const typeStr = String((entry as any).type || '').toLowerCase();\r\n          if (typeStr.includes('trap')) return false;\r\n        }\r\n\r\n        return true;\r\n      });\r\n    }\r\n\r\n    // Ensure the visual trap card is removed from any board lanes if it was added there\r\n    try {\r\n      const removeIfTrapOnBoard = (arr: any[]) => {\r\n        return arr.filter(c => {\r\n          if (!c) return true;\r\n          const key = (c as any).key || (((c as any).name) && String((c as any).name).toLowerCase().replace(/[^a-z0-9_.-]/g, '_'));\r\n          const typeStr = String((c as any).type || '').toLowerCase();\r\n          if (typeStr.includes('trap')) return false;\r\n          if (key && consumedKeys.has(key)) return false;\r\n          return true;\r\n        });\r\n      };\r\n\r\n      // Remove from opponent board lanes (innen, aussen, sofort)\r\n      if (state.board?.[opp]) {\r\n        state.board[opp].innen = removeIfTrapOnBoard(state.board[opp].innen || []);\r\n        state.board[opp].aussen = removeIfTrapOnBoard(state.board[opp].aussen || []);\r\n        state.board[opp].sofort = removeIfTrapOnBoard(state.board[opp].sofort || []);\r\n      }\r\n      // Additionally, remove any consumed trap card objects from all board lanes and move them to discard\r\n      try {\r\n        for (const c of consumed) {\r\n          const cUid = (c as any).uid;\r\n          const cKey = (c as any).key || (c as any).name;\r\n          for (const p of [1, 2] as const) {\r\n            for (const lane of ['innen', 'aussen', 'sofort'] as const) {\r\n              const arr = state.board[p][lane] as any[];\r\n              const idx = arr.findIndex(card => (card && ((card.uid && cUid && card.uid === cUid) || (card.key && cKey && card.key === cKey) || (card.name && cKey && card.name === cKey))));\r\n              if (idx !== -1) {\r\n                const [removed] = arr.splice(idx, 1);\r\n                state.discard = state.discard || [];\r\n                state.discard.push(removed);\r\n                enqueue({ type: 'LOG', msg: `Trap consumed: removed ${(removed && removed.name) || cKey} from board and moved to discard.` });\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } catch (e) {}\r\n    } catch (e) {}\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}