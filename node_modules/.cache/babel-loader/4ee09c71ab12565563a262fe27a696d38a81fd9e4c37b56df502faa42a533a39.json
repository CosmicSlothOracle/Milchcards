{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\skank\\\\Videos\\\\Cards\\\\Milchcards\\\\src\\\\components\\\\Dice3D.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useImperativeHandle, forwardRef } from 'react';\nimport * as THREE from 'three';\nimport { gsap } from 'gsap';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n/**\n * Dice3D – simple WebGL dice rendered with three.js\n * Usage:\n *   const diceRef = useRef<Dice3DHandle>(null);\n *   <Dice3D ref={diceRef} onRoll={(f)=>console.log(f)}/>\n *   diceRef.current?.roll();\n */\nconst Dice3D = /*#__PURE__*/_s(/*#__PURE__*/forwardRef(_c = _s(({\n  size = 180,\n  duration = 1200,\n  onRoll,\n  className\n}, ref) => {\n  _s();\n  const canvasRef = useRef(null);\n  const sceneRef = useRef();\n  const cubeRef = useRef();\n  const rendererRef = useRef();\n  const cameraRef = useRef();\n  const animIdRef = useRef(0);\n\n  /** helper to create a texture with pips */\n  const createFaceTexture = face => {\n    const size = 128;\n    const cvs = document.createElement('canvas');\n    cvs.width = cvs.height = size;\n    const ctx = cvs.getContext('2d');\n    ctx.fillStyle = '#fff';\n    ctx.fillRect(0, 0, size, size);\n    ctx.fillStyle = '#111';\n    const dot = (x, y) => {\n      ctx.beginPath();\n      ctx.arc(x, y, size * 0.1, 0, Math.PI * 2);\n      ctx.fill();\n    };\n    const g = size * 0.25;\n    const centers = {\n      1: [[size / 2, size / 2]],\n      2: [[g, g], [size - g, size - g]],\n      3: [[g, g], [size / 2, size / 2], [size - g, size - g]],\n      4: [[g, g], [size - g, g], [g, size - g], [size - g, size - g]],\n      5: [[g, g], [size - g, g], [size / 2, size / 2], [g, size - g], [size - g, size - g]],\n      6: [[g, g], [size - g, g], [g, size / 2], [size - g, size / 2], [g, size - g], [size - g, size - g]]\n    };\n    centers[face].forEach(([x, y]) => dot(x, y));\n    const tex = new THREE.CanvasTexture(cvs);\n    tex.needsUpdate = true;\n    return tex;\n  };\n\n  // initialize three scene\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x000000);\n    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);\n    camera.position.z = 4;\n    const renderer = new THREE.WebGLRenderer({\n      canvas,\n      antialias: true,\n      alpha: true\n    });\n    renderer.setSize(size, size);\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n    // lights\n    const ambient = new THREE.AmbientLight(0xffffff, 0.6);\n    scene.add(ambient);\n    const dir = new THREE.DirectionalLight(0xffffff, 1.0);\n    dir.position.set(5, 10, 7);\n    dir.castShadow = true;\n    dir.shadow.mapSize.width = 1024;\n    dir.shadow.mapSize.height = 1024;\n    dir.shadow.camera.left = -5;\n    dir.shadow.camera.right = 5;\n    dir.shadow.camera.top = 5;\n    dir.shadow.camera.bottom = -5;\n    scene.add(dir);\n\n    // ground plane to receive shadow\n    const planeGeo = new THREE.PlaneGeometry(10, 10);\n    const planeMat = new THREE.ShadowMaterial({\n      opacity: 0.35\n    });\n    const plane = new THREE.Mesh(planeGeo, planeMat);\n    plane.rotation.x = -Math.PI / 2;\n    plane.position.y = -1.1;\n    plane.receiveShadow = true;\n    scene.add(plane);\n\n    // cube\n    const materials = [1, 2, 3, 4, 5, 6].map(f => new THREE.MeshStandardMaterial({\n      map: createFaceTexture(f),\n      metalness: 0.1,\n      roughness: 0.6\n    }));\n    const geometry = new THREE.BoxGeometry(2, 2, 2);\n    const cube = new THREE.Mesh(geometry, materials);\n    cube.castShadow = true;\n    cube.receiveShadow = false;\n    scene.add(cube);\n    sceneRef.current = scene;\n    cubeRef.current = cube;\n    rendererRef.current = renderer;\n    cameraRef.current = camera;\n\n    // animation loop\n    const animate = () => {\n      animIdRef.current = requestAnimationFrame(animate);\n      // subtle idle rotate\n      if (cube) {\n        cube.rotation.x *= 0.995;\n        cube.rotation.y *= 0.995;\n      }\n      renderer.render(scene, camera);\n    };\n    animate();\n    return () => {\n      cancelAnimationFrame(animIdRef.current);\n      renderer.dispose();\n    };\n  }, [size]);\n\n  // roll logic (includes DOM motion)\n  const rollInternal = targetFace => {\n    if (!cubeRef.current) return;\n    const cube = cubeRef.current;\n    // pick target if not provided\n    const face = targetFace !== null && targetFace !== void 0 ? targetFace : 1 + Math.floor(Math.random() * 6);\n\n    // orientation map: face -> Euler rotation (approx)\n    const orientations = {\n      1: [0, 0, 0],\n      2: [0, Math.PI / 2, 0],\n      3: [-Math.PI / 2, 0, 0],\n      4: [Math.PI / 2, 0, 0],\n      5: [0, -Math.PI / 2, 0],\n      6: [Math.PI, 0, 0]\n    };\n    const [tx, ty, tz] = orientations[face];\n    const start = {\n      x: cube.rotation.x,\n      y: cube.rotation.y,\n      z: cube.rotation.z\n    };\n    const end = {\n      x: tx + 2 * Math.PI,\n      y: ty + 2 * Math.PI,\n      z: tz + 2 * Math.PI\n    };\n\n    // Use GSAP timeline for smooth rotation + bounces and DOM motion\n    const timeline = gsap.timeline({\n      onComplete: () => {\n        cube.rotation.set(tx, ty, tz);\n        if (onRoll) onRoll(face);\n      }\n    });\n\n    // random screen path\n    const canvasEl = canvasRef.current;\n    if (canvasEl && canvasEl.style) {\n      canvasEl.style.position = 'fixed';\n      canvasEl.style.left = '0px';\n      canvasEl.style.top = '0px';\n      canvasEl.style.willChange = 'transform';\n      // pick random path points\n      const startX = Math.random() * (window.innerWidth - size);\n      const startY = Math.random() * (window.innerHeight - size);\n      const midX = Math.random() * (window.innerWidth - size);\n      const midY = Math.random() * (window.innerHeight - size);\n      const endX = Math.random() * (window.innerWidth - size);\n      const endY = Math.random() * (window.innerHeight - size);\n      timeline.to({}, {\n        duration: 0.01\n      }); // tiny offset\n      timeline.to(canvasEl, {\n        duration: duration / 1000,\n        x: endX,\n        y: endY,\n        ease: 'power2.inOut'\n      }, 0);\n    }\n\n    // rotation: spin multiple revolutions then ease to final orientation\n    // we'll use a GSAP ticker to update cube.rotation\n    const totalSpins = 3 + Math.floor(Math.random() * 4);\n    const rotEnd = {\n      x: end.x,\n      y: end.y,\n      z: end.z\n    };\n    const rotStart = {\n      x: start.x,\n      y: start.y,\n      z: start.z\n    };\n\n    // animate rotation using timeline with an onUpdate that writes to cube\n    let progress = {\n      t: 0\n    };\n    timeline.to(progress, {\n      t: 1,\n      duration: duration / 1000,\n      ease: 'power3.out',\n      onUpdate: () => {\n        const k = progress.t;\n        // combine ease with extra spins\n        const spinFactor = 1 - Math.pow(1 - k, 3);\n        const currentX = rotStart.x + (rotEnd.x - rotStart.x) * k + totalSpins * Math.PI * 2 * (1 - (1 - k));\n        const currentY = rotStart.y + (rotEnd.y - rotStart.y) * k + totalSpins * Math.PI * 2 * (1 - (1 - k));\n        const currentZ = rotStart.z + (rotEnd.z - rotStart.z) * k + totalSpins * Math.PI * 2 * (1 - (1 - k));\n        cube.rotation.set(currentX, currentY, currentZ);\n      }\n    });\n\n    // small bounce sequence on completion (scale + tilt)\n    timeline.to(cube.scale, {\n      x: 1.06,\n      y: 0.94,\n      z: 0.94,\n      duration: 0.08,\n      yoyo: true,\n      repeat: 1,\n      ease: 'power2.out'\n    }, '>-0.1');\n    timeline.to(cube.scale, {\n      x: 0.97,\n      y: 1.03,\n      z: 0.97,\n      duration: 0.06,\n      yoyo: true,\n      repeat: 1,\n      ease: 'power2.out'\n    });\n    timeline.to(cube.scale, {\n      x: 1,\n      y: 1,\n      z: 1,\n      duration: 0.05,\n      ease: 'power2.out'\n    });\n  };\n  useImperativeHandle(ref, () => ({\n    roll: () => rollInternal(),\n    rollTo: face => rollInternal(Math.max(1, Math.min(6, face)))\n  }), [duration, onRoll]);\n\n  // click to roll\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const handler = () => rollInternal();\n    canvas.addEventListener('click', handler);\n    return () => canvas.removeEventListener('click', handler);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    width: size,\n    height: size,\n    className: className,\n    style: {\n      cursor: 'pointer'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 222,\n    columnNumber: 12\n  }, this);\n}, \"ly5rQgKhkC6yoCpgKv0PQVA/swM=\")), \"ly5rQgKhkC6yoCpgKv0PQVA/swM=\");\n_c2 = Dice3D;\nexport default Dice3D;\nvar _c, _c2;\n$RefreshReg$(_c, \"Dice3D$forwardRef\");\n$RefreshReg$(_c2, \"Dice3D\");","map":{"version":3,"names":["React","useEffect","useRef","useImperativeHandle","forwardRef","THREE","gsap","jsxDEV","_jsxDEV","Dice3D","_s","_c","size","duration","onRoll","className","ref","canvasRef","sceneRef","cubeRef","rendererRef","cameraRef","animIdRef","createFaceTexture","face","cvs","document","createElement","width","height","ctx","getContext","fillStyle","fillRect","dot","x","y","beginPath","arc","Math","PI","fill","g","centers","forEach","tex","CanvasTexture","needsUpdate","canvas","current","scene","Scene","background","Color","camera","PerspectiveCamera","position","z","renderer","WebGLRenderer","antialias","alpha","setSize","shadowMap","enabled","type","PCFSoftShadowMap","ambient","AmbientLight","add","dir","DirectionalLight","set","castShadow","shadow","mapSize","left","right","top","bottom","planeGeo","PlaneGeometry","planeMat","ShadowMaterial","opacity","plane","Mesh","rotation","receiveShadow","materials","map","f","MeshStandardMaterial","metalness","roughness","geometry","BoxGeometry","cube","animate","requestAnimationFrame","render","cancelAnimationFrame","dispose","rollInternal","targetFace","floor","random","orientations","tx","ty","tz","start","end","timeline","onComplete","canvasEl","style","willChange","startX","window","innerWidth","startY","innerHeight","midX","midY","endX","endY","to","ease","totalSpins","rotEnd","rotStart","progress","t","onUpdate","k","spinFactor","pow","currentX","currentY","currentZ","scale","yoyo","repeat","roll","rollTo","max","min","handler","addEventListener","removeEventListener","cursor","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/components/Dice3D.tsx"],"sourcesContent":["import React, { useEffect, useRef, useImperativeHandle, forwardRef } from 'react';\nimport * as THREE from 'three';\nimport { gsap } from 'gsap';\n\nexport interface Dice3DProps {\n  /** pixel size of canvas */\n  size?: number;\n  /** roll animation duration in ms */\n  duration?: number;\n  /** callback when roll ends */\n  onRoll?: (face: number) => void;\n  className?: string;\n}\n\nexport interface Dice3DHandle {\n  roll: () => void;\n  rollTo: (face: number) => void;\n}\n\n/**\n * Dice3D – simple WebGL dice rendered with three.js\n * Usage:\n *   const diceRef = useRef<Dice3DHandle>(null);\n *   <Dice3D ref={diceRef} onRoll={(f)=>console.log(f)}/>\n *   diceRef.current?.roll();\n */\nconst Dice3D = forwardRef<Dice3DHandle, Dice3DProps>(\n  ({ size = 180, duration = 1200, onRoll, className }: Dice3DProps, ref) => {\n    const canvasRef = useRef<HTMLCanvasElement | null>(null);\n    const sceneRef = useRef<THREE.Scene>();\n    const cubeRef = useRef<THREE.Mesh>();\n    const rendererRef = useRef<THREE.WebGLRenderer>();\n    const cameraRef = useRef<THREE.PerspectiveCamera>();\n    const animIdRef = useRef(0);\n\n    /** helper to create a texture with pips */\n    const createFaceTexture = (face: number): THREE.Texture => {\n      const size = 128;\n      const cvs = document.createElement('canvas');\n      cvs.width = cvs.height = size;\n      const ctx = cvs.getContext('2d')!;\n      ctx.fillStyle = '#fff';\n      ctx.fillRect(0, 0, size, size);\n      ctx.fillStyle = '#111';\n\n      const dot = (x: number, y: number) => {\n        ctx.beginPath();\n        ctx.arc(x, y, size * 0.1, 0, Math.PI * 2);\n        ctx.fill();\n      };\n      const g = size * 0.25;\n      const centers: Record<number, Array<[number, number]>> = {\n        1: [[size / 2, size / 2]],\n        2: [[g, g], [size - g, size - g]],\n        3: [[g, g], [size / 2, size / 2], [size - g, size - g]],\n        4: [[g, g], [size - g, g], [g, size - g], [size - g, size - g]],\n        5: [[g, g], [size - g, g], [size / 2, size / 2], [g, size - g], [size - g, size - g]],\n        6: [[g, g], [size - g, g], [g, size / 2], [size - g, size / 2], [g, size - g], [size - g, size - g]],\n      };\n      centers[face].forEach(([x, y]) => dot(x, y));\n      const tex = new THREE.CanvasTexture(cvs);\n      tex.needsUpdate = true;\n      return tex;\n    };\n\n    // initialize three scene\n    useEffect(() => {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n      const scene = new THREE.Scene();\n      scene.background = new THREE.Color(0x000000);\n      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);\n      camera.position.z = 4;\n      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });\n      renderer.setSize(size, size);\n      renderer.shadowMap.enabled = true;\n      renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n      // lights\n      const ambient = new THREE.AmbientLight(0xffffff, 0.6);\n      scene.add(ambient);\n      const dir = new THREE.DirectionalLight(0xffffff, 1.0);\n      dir.position.set(5, 10, 7);\n      dir.castShadow = true;\n      dir.shadow.mapSize.width = 1024;\n      dir.shadow.mapSize.height = 1024;\n      dir.shadow.camera.left = -5;\n      dir.shadow.camera.right = 5;\n      dir.shadow.camera.top = 5;\n      dir.shadow.camera.bottom = -5;\n      scene.add(dir);\n\n      // ground plane to receive shadow\n      const planeGeo = new THREE.PlaneGeometry(10, 10);\n      const planeMat = new THREE.ShadowMaterial({ opacity: 0.35 });\n      const plane = new THREE.Mesh(planeGeo, planeMat);\n      plane.rotation.x = -Math.PI / 2;\n      plane.position.y = -1.1;\n      plane.receiveShadow = true;\n      scene.add(plane);\n\n      // cube\n      const materials = [1, 2, 3, 4, 5, 6].map(f => new THREE.MeshStandardMaterial({ map: createFaceTexture(f), metalness: 0.1, roughness: 0.6 }));\n      const geometry = new THREE.BoxGeometry(2, 2, 2);\n      const cube = new THREE.Mesh(geometry, materials);\n      cube.castShadow = true;\n      cube.receiveShadow = false;\n      scene.add(cube);\n\n      sceneRef.current = scene;\n      cubeRef.current = cube;\n      rendererRef.current = renderer;\n      cameraRef.current = camera;\n\n      // animation loop\n      const animate = () => {\n        animIdRef.current = requestAnimationFrame(animate);\n        // subtle idle rotate\n        if (cube) {\n          cube.rotation.x *= 0.995;\n          cube.rotation.y *= 0.995;\n        }\n        renderer.render(scene, camera);\n      };\n      animate();\n\n      return () => {\n        cancelAnimationFrame(animIdRef.current);\n        renderer.dispose();\n      };\n    }, [size]);\n\n    // roll logic (includes DOM motion)\n    const rollInternal = (targetFace?: number) => {\n      if (!cubeRef.current) return;\n      const cube = cubeRef.current;\n      // pick target if not provided\n      const face = targetFace ?? (1 + Math.floor(Math.random() * 6));\n\n      // orientation map: face -> Euler rotation (approx)\n      const orientations: Record<number, [number, number, number]> = {\n        1: [0, 0, 0],\n        2: [0, Math.PI / 2, 0],\n        3: [-Math.PI / 2, 0, 0],\n        4: [Math.PI / 2, 0, 0],\n        5: [0, -Math.PI / 2, 0],\n        6: [Math.PI, 0, 0],\n      };\n      const [tx, ty, tz] = orientations[face];\n\n      const start = { x: cube.rotation.x, y: cube.rotation.y, z: cube.rotation.z };\n      const end = { x: tx + 2 * Math.PI, y: ty + 2 * Math.PI, z: tz + 2 * Math.PI };\n\n      // Use GSAP timeline for smooth rotation + bounces and DOM motion\n      const timeline = gsap.timeline({ onComplete: () => {\n        cube.rotation.set(tx, ty, tz);\n        if (onRoll) onRoll(face);\n      }});\n\n      // random screen path\n      const canvasEl = canvasRef.current as HTMLCanvasElement | null;\n      if (canvasEl && canvasEl.style) {\n        canvasEl.style.position = 'fixed';\n        canvasEl.style.left = '0px';\n        canvasEl.style.top = '0px';\n        canvasEl.style.willChange = 'transform';\n        // pick random path points\n        const startX = Math.random() * (window.innerWidth - size);\n        const startY = Math.random() * (window.innerHeight - size);\n        const midX = Math.random() * (window.innerWidth - size);\n        const midY = Math.random() * (window.innerHeight - size);\n        const endX = Math.random() * (window.innerWidth - size);\n        const endY = Math.random() * (window.innerHeight - size);\n\n        timeline.to({}, { duration: 0.01 }); // tiny offset\n        timeline.to(canvasEl, { duration: duration / 1000, x: endX, y: endY, ease: 'power2.inOut' }, 0);\n      }\n\n      // rotation: spin multiple revolutions then ease to final orientation\n      // we'll use a GSAP ticker to update cube.rotation\n      const totalSpins = 3 + Math.floor(Math.random() * 4);\n      const rotEnd = { x: end.x, y: end.y, z: end.z };\n      const rotStart = { x: start.x, y: start.y, z: start.z };\n\n      // animate rotation using timeline with an onUpdate that writes to cube\n      let progress = { t: 0 };\n      timeline.to(progress, {\n        t: 1,\n        duration: duration / 1000,\n        ease: 'power3.out',\n        onUpdate: () => {\n          const k = progress.t;\n          // combine ease with extra spins\n          const spinFactor = 1 - Math.pow(1 - k, 3);\n          const currentX = rotStart.x + (rotEnd.x - rotStart.x) * k + totalSpins * Math.PI * 2 * (1 - (1 - k));\n          const currentY = rotStart.y + (rotEnd.y - rotStart.y) * k + totalSpins * Math.PI * 2 * (1 - (1 - k));\n          const currentZ = rotStart.z + (rotEnd.z - rotStart.z) * k + totalSpins * Math.PI * 2 * (1 - (1 - k));\n          cube.rotation.set(currentX, currentY, currentZ);\n        }\n      });\n\n      // small bounce sequence on completion (scale + tilt)\n      timeline.to(cube.scale, { x: 1.06, y: 0.94, z: 0.94, duration: 0.08, yoyo: true, repeat: 1, ease: 'power2.out' }, '>-0.1');\n      timeline.to(cube.scale, { x: 0.97, y: 1.03, z: 0.97, duration: 0.06, yoyo: true, repeat: 1, ease: 'power2.out' });\n      timeline.to(cube.scale, { x: 1, y: 1, z: 1, duration: 0.05, ease: 'power2.out' });\n    };\n\n    useImperativeHandle(ref, () => ({\n      roll: () => rollInternal(),\n      rollTo: (face: number) => rollInternal(Math.max(1, Math.min(6, face))),\n    }), [duration, onRoll]);\n\n    // click to roll\n    useEffect(() => {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n      const handler = () => rollInternal();\n      canvas.addEventListener('click', handler);\n      return () => canvas.removeEventListener('click', handler);\n    }, []);\n\n    return <canvas ref={canvasRef} width={size} height={size} className={className} style={{ cursor: 'pointer' }} />;\n  });\n\nexport default Dice3D;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}