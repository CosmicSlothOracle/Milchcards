{"ast":null,"code":"import _objectSpread from\"C:/Users/skank/Videos/Cards/Milchcards/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{useCallback}from'react';import{ActiveAbilitiesManager,EffectQueueManager}from'../utils/gameUtils';export function useGameEffects(gameState,setGameState,log){const executeCardEffect=useCallback((card,player,state,log)=>{let newState=_objectSpread({},state);if(card.kind==='spec'){const specCard=card;// Karten-Nachzieh-Effekte\nif(specCard.name==='Oprah Winfrey'){log(\"Oprah Winfrey: Ziehe 1 Karte\");// Draw card logic would go here\n}// Additional card effects would be implemented here\n}return newState;},[]);const processEffectQueue=useCallback(state=>{if(!state.effectQueue||state.effectQueue.items.length===0){return state;}const[newQueue,newState]=EffectQueueManager.processQueue(state.effectQueue,state,log);return _objectSpread(_objectSpread({},newState),{},{effectQueue:newQueue});},[log]);const getActiveAbilities=useCallback(player=>{return ActiveAbilitiesManager.getAvailableAbilities(player,gameState);},[gameState]);const useActiveAbility=useCallback((abilityId,targetCardUid)=>{setGameState(prev=>{const player=prev.current;const abilities=ActiveAbilitiesManager.getAvailableAbilities(player,prev);const ability=abilities.find(a=>a.id===abilityId);if(!ability||!ActiveAbilitiesManager.canUseAbility(ability,player,prev)){return prev;}// Active ability execution logic would go here\nlog(\"Aktive F\\xE4higkeit verwendet: \".concat(ability.name));return prev;});},[gameState,log]);const transferInfluence=useCallback((player,fromCardUid,toCardUid,amount)=>{setGameState(prev=>{var _prev$effectFlags;if(prev.current!==player)return prev;const flags=(_prev$effectFlags=prev.effectFlags)===null||_prev$effectFlags===void 0?void 0:_prev$effectFlags[player];if(!flags||flags.diplomatInfluenceTransferUsed||flags.influenceTransferBlocked)return prev;// Influence transfer logic would go here\nlog(\"Einfluss transferiert: \".concat(amount,\" Punkte\"));return prev;});},[log]);return{executeCardEffect,processEffectQueue,getActiveAbilities,useActiveAbility,transferInfluence};}","map":{"version":3,"names":["useCallback","ActiveAbilitiesManager","EffectQueueManager","useGameEffects","gameState","setGameState","log","executeCardEffect","card","player","state","newState","_objectSpread","kind","specCard","name","processEffectQueue","effectQueue","items","length","newQueue","processQueue","getActiveAbilities","getAvailableAbilities","useActiveAbility","abilityId","targetCardUid","prev","current","abilities","ability","find","a","id","canUseAbility","concat","transferInfluence","fromCardUid","toCardUid","amount","_prev$effectFlags","flags","effectFlags","diplomatInfluenceTransferUsed","influenceTransferBlocked"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/hooks/useGameEffects.ts"],"sourcesContent":["import { useCallback } from 'react';\r\nimport { GameState, Card, Player } from '../types/game';\r\nimport { ActiveAbilitiesManager, EffectQueueManager } from '../utils/gameUtils';\r\n\r\nexport function useGameEffects(\r\n  gameState: GameState,\r\n  setGameState: React.Dispatch<React.SetStateAction<GameState>>,\r\n  log: (msg: string) => void\r\n) {\r\n\r\n  const executeCardEffect = useCallback((\r\n    card: Card,\r\n    player: Player,\r\n    state: GameState,\r\n    log: (msg: string) => void\r\n  ): GameState => {\r\n    let newState = { ...state };\r\n\r\n    if (card.kind === 'spec') {\r\n      const specCard = card as any;\r\n\r\n      // Karten-Nachzieh-Effekte\r\n      if (specCard.name === 'Oprah Winfrey') {\r\n        log(`Oprah Winfrey: Ziehe 1 Karte`);\r\n        // Draw card logic would go here\r\n      }\r\n      // Additional card effects would be implemented here\r\n    }\r\n\r\n    return newState;\r\n  }, []);\r\n\r\n  const processEffectQueue = useCallback((state: GameState): GameState => {\r\n    if (!state.effectQueue || state.effectQueue.items.length === 0) {\r\n      return state;\r\n    }\r\n\r\n    const [newQueue, newState] = EffectQueueManager.processQueue(\r\n      state.effectQueue,\r\n      state,\r\n      log\r\n    );\r\n\r\n    return {\r\n      ...newState,\r\n      effectQueue: newQueue\r\n    };\r\n  }, [log]);\r\n\r\n  const getActiveAbilities = useCallback((player: Player) => {\r\n    return ActiveAbilitiesManager.getAvailableAbilities(player, gameState);\r\n  }, [gameState]);\r\n\r\n  const useActiveAbility = useCallback((abilityId: string, targetCardUid?: number) => {\r\n    setGameState(prev => {\r\n      const player = prev.current;\r\n      const abilities = ActiveAbilitiesManager.getAvailableAbilities(player, prev);\r\n      const ability = abilities.find(a => a.id === abilityId);\r\n\r\n      if (!ability || !ActiveAbilitiesManager.canUseAbility(ability, player, prev)) {\r\n        return prev;\r\n      }\r\n\r\n      // Active ability execution logic would go here\r\n      log(`Aktive FÃ¤higkeit verwendet: ${ability.name}`);\r\n\r\n      return prev;\r\n    });\r\n  }, [gameState, log]);\r\n\r\n  const transferInfluence = useCallback((player: Player, fromCardUid: number, toCardUid: number, amount: number) => {\r\n    setGameState(prev => {\r\n      if (prev.current !== player) return prev;\r\n\r\n      const flags = prev.effectFlags?.[player];\r\n      if (!flags || flags.diplomatInfluenceTransferUsed || flags.influenceTransferBlocked) return prev;\r\n\r\n      // Influence transfer logic would go here\r\n      log(`Einfluss transferiert: ${amount} Punkte`);\r\n\r\n      return prev;\r\n    });\r\n  }, [log]);\r\n\r\n  return {\r\n    executeCardEffect,\r\n    processEffectQueue,\r\n    getActiveAbilities,\r\n    useActiveAbility,\r\n    transferInfluence,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}