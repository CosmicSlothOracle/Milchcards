{"ast":null,"code":"import { triggerCardEffects } from '../effects/cards';\nimport { resolveQueue } from '../utils/queue';\nimport { applyTrapsOnCardPlayed } from '../utils/traps';\nimport { AnimationEngine } from './animationEngine';\nimport { CharacterSystem } from './characterSystem';\n// Pure game engine - no React dependencies\nexport class GameEngine {\n  constructor(initialState) {\n    this.state = void 0;\n    this.animationEngine = void 0;\n    this.characterSystem = void 0;\n    this.state = {\n      ...initialState\n    };\n    this.animationEngine = new AnimationEngine();\n    this.characterSystem = new CharacterSystem();\n  }\n  getState() {\n    return {\n      ...this.state\n    };\n  }\n\n  // Core action: Play a card\n  playCard(player, card, targetLane) {\n    // Validate AP cost\n    if (this.state.actionPoints[player] < 1) {\n      console.warn(`Player ${player} has insufficient AP: ${this.state.actionPoints[player]}`);\n      return false;\n    }\n\n    // Validate card is in hand\n    const handIndex = this.state.hands[player].findIndex(c => c.uid === card.uid);\n    if (handIndex === -1) {\n      console.warn(`Card ${card.name} not found in player ${player}'s hand`);\n      return false;\n    }\n\n    // Remove card from hand\n    const [playedCard] = this.state.hands[player].splice(handIndex, 1);\n\n    // Determine target lane if not specified\n    const lane = targetLane || this.determineCardLane(playedCard);\n\n    // Add card to board\n    this.state.board[player][lane].push(playedCard);\n\n    // Consume AP\n    this.state.actionPoints[player] = Math.max(0, this.state.actionPoints[player] - 1);\n\n    // Trigger card effects\n    triggerCardEffects(this.state, player, playedCard);\n\n    // Check for trap triggers from opponent\n    applyTrapsOnCardPlayed(this.state, player, playedCard, event => {\n      if (!this.state._effectQueue) this.state._effectQueue = [];\n      this.state._effectQueue.push(event);\n    }, msg => {\n      this.state.log.push(msg);\n    });\n\n    // Resolve effect queue with animation support\n    if (this.state._effectQueue && this.state._effectQueue.length > 0) {\n      const events = [...this.state._effectQueue];\n      this.state._effectQueue = [];\n      this.resolveQueueWithAnimation(events);\n    }\n    console.log(`Card played: ${playedCard.name} by player ${player} in ${lane}`);\n    return true;\n  }\n\n  // Determine which lane a card should go to based on its type\n  determineCardLane(card) {\n    switch (card.kind) {\n      case 'spec':\n        // Check if it's a Sofort-Initiative\n        const specialCard = card;\n        if (specialCard.type && specialCard.type.toLowerCase().includes('sofort-initiative')) {\n          return 'sofort';\n        }\n        return 'innen';\n      case 'pol':\n        return 'aussen';\n      default:\n        console.warn(`Unknown card kind: ${card.kind}, defaulting to 'innen'`);\n        return 'innen';\n    }\n  }\n\n  // Start turn - give player 2 AP\n  startTurn(player) {\n    this.state.actionPoints[player] = 2;\n    console.log(`Turn started for player ${player}, AP set to 2`);\n  }\n\n  // Draw cards\n  drawCards(player, amount) {\n    for (let i = 0; i < amount; i++) {\n      const topCard = this.state.decks[player].shift();\n      if (topCard) {\n        this.state.hands[player].push(topCard);\n      } else {\n        console.warn(`No cards left in deck for player ${player}`);\n        break;\n      }\n    }\n  }\n\n  // Get current AP for player\n  getActionPoints(player) {\n    return this.state.actionPoints[player] || 0;\n  }\n\n  // Check if player can play a card\n  canPlayCard(player) {\n    return this.getActionPoints(player) >= 1;\n  }\n\n  // Get player's hand\n  getHand(player) {\n    return [...this.state.hands[player]];\n  }\n\n  // Get player's board state\n  getBoard(player) {\n    return {\n      innen: [...this.state.board[player].innen],\n      aussen: [...this.state.board[player].aussen],\n      sofort: [...this.state.board[player].sofort]\n    };\n  }\n\n  // === ANIMATION SYSTEM INTEGRATION ===\n\n  // Start animation system\n  startAnimationSystem() {\n    this.animationEngine.start();\n  }\n\n  // Stop animation system\n  stopAnimationSystem() {\n    this.animationEngine.stop();\n  }\n\n  // Update animation system (call from game loop)\n  updateAnimationSystem(currentTime) {\n    this.animationEngine.update(currentTime);\n  }\n\n  // Create character for animation\n  createAnimatedCharacter(id, position, facing = 1) {\n    this.animationEngine.createCharacter(id, position, facing);\n    this.characterSystem.createCharacter(id, position, facing);\n  }\n\n  // Play animation on character\n  playCharacterAnimation(characterId, animationName) {\n    return this.animationEngine.playAnimation(characterId, animationName);\n  }\n\n  // Get animation system state\n  getAnimationState() {\n    return this.animationEngine.getState();\n  }\n\n  // Get character system state\n  getCharacterState() {\n    return this.characterSystem.getAllCharacters();\n  }\n\n  // Handle animation events from the effect queue\n  handleAnimationEvent(event) {\n    switch (event.type) {\n      case 'ANIMATION_PLAY':\n        this.playCharacterAnimation(event.characterId, event.animationName);\n        break;\n      case 'PROJECTILE_SPAWN':\n        this.animationEngine.createProjectile(`projectile_${Date.now()}`, event.position, event.velocity, event.characterId);\n        break;\n      case 'EFFECT_SPAWN':\n        this.animationEngine.createEffect(event.effectId, event.position, event.animationName);\n        break;\n      case 'DAMAGE_DEALT':\n        // Handle damage in game logic\n        console.log(`Damage dealt: ${event.amount} to ${event.targetId}`);\n        break;\n    }\n  }\n\n  // Enhanced resolveQueue that handles animation events\n  resolveQueueWithAnimation(events) {\n    for (const event of events) {\n      // Handle animation events\n      if (event.type.startsWith('ANIMATION_') || event.type.startsWith('PROJECTILE_') || event.type.startsWith('EFFECT_') || event.type === 'DAMAGE_DEALT') {\n        this.handleAnimationEvent(event);\n      }\n    }\n\n    // Process remaining events with existing resolver\n    const nonAnimationEvents = events.filter(event => !event.type.startsWith('ANIMATION_') && !event.type.startsWith('PROJECTILE_') && !event.type.startsWith('EFFECT_') && event.type !== 'DAMAGE_DEALT');\n    if (nonAnimationEvents.length > 0) {\n      resolveQueue(this.state, nonAnimationEvents);\n    }\n  }\n}","map":{"version":3,"names":["triggerCardEffects","resolveQueue","applyTrapsOnCardPlayed","AnimationEngine","CharacterSystem","GameEngine","constructor","initialState","state","animationEngine","characterSystem","getState","playCard","player","card","targetLane","actionPoints","console","warn","handIndex","hands","findIndex","c","uid","name","playedCard","splice","lane","determineCardLane","board","push","Math","max","event","_effectQueue","msg","log","length","events","resolveQueueWithAnimation","kind","specialCard","type","toLowerCase","includes","startTurn","drawCards","amount","i","topCard","decks","shift","getActionPoints","canPlayCard","getHand","getBoard","innen","aussen","sofort","startAnimationSystem","start","stopAnimationSystem","stop","updateAnimationSystem","currentTime","update","createAnimatedCharacter","id","position","facing","createCharacter","playCharacterAnimation","characterId","animationName","playAnimation","getAnimationState","getCharacterState","getAllCharacters","handleAnimationEvent","createProjectile","Date","now","velocity","createEffect","effectId","targetId","startsWith","nonAnimationEvents","filter"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/engine/gameEngine.ts"],"sourcesContent":["import { GameState, Player, Card } from '../types/game';\nimport { triggerCardEffects } from '../effects/cards';\nimport { resolveQueue } from '../utils/queue';\nimport { applyTrapsOnCardPlayed } from '../utils/traps';\nimport { AnimationEngine } from './animationEngine';\nimport { CharacterSystem } from './characterSystem';\nimport type { EffectEvent } from '../types/effects';\n\n// Pure game engine - no React dependencies\nexport class GameEngine {\n  private state: GameState;\n  private animationEngine: AnimationEngine;\n  private characterSystem: CharacterSystem;\n\n  constructor(initialState: GameState) {\n    this.state = { ...initialState };\n    this.animationEngine = new AnimationEngine();\n    this.characterSystem = new CharacterSystem();\n  }\n\n  getState(): GameState {\n    return { ...this.state };\n  }\n\n  // Core action: Play a card\n  playCard(player: Player, card: Card, targetLane?: 'innen' | 'aussen' | 'sofort'): boolean {\n    // Validate AP cost\n    if (this.state.actionPoints[player] < 1) {\n      console.warn(`Player ${player} has insufficient AP: ${this.state.actionPoints[player]}`);\n      return false;\n    }\n\n    // Validate card is in hand\n    const handIndex = this.state.hands[player].findIndex(c => c.uid === card.uid);\n    if (handIndex === -1) {\n      console.warn(`Card ${card.name} not found in player ${player}'s hand`);\n      return false;\n    }\n\n    // Remove card from hand\n    const [playedCard] = this.state.hands[player].splice(handIndex, 1);\n\n    // Determine target lane if not specified\n    const lane = targetLane || this.determineCardLane(playedCard);\n\n    // Add card to board\n    this.state.board[player][lane].push(playedCard);\n\n    // Consume AP\n    this.state.actionPoints[player] = Math.max(0, this.state.actionPoints[player] - 1);\n\n    // Trigger card effects\n    triggerCardEffects(this.state, player, playedCard);\n\n    // Check for trap triggers from opponent\n    applyTrapsOnCardPlayed(\n      this.state,\n      player,\n      playedCard,\n      (event) => {\n        if (!this.state._effectQueue) this.state._effectQueue = [];\n        this.state._effectQueue.push(event);\n      },\n      (msg) => {\n        this.state.log.push(msg);\n      }\n    );\n\n    // Resolve effect queue with animation support\n    if (this.state._effectQueue && this.state._effectQueue.length > 0) {\n      const events = [...this.state._effectQueue];\n      this.state._effectQueue = [];\n      this.resolveQueueWithAnimation(events);\n    }\n\n    console.log(`Card played: ${playedCard.name} by player ${player} in ${lane}`);\n    return true;\n  }\n\n  // Determine which lane a card should go to based on its type\n  private determineCardLane(card: Card): 'innen' | 'aussen' | 'sofort' {\n    switch (card.kind) {\n      case 'spec':\n        // Check if it's a Sofort-Initiative\n        const specialCard = card as any;\n        if (specialCard.type && specialCard.type.toLowerCase().includes('sofort-initiative')) {\n          return 'sofort';\n        }\n        return 'innen';\n      case 'pol':\n        return 'aussen';\n      default:\n        console.warn(`Unknown card kind: ${card.kind}, defaulting to 'innen'`);\n        return 'innen';\n    }\n  }\n\n  // Start turn - give player 2 AP\n  startTurn(player: Player): void {\n    this.state.actionPoints[player] = 2;\n    console.log(`Turn started for player ${player}, AP set to 2`);\n  }\n\n  // Draw cards\n  drawCards(player: Player, amount: number): void {\n    for (let i = 0; i < amount; i++) {\n      const topCard = this.state.decks[player].shift();\n      if (topCard) {\n        this.state.hands[player].push(topCard);\n      } else {\n        console.warn(`No cards left in deck for player ${player}`);\n        break;\n      }\n    }\n  }\n\n  // Get current AP for player\n  getActionPoints(player: Player): number {\n    return this.state.actionPoints[player] || 0;\n  }\n\n  // Check if player can play a card\n  canPlayCard(player: Player): boolean {\n    return this.getActionPoints(player) >= 1;\n  }\n\n  // Get player's hand\n  getHand(player: Player): Card[] {\n    return [...this.state.hands[player]];\n  }\n\n  // Get player's board state\n  getBoard(player: Player) {\n    return {\n      innen: [...this.state.board[player].innen],\n      aussen: [...this.state.board[player].aussen],\n      sofort: [...this.state.board[player].sofort]\n    };\n  }\n\n  // === ANIMATION SYSTEM INTEGRATION ===\n  \n  // Start animation system\n  startAnimationSystem(): void {\n    this.animationEngine.start();\n  }\n\n  // Stop animation system\n  stopAnimationSystem(): void {\n    this.animationEngine.stop();\n  }\n\n  // Update animation system (call from game loop)\n  updateAnimationSystem(currentTime: number): void {\n    this.animationEngine.update(currentTime);\n  }\n\n  // Create character for animation\n  createAnimatedCharacter(id: string, position: { x: number; y: number }, facing: -1 | 1 = 1): void {\n    this.animationEngine.createCharacter(id, position, facing);\n    this.characterSystem.createCharacter(id, position, facing);\n  }\n\n  // Play animation on character\n  playCharacterAnimation(characterId: string, animationName: string): boolean {\n    return this.animationEngine.playAnimation(characterId, animationName);\n  }\n\n  // Get animation system state\n  getAnimationState() {\n    return this.animationEngine.getState();\n  }\n\n  // Get character system state\n  getCharacterState() {\n    return this.characterSystem.getAllCharacters();\n  }\n\n  // Handle animation events from the effect queue\n  private handleAnimationEvent(event: EffectEvent): void {\n    switch (event.type) {\n      case 'ANIMATION_PLAY':\n        this.playCharacterAnimation(event.characterId, event.animationName);\n        break;\n      case 'PROJECTILE_SPAWN':\n        this.animationEngine.createProjectile(\n          `projectile_${Date.now()}`,\n          event.position,\n          event.velocity,\n          event.characterId\n        );\n        break;\n      case 'EFFECT_SPAWN':\n        this.animationEngine.createEffect(\n          event.effectId,\n          event.position,\n          event.animationName\n        );\n        break;\n      case 'DAMAGE_DEALT':\n        // Handle damage in game logic\n        console.log(`Damage dealt: ${event.amount} to ${event.targetId}`);\n        break;\n    }\n  }\n\n  // Enhanced resolveQueue that handles animation events\n  private resolveQueueWithAnimation(events: EffectEvent[]): void {\n    for (const event of events) {\n      // Handle animation events\n      if (event.type.startsWith('ANIMATION_') || \n          event.type.startsWith('PROJECTILE_') || \n          event.type.startsWith('EFFECT_') || \n          event.type === 'DAMAGE_DEALT') {\n        this.handleAnimationEvent(event);\n      }\n    }\n    \n    // Process remaining events with existing resolver\n    const nonAnimationEvents = events.filter(event => \n      !event.type.startsWith('ANIMATION_') && \n      !event.type.startsWith('PROJECTILE_') && \n      !event.type.startsWith('EFFECT_') && \n      event.type !== 'DAMAGE_DEALT'\n    );\n    \n    if (nonAnimationEvents.length > 0) {\n      resolveQueue(this.state, nonAnimationEvents);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}