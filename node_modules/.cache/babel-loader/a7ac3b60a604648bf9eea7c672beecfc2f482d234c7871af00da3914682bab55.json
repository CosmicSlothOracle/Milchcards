{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\skank\\\\Videos\\\\Cards\\\\Milchcards\\\\src\\\\components\\\\GameCanvas.tsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback } from 'react';\nimport { LAYOUT, getZone, computeSlotRects, getUiTransform, getLaneCapacity, getPublicRects, getGovernmentRects } from '../ui/layout';\nimport { sortHandCards } from '../utils/gameUtils';\nimport { getCardImagePath } from '../data/gameData';\nimport influenceIconUrl from '../assets/icons/influence.svg';\nimport publicSymbolUrl from '../assets/icons/public_symbol.png';\nimport sofortSymbolUrl from '../assets/icons/sofort_initiative_symbol.png';\nimport dauerhaftSymbolUrl from '../assets/icons/dauerhaft_initative.png';\nimport governmentSymbolUrl from '../assets/icons/government_symbol.png';\nimport interventionSymbolUrl from '../assets/icons/intervention_symbol.png';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const GameCanvas = ({\n  gameState,\n  selectedHandIndex,\n  onCardClick,\n  onCardHover,\n  devMode = false\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const clickZonesRef = useRef([]);\n  // Smooth vertical scroll for P1 hand when it has more than visible slots\n  const handScrollTargetRef = useRef(0);\n  const handScrollCurrentRef = useRef(0);\n  const handScrollEnabledRef = useRef(true);\n  // Touch handling refs\n  const touchStartYRef = useRef(null);\n  const lastTouchYRef = useRef(null);\n  const isTouchingRef = useRef(false);\n  const backgroundImageRef = useRef(null);\n  const imageCacheRef = useRef(new Map());\n  const influenceImgRef = useRef(null);\n  // Animation state for visual influence changes: Map<uid, Array<Anim>>\n  const influenceAnimRef = useRef(new Map());\n  // Previous per-card influence snapshot to detect increases\n  const prevInfluencesRef = useRef({});\n  // Slot symbol images\n  const slotSymbolImgsRef = useRef(new Map());\n\n  // Helper: draw slot icons with uniform pulsing opacity and a light reflection\n  const drawSlotIconWithPulse = useCallback((ctx, img, x, y, w, h, phase = 0) => {\n    if (!img || !img.complete) return;\n    try {\n      const now = performance.now();\n      const base = 0.10; // base opacity\n      const pulseRange = 0.08; // pulse amplitude (-> up to base + pulseRange)\n      const period = 700; // ms\n      const pulse = base + pulseRange * (0.5 + 0.5 * Math.sin(now / period + phase));\n\n      // draw icon with pulsing alpha\n      ctx.save();\n      ctx.globalAlpha = pulse;\n      ctx.drawImage(img, x, y, w, h);\n\n      // subtle reflection: gradient overlay on top half\n      const grad = ctx.createLinearGradient(x, y, x, y + h * 0.5);\n      grad.addColorStop(0, `rgba(255,255,255,${0.18 * pulse})`);\n      grad.addColorStop(1, `rgba(255,255,255,0)`);\n      ctx.globalCompositeOperation = 'lighter';\n      ctx.fillStyle = grad;\n      ctx.fillRect(x, y, w, h * 0.5);\n      ctx.restore();\n    } catch (e) {\n      // silent fallback\n    }\n  }, []);\n\n  // Load influence icon once\n  useEffect(() => {\n    const img = new Image();\n    img.src = influenceIconUrl;\n    influenceImgRef.current = img;\n  }, []);\n  const drawCardAt = useCallback((ctx, card, x, y, size, selected = false, showAPCost = false, player) => {\n    var _shield;\n    let dx = x,\n      dy = y,\n      s = size;\n    if (selected) {\n      s = Math.floor(size * 1.05);\n      dx = x - Math.floor((s - size) / 2);\n      dy = y - Math.floor((s - size) / 2);\n    }\n\n    // Note: pulse overlay is drawn at top layer after all cards are rendered\n\n    // Draw card image with caching to prevent flicker in continuous loop\n    const src = getCardImagePath(card, 'ui');\n    const cached = imageCacheRef.current.get(src);\n    if (cached && cached.complete) {\n      ctx.drawImage(cached, dx, dy, s, s);\n    } else {\n      const img = new Image();\n      img.onload = () => {\n        imageCacheRef.current.set(src, img);\n        ctx.drawImage(img, dx, dy, s, s);\n      };\n      img.src = src;\n      imageCacheRef.current.set(src, img);\n    }\n\n    // Status-Indikatoren (fÃ¼r alle Board-Karten)\n    // Einfluss-Wert dauerhaft anzeigen (oben links) â€“ nur fÃ¼r Regierungskarten\n    if (card.kind === 'pol') {\n      var _influence;\n      const barH = Math.max(20, Math.floor(s * 0.12) + 6);\n      ctx.fillStyle = 'rgba(0,0,0,0.6)';\n      ctx.fillRect(dx, dy + s - barH, s, barH);\n      ctx.fillStyle = '#ffffff';\n      const fontSize = Math.floor(s * 0.12);\n      ctx.font = `bold ${fontSize}px sans-serif`;\n      ctx.textAlign = 'left';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(`${(_influence = card.influence) !== null && _influence !== void 0 ? _influence : 0}`, dx + 8, dy + s - barH / 2);\n    }\n    // Schutz-Status (blauer Punkt)\n    if (card.protected || ((_shield = card.shield) !== null && _shield !== void 0 ? _shield : 0) > 0) {\n      ctx.fillStyle = '#1da1f2';\n      ctx.fillRect(dx + s - 22, dy + 6, 16, 16);\n    }\n    // Deaktiviert-Status (roter Punkt)\n    if (card.deactivated) {\n      ctx.fillStyle = '#b63838';\n      ctx.fillRect(dx + s - 22, dy + 26, 16, 16);\n    }\n\n    // Einfluss-Badge fÃ¼r Handkarten oben rechts (nur Regierungskarten)\n    if (showAPCost && player && card.kind === 'pol') {\n      var _influence2;\n      const badgeHeight = Math.max(16, Math.floor(s * 0.12));\n      const badgeWidth = badgeHeight * 2;\n      const badgeX = dx + s - badgeWidth - 6;\n      const badgeY = dy + 6;\n\n      // Semi-transparent dunkler Hintergrund\n      ctx.fillStyle = 'rgba(0,0,0,0.6)';\n      ctx.beginPath();\n      ctx.roundRect(badgeX, badgeY, badgeWidth, badgeHeight, badgeHeight / 2);\n      ctx.fill();\n\n      // Influence icon (90% opacity) links im Badge\n      if (influenceImgRef.current && influenceImgRef.current.complete) {\n        ctx.globalAlpha = 0.9;\n        ctx.drawImage(influenceImgRef.current, badgeX + 2, badgeY + 2, badgeHeight - 4, badgeHeight - 4);\n        ctx.globalAlpha = 1;\n      }\n\n      // Influence number rechts im Badge\n      ctx.fillStyle = '#ffffff';\n      ctx.font = `bold ${Math.floor(badgeHeight * 0.5)}px sans-serif`;\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(`${(_influence2 = card.influence) !== null && _influence2 !== void 0 ? _influence2 : 0}`, badgeX + badgeWidth - 4, badgeY + badgeHeight / 2);\n\n      // Reset align\n      ctx.textAlign = 'start';\n      ctx.textBaseline = 'alphabetic';\n    }\n\n    // NOTE: influence overlays (pulse + labels) are drawn in a separate pass\n\n    // Auswahl-Rahmen\n    if (selected) {\n      ctx.strokeStyle = '#61dafb';\n      ctx.lineWidth = 3;\n      ctx.strokeRect(dx + 1, dy + 1, s - 2, s - 2);\n      ctx.lineWidth = 1;\n    }\n\n    // Return exact 256x256 click zone over the card\n    // Since all cards are 256x256, the click zone should match exactly\n    return {\n      x: dx,\n      y: dy,\n      w: 256,\n      h: 256\n    };\n  }, [gameState]);\n\n  // Slot-Benennungs-Funktion basierend auf Glossar\n  const getSlotDisplayName = useCallback((zoneId, index, player) => {\n    const slotNumber = index + 1;\n    if (zoneId.includes('government')) {\n      if (zoneId.includes('player')) {\n        return `Regierungsreihe Slot ${slotNumber}`;\n      } else {\n        return `Gegner Regierung Slot ${slotNumber}`;\n      }\n    } else if (zoneId.includes('public')) {\n      if (zoneId.includes('player')) {\n        return `Ã–ffentlichkeitsreihe Slot ${slotNumber}`;\n      } else {\n        return `Gegner Ã–ffentlichkeit Slot ${slotNumber}`;\n      }\n    } else if (zoneId.includes('permanent.government')) {\n      if (zoneId.includes('player')) {\n        return 'Regierung Spezial-Slot';\n      } else {\n        return 'Gegner Regierung Spezial-Slot';\n      }\n    } else if (zoneId.includes('permanent.public')) {\n      if (zoneId.includes('player')) {\n        return 'Ã–ffentlichkeit Spezial-Slot';\n      } else {\n        return 'Gegner Ã–ffentlichkeit Spezial-Slot';\n      }\n    } else if (zoneId.includes('instant')) {\n      if (zoneId.includes('player')) {\n        return 'Sofort-Slot';\n      } else {\n        return 'Gegner Sofort-Slot';\n      }\n    } else if (zoneId.includes('hand')) {\n      return 'Hand';\n    } else if (zoneId.includes('interventions')) {\n      return 'Interventionen';\n    }\n    return `Slot ${slotNumber}`;\n  }, []);\n  const drawLane = useCallback((ctx, zoneId, player, lane, clickable) => {\n    const zone = getZone(zoneId);\n    if (!zone) return;\n    const slots = computeSlotRects(zone);\n    const arr = gameState.board[player][lane];\n    slots.forEach((s, idx) => {\n      const card = arr[idx];\n\n      // Hintergrundfarbe nach Kategorie\n      let bgColor = 'rgba(0,0,0,0.1)'; // Standard\n      if (zoneId.includes('government')) {\n        bgColor = 'rgba(255, 197, 0, 0.15)'; // Hellgelb fÃ¼r Regierung\n      } else if (zoneId.includes('public')) {\n        bgColor = 'rgba(0, 255, 0, 0.15)'; // HellgrÃ¼n fÃ¼r Ã–ffentlichkeit\n      }\n      ctx.fillStyle = bgColor;\n      ctx.fillRect(s.x, s.y, s.w, s.h);\n\n      // Slot-Rahmen\n      ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n      ctx.strokeRect(s.x + 0.5, s.y + 0.5, s.w - 1, s.h - 1);\n      if (card) {\n        const isSelected = player === 1 && selectedHandIndex !== null && gameState.hands[1][selectedHandIndex] === card;\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, isSelected, false);\n\n        // Kartenname unter dem Slot anzeigen\n        ctx.fillStyle = 'rgba(255,255,255,0.9)';\n        ctx.font = 'bold 12px sans-serif';\n        ctx.textAlign = 'center';\n        const textY = s.y + s.h + 16;\n        ctx.fillText(card.name, s.x + s.w / 2, textY);\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: {\n            type: 'board_card',\n            player,\n            lane,\n            index: idx,\n            card\n          }\n        });\n      } else if (clickable && gameState.current === player) {\n        // Slot-Benennung anzeigen (fÃ¼r den aktuellen Spieler)\n        const slotName = getSlotDisplayName(zoneId, idx, player);\n        ctx.fillStyle = 'rgba(255,255,255,0.6)';\n        ctx.font = '11px sans-serif';\n        ctx.textAlign = 'center';\n        const textY = s.y + s.h / 2;\n        ctx.fillText(slotName, s.x + s.w / 2, textY);\n        clickZonesRef.current.push({\n          x: s.x,\n          y: s.y,\n          w: s.w,\n          h: s.h,\n          data: {\n            type: 'row_slot',\n            lane,\n            index: idx\n          }\n        });\n      }\n    });\n  }, [gameState, selectedHandIndex, drawCardAt, getSlotDisplayName]);\n  const drawHandP1 = useCallback(ctx => {\n    const hand = sortHandCards(gameState.hands[1]);\n    const zone = getZone('hand.player');\n    if (!zone) return;\n    const slots = computeSlotRects(zone);\n    // Apply smooth offset (lerp towards target)\n    const target = handScrollTargetRef.current;\n    handScrollCurrentRef.current += (target - handScrollCurrentRef.current) * 0.15; // easing\n    const offsetY = Math.round(handScrollCurrentRef.current);\n    slots.forEach((s, i) => {\n      const card = hand[i];\n      if (!card) return;\n      // Find original index in unsorted hand for click handling\n      const originalIndex = gameState.hands[1].findIndex(c => c.uid === card.uid);\n      const isSel = selectedHandIndex === originalIndex;\n      // apply vertical offset\n      const sx = s.x;\n      const sy = s.y + offsetY;\n      const clickZone = drawCardAt(ctx, card, sx, sy, s.w, isSel, true, 1); // Show AP cost for player 1 hand\n      clickZonesRef.current.push({\n        ...clickZone,\n        data: {\n          type: 'hand_p1',\n          index: originalIndex,\n          card\n        }\n      });\n    });\n  }, [gameState.hands, selectedHandIndex, drawCardAt]);\n\n  // ðŸ”§ DEV MODE: Player 2 Hand (rechts unten, kompakter)\n  const drawHandP2 = useCallback(ctx => {\n    const hand = sortHandCards(gameState.hands[2]);\n    const zone = getZone('hand.opponent');\n    if (!zone) return;\n    const slots = computeSlotRects(zone);\n\n    // Hintergrund fÃ¼r P2 Hand\n    const [x, y, w, h] = zone.rectPx;\n    ctx.fillStyle = 'rgba(255, 100, 100, 0.15)'; // RÃ¶tlicher Hintergrund fÃ¼r P2\n    ctx.fillRect(x, y, w, h);\n    ctx.strokeStyle = 'rgba(255, 100, 100, 0.3)';\n    ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);\n\n    // Label fÃ¼r P2 Hand\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n    ctx.font = 'bold 14px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Player 2 Hand', x + w / 2, y - 8);\n    slots.forEach((s, i) => {\n      const card = hand[i];\n      if (!card) return;\n      // Find original index in unsorted hand for click handling\n      const originalIndex = gameState.hands[2].findIndex(c => c.uid === card.uid);\n      const isSel = gameState.current === 2 && selectedHandIndex === originalIndex;\n      const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, isSel, true, 2); // Show AP cost for player 2 hand\n      clickZonesRef.current.push({\n        ...clickZone,\n        data: {\n          type: 'hand_p2',\n          index: originalIndex,\n          card\n        }\n      });\n    });\n  }, [gameState, selectedHandIndex, drawCardAt]);\n  // Interventions strip (player traps)\n  const drawInterventionsP1 = useCallback(ctx => {\n    const traps = gameState.traps[1] || [];\n    const zone = getZone('interventions.player');\n    if (!zone) return;\n\n    // Single intervention slot\n    const [zx, zy, zw, zh] = zone.rectPx;\n    const card = traps[0]; // Only first trap\n\n    // Hintergrund fÃ¼r Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.15)'; // Lavendelfarben fÃ¼r Interventionen\n    ctx.fillRect(zx, zy, zw, zh);\n    ctx.strokeStyle = 'rgba(200, 160, 255, 0.3)';\n    ctx.strokeRect(zx + 0.5, zy + 0.5, zw - 1, zh - 1);\n\n    // Slot-Benennung fÃ¼r Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.8)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Intervention', zx + 8, zy + zh - 6);\n    if (card) {\n      const clickZone = drawCardAt(ctx, card, zx, zy, zw, false, false);\n      clickZonesRef.current.push({\n        ...clickZone,\n        data: {\n          type: 'trap_p1',\n          index: 0,\n          card\n        }\n      });\n    }\n  }, [gameState.traps, drawCardAt]);\n\n  // Interventions strip (opponent traps)\n  const drawInterventionsP2 = useCallback(ctx => {\n    const traps = gameState.traps[2] || [];\n    const zone = getZone('interventions.opponent');\n    if (!zone) return;\n\n    // Single intervention slot\n    const [zx, zy, zw, zh] = zone.rectPx;\n    const card = traps[0]; // Only first trap\n\n    // Hintergrund fÃ¼r Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.15)'; // Lavendelfarben fÃ¼r Interventionen\n    ctx.fillRect(zx, zy, zw, zh);\n    ctx.strokeStyle = 'rgba(200, 160, 255, 0.3)';\n    ctx.strokeRect(zx + 0.5, zy + 0.5, zw - 1, zh - 1);\n\n    // Slot-Benennung fÃ¼r Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.8)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Intervention', zx + 8, zy + zh - 6);\n    if (card) {\n      const clickZone = drawCardAt(ctx, card, zx, zy, zw, false, false);\n      clickZonesRef.current.push({\n        ...clickZone,\n        data: {\n          type: 'trap_p2',\n          index: 0,\n          card\n        }\n      });\n    }\n  }, [gameState.traps, drawCardAt]);\n\n  // Single slot drawing function\n  const drawSingleSlot = useCallback((ctx, zoneId, card, clickType, player) => {\n    const zone = getZone(zoneId);\n    if (!zone) return;\n    const [x, y, w, h] = zone.rectPx;\n\n    // Hintergrundfarbe nach Kategorie\n    let bgColor = 'rgba(0,0,0,0.1)'; // Standard\n    if (zoneId.includes('government')) {\n      bgColor = 'rgba(255, 197, 0, 0.15)'; // Hellgelb fÃ¼r Regierung\n    } else if (zoneId.includes('public')) {\n      bgColor = 'rgba(0, 255, 0, 0.15)'; // HellgrÃ¼n fÃ¼r Ã–ffentlichkeit\n    } else if (zoneId.includes('instant')) {\n      bgColor = 'rgba(127, 116, 91, 0.15)'; // Neutral fÃ¼r Sofort-Slots\n    } else if (zoneId.includes('permanent')) {\n      // Unterscheide zwischen government und public permanent slots\n      if (zoneId.includes('government')) {\n        bgColor = 'rgba(255, 197, 0, 0.15)';\n      } else if (zoneId.includes('public')) {\n        bgColor = 'rgba(0, 255, 0, 0.15)';\n      }\n    }\n    ctx.fillStyle = bgColor;\n    ctx.fillRect(x, y, w, h);\n\n    // Draw slot border\n    ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n    ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);\n    if (card) {\n      const isSelected = player === 1 && selectedHandIndex !== null && gameState.hands[1][selectedHandIndex] === card;\n      const clickZone = drawCardAt(ctx, card, x, y, w, isSelected, false);\n\n      // Kartenname unter dem Slot anzeigen\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.font = 'bold 12px sans-serif';\n      ctx.textAlign = 'center';\n      const textY = y + h + 16;\n      ctx.fillText(card.name, x + w / 2, textY);\n      clickZonesRef.current.push({\n        ...clickZone,\n        data: {\n          type: 'slot_card',\n          slot: clickType,\n          card\n        }\n      });\n\n      // ðŸ”§ NEU: Sofort-Initiative-Slots sind klickbar fÃ¼r Aktivierung\n      if (clickType === 'instant' && gameState.current === player) {\n        clickZonesRef.current.push({\n          x,\n          y,\n          w,\n          h,\n          data: {\n            type: 'activate_instant',\n            player,\n            card\n          }\n        });\n      }\n    } else if (gameState.current === player) {\n      // Slot-Benennung fÃ¼r leere Slots anzeigen (fÃ¼r den aktuellen Spieler)\n      const slotName = getSlotDisplayName(zoneId, 0, player);\n      ctx.fillStyle = 'rgba(255,255,255,0.6)';\n      ctx.font = '11px sans-serif';\n      ctx.textAlign = 'center';\n      const textY = y + h / 2;\n      ctx.fillText(slotName, x + w / 2, textY);\n      clickZonesRef.current.push({\n        x,\n        y,\n        w,\n        h,\n        data: {\n          type: 'empty_slot',\n          slot: clickType\n        }\n      });\n    }\n  }, [selectedHandIndex, gameState, drawCardAt, getSlotDisplayName]);\n\n  // Draw permanent slots for player\n  const drawPermanentSlotsP1 = useCallback(ctx => {\n    drawSingleSlot(ctx, 'slot.permanent.government.player', gameState.permanentSlots[1].government, 'permanent_government', 1);\n    drawSingleSlot(ctx, 'slot.permanent.public.player', gameState.permanentSlots[1].public, 'permanent_public', 1);\n  }, [gameState.permanentSlots, drawSingleSlot]);\n\n  // Draw permanent slots for opponent\n  const drawPermanentSlotsP2 = useCallback(ctx => {\n    drawSingleSlot(ctx, 'slot.permanent.government.opponent', gameState.permanentSlots[2].government, 'permanent_government', 2);\n    drawSingleSlot(ctx, 'slot.permanent.public.opponent', gameState.permanentSlots[2].public, 'permanent_public', 2);\n  }, [gameState.permanentSlots, drawSingleSlot]);\n\n  // Draw instant slots\n  const drawInstantSlots = useCallback(ctx => {\n    // Sofort-Initiative-Slots aus dem Board zeichnen\n    const sofortPlayerCard = gameState.board[1].sofort[0];\n    const sofortOppCard = gameState.board[2].sofort[0];\n    drawSingleSlot(ctx, 'slot.instant.player', sofortPlayerCard, 'instant', 1);\n    drawSingleSlot(ctx, 'slot.instant.opponent', sofortOppCard, 'instant', 2);\n  }, [gameState.board, drawSingleSlot]);\n\n  // Aktive SchlÃ¼sselwÃ¶rter und Unterkategorien ermitteln\n  const getActiveKeywordsAndSubcategories = useCallback(player => {\n    const board = gameState.board[player];\n    const permanentSlots = gameState.permanentSlots[player];\n    const allCards = [...board.innen, ...board.aussen, permanentSlots.government, permanentSlots.public].filter(c => c && c.kind === 'pol');\n    const keywords = new Set();\n    const subcategories = new Set();\n    allCards.forEach(card => {\n      if (!card.deactivated) {\n        // Regierungskarten-SchlÃ¼sselwÃ¶rter\n        if (card.tag === 'Leadership') {\n          keywords.add('Leadership');\n        }\n        if (card.tag === 'Diplomat') {\n          keywords.add('Diplomat');\n        }\n\n        // Ã–ffentlichkeits-Unterkategorien (fÃ¼r Karten in Ã–ffentlichkeitsreihe)\n        if (board.innen.includes(card)) {\n          const publicCard = card;\n          if (publicCard.tag) {\n            // Oligarch\n            const oligarchNames = ['Elon Musk', 'Bill Gates', 'George Soros', 'Warren Buffett', 'Mukesh Ambani', 'Jeff Bezos', 'Alisher Usmanov', 'Gautam Adani', 'Jack Ma', 'Zhang Yiming', 'Roman Abramovich'];\n            if (oligarchNames.includes(publicCard.name)) {\n              subcategories.add('Oligarch');\n            }\n\n            // Plattform\n            const platformNames = ['Mark Zuckerberg', 'Tim Cook', 'Sam Altman', 'Jack Ma'];\n            if (platformNames.includes(publicCard.name)) {\n              subcategories.add('Plattform');\n            }\n\n            // Bewegung\n            const movementNames = ['Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'];\n            if (movementNames.includes(publicCard.name)) {\n              subcategories.add('Bewegung');\n            }\n\n            // NGO/Think-Tank\n            const ngoNames = ['Bill Gates', 'George Soros', 'Jennifer Doudna', 'Noam Chomsky', 'Anthony Fauci'];\n            if (ngoNames.includes(publicCard.name)) {\n              subcategories.add('NGO/Think-Tank');\n            }\n\n            // Intelligenz\n            const intelligenceNames = ['Jennifer Doudna', 'Noam Chomsky', 'Edward Snowden', 'Julian Assange', 'Yuval Noah Harari', 'Ai Weiwei', 'Alexei Navalny', 'Anthony Fauci'];\n            if (intelligenceNames.includes(publicCard.name)) {\n              subcategories.add('Intelligenz');\n            }\n\n            // Medien\n            const mediaNames = ['Oprah Winfrey'];\n            if (mediaNames.includes(publicCard.name)) {\n              subcategories.add('Medien');\n            }\n          }\n        }\n      }\n    });\n    return {\n      keywords: Array.from(keywords),\n      subcategories: Array.from(subcategories)\n    };\n  }, [gameState]);\n\n  // Info-Panels zeichnen\n  const drawInfoPanels = useCallback(ctx => {\n    const {\n      keywords,\n      subcategories\n    } = getActiveKeywordsAndSubcategories(1);\n\n    // Panel fÃ¼r RegierungsschlÃ¼sselwÃ¶rter (rechts neben Regierungsslots)\n    const govPanelX = 1640 + 256 + 20; // Nach dem letzten permanenten Slot\n    const govPanelY = 300; // Auf HÃ¶he der Regierungsslots\n    const govPanelW = 120;\n    const govPanelH = 256;\n\n    // Regierungspanel Hintergrund\n    ctx.fillStyle = 'rgba(255, 197, 0, 0.15)';\n    ctx.fillRect(govPanelX, govPanelY, govPanelW, govPanelH);\n    ctx.strokeStyle = 'rgba(255, 197, 0, 0.3)';\n    ctx.strokeRect(govPanelX + 0.5, govPanelY + 0.5, govPanelW - 1, govPanelH - 1);\n\n    // Regierungspanel Titel\n    ctx.fillStyle = 'rgba(255, 197, 0, 0.9)';\n    ctx.font = 'bold 12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Regierung', govPanelX + govPanelW / 2, govPanelY + 16);\n\n    // SchlÃ¼sselwÃ¶rter auflisten\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    if (keywords.length > 0) {\n      keywords.forEach((keyword, idx) => {\n        ctx.fillText(`â€¢ ${keyword}`, govPanelX + 8, govPanelY + 36 + idx * 16);\n      });\n    } else {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\n      ctx.fillText('Keine aktiven', govPanelX + 8, govPanelY + 36);\n      ctx.fillText('SchlÃ¼sselwÃ¶rter', govPanelX + 8, govPanelY + 52);\n    }\n\n    // Panel fÃ¼r Ã–ffentlichkeits-Unterkategorien (rechts neben Ã–ffentlichkeitsslots)\n    const pubPanelX = 1640 + 256 + 20;\n    const pubPanelY = 580; // Auf HÃ¶he der Ã–ffentlichkeitsslots\n    const pubPanelW = 120;\n    const pubPanelH = 256;\n\n    // Ã–ffentlichkeitspanel Hintergrund\n    ctx.fillStyle = 'rgba(0, 255, 0, 0.15)';\n    ctx.fillRect(pubPanelX, pubPanelY, pubPanelW, pubPanelH);\n    ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';\n    ctx.strokeRect(pubPanelX + 0.5, pubPanelY + 0.5, pubPanelW - 1, pubPanelH - 1);\n\n    // Ã–ffentlichkeitspanel Titel\n    ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';\n    ctx.font = 'bold 12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Ã–ffentlichkeit', pubPanelX + pubPanelW / 2, pubPanelY + 16);\n\n    // Unterkategorien auflisten\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    if (subcategories.length > 0) {\n      subcategories.forEach((subcategory, idx) => {\n        const displayName = subcategory.length > 12 ? subcategory.substring(0, 10) + '...' : subcategory;\n        ctx.fillText(`â€¢ ${displayName}`, pubPanelX + 8, pubPanelY + 36 + idx * 16);\n      });\n    } else {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\n      ctx.fillText('Keine aktiven', pubPanelX + 8, pubPanelY + 36);\n      ctx.fillText('Unterkategorien', pubPanelX + 8, pubPanelY + 52);\n    }\n  }, [getActiveKeywordsAndSubcategories]);\n\n  // Move diagnostics to draw callback to ensure they run after canvas is actually rendered\n  const runDiagnostics = useCallback(() => {\n    try {\n      const handZones = clickZonesRef.current.filter(z => z.data && z.data.type === 'hand_p1');\n      const uiUIDs = handZones.map(z => {\n        var _z$data$card$uid;\n        return z.data.card && ((_z$data$card$uid = z.data.card.uid) !== null && _z$data$card$uid !== void 0 ? _z$data$card$uid : z.data.card.id);\n      }).filter(Boolean);\n      const stateHand = gameState.hands && gameState.hands[1] ? gameState.hands[1] : [];\n      const stateUIDs = stateHand.map(c => {\n        var _c$uid;\n        return (_c$uid = c.uid) !== null && _c$uid !== void 0 ? _c$uid : c.id;\n      }).filter(Boolean);\n      const missingInState = uiUIDs.filter(u => !stateUIDs.includes(u));\n      const missingInUI = stateUIDs.filter(u => !uiUIDs.includes(u));\n\n      // Only warn if there are cards in UI that don't exist in state (real error)\n      // Don't warn about missing UI cards due to limited slot capacity\n      if (missingInState.length > 0) {\n        var _politicardDebug;\n        const mismatch = {\n          ts: Date.now(),\n          uiCount: uiUIDs.length,\n          stateCount: stateUIDs.length,\n          uiUIDs,\n          stateUIDs,\n          missingInState,\n          missingInUI,\n          stack: new Error('mismatch-stack').stack\n        };\n        window.__politicardDebug = {\n          ...window.__politicardDebug,\n          mismatch: [...(((_politicardDebug = window.__politicardDebug) === null || _politicardDebug === void 0 ? void 0 : _politicardDebug.mismatch) || [])].slice(-19).concat([mismatch])\n        };\n        // Clear, then log to console so user can copy/paste trace\n        console.warn('POLITICARD DIAGNOSTIC: hand mismatch detected', mismatch);\n      }\n    } catch (e) {\n      // swallow diagnostic errors to avoid breaking rendering\n      console.error('Diagnostic error', e);\n    }\n  }, [gameState.hands]);\n  const draw = useCallback(() => {\n    var _LAYOUT$background, _LAYOUT$background2;\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Detect influence increases and start animations\n    try {\n      const currSnapshot = {};\n      const collect = c => {\n        var _c$uid2, _c$influence;\n        if (!c) return;\n        if (c.kind !== 'pol') return;\n        const uid = (_c$uid2 = c.uid) !== null && _c$uid2 !== void 0 ? _c$uid2 : c.id != null ? String(c.id) : null;\n        if (!uid) return;\n        currSnapshot[uid] = (_c$influence = c.influence) !== null && _c$influence !== void 0 ? _c$influence : 0;\n      };\n      // board rows\n      (gameState.board[1].aussen || []).forEach(collect);\n      (gameState.board[2].aussen || []).forEach(collect);\n      (gameState.board[1].innen || []).forEach(collect);\n      (gameState.board[2].innen || []).forEach(collect);\n      // permanent slots\n      collect(gameState.permanentSlots[1].government);\n      collect(gameState.permanentSlots[2].government);\n      collect(gameState.permanentSlots[1].public);\n      collect(gameState.permanentSlots[2].public);\n      const now = performance.now();\n      Object.keys(currSnapshot).forEach(uid => {\n        var _currSnapshot$uid, _prevInfluencesRef$cu;\n        const curr = (_currSnapshot$uid = currSnapshot[uid]) !== null && _currSnapshot$uid !== void 0 ? _currSnapshot$uid : 0;\n        const prev = (_prevInfluencesRef$cu = prevInfluencesRef.current[uid]) !== null && _prevInfluencesRef$cu !== void 0 ? _prevInfluencesRef$cu : curr;\n        if (curr > prev) {\n          const delta = curr - prev;\n          const list = influenceAnimRef.current.get(uid) || [];\n          list.push({\n            start: now,\n            duration: 900,\n            amount: delta\n          });\n          influenceAnimRef.current.set(uid, list);\n        }\n        prevInfluencesRef.current[uid] = curr;\n      });\n    } catch (e) {\n      // ignore\n    }\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Clear click zones\n    clickZonesRef.current = [];\n\n    // Background: prefer PNG if configured\n    if ((_LAYOUT$background = LAYOUT.background) !== null && _LAYOUT$background !== void 0 && _LAYOUT$background.enabled && (_LAYOUT$background2 = LAYOUT.background) !== null && _LAYOUT$background2 !== void 0 && _LAYOUT$background2.src) {\n      if (backgroundImageRef.current) {\n        ctx.drawImage(backgroundImageRef.current, 0, 0, canvas.width, canvas.height);\n      } else {\n        ctx.fillStyle = '#0c131b';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n      }\n    } else {\n      ctx.fillStyle = '#0c131b';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Apply UI transform (new signature)\n    const {\n      scale,\n      offsetX,\n      offsetY\n    } = getUiTransform(canvas.width, canvas.height);\n    ctx.save();\n    ctx.translate(offsetX, offsetY);\n    ctx.scale(scale, scale);\n\n    // Draw opponent board (top rows) - clickable im Dev Mode\n    // Draw opponent board using new layout system\n    const opponentPublicRects = getPublicRects('opponent');\n    const opponentGovRects = getGovernmentRects('opponent');\n\n    // Draw opponent public slots\n    opponentPublicRects.forEach((s, idx) => {\n      const card = gameState.board[2].innen[idx];\n      if (card) {\n        drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 2);\n      } else {\n        // draw placeholder symbol for empty public slot\n        const img = slotSymbolImgsRef.current.get('public');\n        if (img && img.complete) ctx.drawImage(img, s.x, s.y, s.w, s.h);\n      }\n    });\n\n    // Draw opponent government slots\n    opponentGovRects.forEach((s, idx) => {\n      const card = gameState.board[2].aussen[idx];\n      if (card) {\n        drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 2);\n      } else {\n        const img = slotSymbolImgsRef.current.get('government');\n        if (img && img.complete) ctx.drawImage(img, s.x, s.y, s.w, s.h);\n      }\n    });\n\n    // Draw opponent permanent slots\n    drawPermanentSlotsP2(ctx);\n\n    // Draw player board (middle rows)\n    // Draw player board using new layout system\n    const playerPublicRects = getPublicRects('player');\n    const playerGovRects = getGovernmentRects('player');\n\n    // Draw player public slots\n    playerPublicRects.forEach((s, idx) => {\n      const card = gameState.board[1].innen[idx];\n      if (card) {\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 1);\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: {\n            type: 'row_slot',\n            player: 1,\n            lane: 'innen',\n            index: idx\n          }\n        });\n      } else {\n        // Empty slot click zone and draw public symbol\n        // Draw unified pulsing icon for empty public slot\n        const img = slotSymbolImgsRef.current.get('public');\n        drawSlotIconWithPulse(ctx, img, s.x, s.y, s.w, s.h, 0.4);\n        clickZonesRef.current.push({\n          x: s.x,\n          y: s.y,\n          w: s.w,\n          h: s.h,\n          data: {\n            type: 'row_slot',\n            player: 1,\n            lane: 'innen',\n            index: idx\n          }\n        });\n      }\n    });\n\n    // Draw player government slots\n    playerGovRects.forEach((s, idx) => {\n      const card = gameState.board[1].aussen[idx];\n      if (card) {\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 1);\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: {\n            type: 'row_slot',\n            player: 1,\n            lane: 'aussen',\n            index: idx\n          }\n        });\n      } else {\n        // Empty slot click zone and draw government symbol\n        const img = slotSymbolImgsRef.current.get('government');\n        drawSlotIconWithPulse(ctx, img, s.x, s.y, s.w, s.h, 0.1);\n        clickZonesRef.current.push({\n          x: s.x,\n          y: s.y,\n          w: s.w,\n          h: s.h,\n          data: {\n            type: 'row_slot',\n            player: 1,\n            lane: 'aussen',\n            index: idx\n          }\n        });\n      }\n    });\n\n    // Draw player permanent slots (draw symbols if empty)\n    // permanent government\n    const permGovZone = getZone('slot.permanent.government.player');\n    if (permGovZone) {\n      const card = gameState.permanentSlots[1].government;\n      const [x, y, w, h] = permGovZone.rectPx;\n      if (card) {\n        drawSingleSlot(ctx, 'slot.permanent.government.player', card, 'permanent_government', 1);\n      } else {\n        // Draw all slot icons using unified helper (so 'dauerhaft' used visually for empty permanent gov slot)\n        const img = slotSymbolImgsRef.current.get('dauerhaft');\n        drawSlotIconWithPulse(ctx, img, x, y, w, h, 0.2);\n      }\n    }\n    // permanent public\n    const permPubZone = getZone('slot.permanent.public.player');\n    if (permPubZone) {\n      const card = gameState.permanentSlots[1].public;\n      const [x2, y2, w2, h2] = permPubZone.rectPx;\n      if (card) {\n        drawSingleSlot(ctx, 'slot.permanent.public.player', card, 'permanent_public', 1);\n      } else {\n        // Draw all slot icons using unified helper (so 'dauerhaft' used visually for empty permanent public slot)\n        const img = slotSymbolImgsRef.current.get('dauerhaft');\n        drawSlotIconWithPulse(ctx, img, x2, y2, w2, h2, 0.9);\n      }\n    }\n\n    // Draw instant slots (both players) and placeholder if empty\n    const instantPlayerZone = getZone('slot.instant.player');\n    if (instantPlayerZone) {\n      const card = gameState.board[1].sofort[0];\n      const [x, y, w, h] = instantPlayerZone.rectPx;\n      if (card) drawSingleSlot(ctx, 'slot.instant.player', card, 'instant', 1);else {\n        // Use unified icon draw helper for instant slot\n        const img = slotSymbolImgsRef.current.get('sofort');\n        drawSlotIconWithPulse(ctx, img, x, y, w, h, 0.0);\n      }\n    }\n\n    // Draw interventions strip (player)\n    // We draw symbol if empty\n    const interventionsZone = getZone('interventions.player');\n    if (interventionsZone) {\n      const [zx, zy, zw, zh] = interventionsZone.rectPx;\n      const card = gameState.traps[1] && gameState.traps[1][0];\n      if (card) drawInterventionsP1(ctx);else {\n        const img = slotSymbolImgsRef.current.get('intervention');\n        drawSlotIconWithPulse(ctx, img, zx, zy, zw, zh, 0.6);\n      }\n    }\n\n    // Draw interventions strip (opponent) - nur im Dev Mode\n    if (devMode) {\n      drawInterventionsP2(ctx);\n    }\n\n    // Draw hand (P1)\n    drawHandP1(ctx);\n\n    // ðŸ”§ DEV MODE: Draw hand (P2) - nur im Dev Mode\n    if (devMode) {\n      drawHandP2(ctx);\n    }\n\n    // Draw info panels\n    drawInfoPanels(ctx);\n\n    // --- VISUAL EFFECTS: Particle bursts, card pop scale, initiative ripple & AP pop ---\n    try {\n      const now = performance.now();\n      const reducedMotion = !!window.__pc_reduced_motion || typeof window !== 'undefined' && window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n\n      // Particle bursts stored temporarily on window for prototyping: window.__pc_particles = Array<{x,y, vx, vy, life, size, color}>\n      const parts = window.__pc_particles || [];\n      // Skip heavy visuals when reduced motion is requested\n      if (!reducedMotion) {\n        // Update & draw particles\n        for (let i = parts.length - 1; i >= 0; i--) {\n          const p = parts[i];\n          const age = now - p.start;\n          if (age > p.life) {\n            parts.splice(i, 1);\n            continue;\n          }\n          // integrate\n          p.vy += p.gravity || 0.09;\n          p.x += p.vx;\n          p.y += p.vy;\n          const t = 1 - age / p.life;\n          ctx.save();\n          ctx.globalAlpha = Math.max(0, Math.min(1, t));\n          ctx.fillStyle = p.color || '#ffd166';\n          ctx.beginPath();\n          ctx.arc(p.x, p.y, (p.size || 4) * t, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.restore();\n        }\n        // persist mutated array\n        window.__pc_particles = parts;\n\n        // Card pop scales: window.__pc_pops = Array<{uid, started, duration, cx, cy, maxScale}>\n        const pops = window.__pc_pops || [];\n        pops.forEach(pop => {\n          const p = Math.min(1, Math.max(0, (now - pop.started) / pop.duration));\n          const eased = 1 + 0.12 * (1 - Math.pow(1 - p, 3));\n          // find card zone\n          const zone = clickZonesRef.current.find(z => {\n            var _z$data$card$uid2;\n            return z.data && z.data.card && ((_z$data$card$uid2 = z.data.card.uid) !== null && _z$data$card$uid2 !== void 0 ? _z$data$card$uid2 : String(z.data.card.id)) === pop.uid;\n          });\n          if (!zone) return;\n          // draw a translucent scale overlay\n          ctx.save();\n          ctx.translate(zone.x + zone.w / 2, zone.y + zone.h / 2);\n          ctx.scale(eased, eased);\n          ctx.globalAlpha = 0.12 * (1 - p);\n          ctx.fillStyle = '#ffffff';\n          ctx.fillRect(-zone.w / 2, -zone.h / 2, zone.w, zone.h);\n          ctx.restore();\n        });\n\n        // Initiative ripple overlays: window.__pc_ripples = Array<{cx,cy, started, duration, radius}>\n        const ripples = window.__pc_ripples || [];\n        for (let i = ripples.length - 1; i >= 0; i--) {\n          const r = ripples[i];\n          const p = Math.min(1, Math.max(0, (now - r.started) / r.duration));\n          if (p >= 1) {\n            ripples.splice(i, 1);\n            continue;\n          }\n          const radius = r.radius * (0.8 + 1.8 * p);\n          ctx.save();\n          // soft radial gradient\n          const g = ctx.createRadialGradient(r.cx, r.cy, radius * 0.1, r.cx, r.cy, radius);\n          g.addColorStop(0, `rgba(255,255,255,${0.12 * (1 - p)})`);\n          g.addColorStop(1, `rgba(255,255,255,0)`);\n          ctx.fillStyle = g;\n          ctx.beginPath();\n          ctx.arc(r.cx, r.cy, radius, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.restore();\n\n          // AP pop: spawn temporary +1 label at r.apX/apY\n          if (r.showAp && !r._apSpawned) {\n            window.__pc_aplabels = window.__pc_aplabels || [];\n            window.__pc_aplabels.push({\n              x: r.apX,\n              y: r.apY,\n              started: now,\n              duration: 800,\n              text: '+1'\n            });\n            r._apSpawned = true;\n          }\n        }\n        window.__pc_ripples = ripples;\n\n        // Draw AP labels\n        const apl = window.__pc_aplabels || [];\n        for (let i = apl.length - 1; i >= 0; i--) {\n          const l = apl[i];\n          const p = Math.min(1, Math.max(0, (now - l.started) / l.duration));\n          if (p >= 1) {\n            apl.splice(i, 1);\n            continue;\n          }\n          ctx.save();\n          ctx.globalAlpha = 1 - p;\n          ctx.fillStyle = '#ffdd57';\n          ctx.font = 'bold 22px sans-serif';\n          ctx.textAlign = 'center';\n          ctx.fillText(l.text, l.x, l.y - 20 * p);\n          ctx.restore();\n        }\n        window.__pc_aplabels = apl;\n      } else {\n        // Reduced motion: still draw AP labels minimally if present\n        const apl = window.__pc_aplabels || [];\n        for (let i = apl.length - 1; i >= 0; i--) {\n          const l = apl[i];\n          const p = Math.min(1, Math.max(0, (now - l.started) / l.duration));\n          if (p >= 1) {\n            apl.splice(i, 1);\n            continue;\n          }\n          ctx.save();\n          ctx.globalAlpha = 1 - p;\n          ctx.fillStyle = '#ffdd57';\n          ctx.font = 'bold 18px sans-serif';\n          ctx.textAlign = 'center';\n          ctx.fillText(l.text, l.x, l.y - 10 * p);\n          ctx.restore();\n        }\n        window.__pc_aplabels = apl;\n      }\n    } catch (e) {}\n\n    // --- Overlay pass: draw influence pulse ring and +N labels on top of all cards ---\n    try {\n      const now = performance.now();\n      // iterate over stored anims\n      influenceAnimRef.current.forEach((anims, uid) => {\n        // find card position by scanning clickZones\n        const zone = clickZonesRef.current.find(z => {\n          var _z$data$card$uid3;\n          return z.data && (z.data.card && ((_z$data$card$uid3 = z.data.card.uid) !== null && _z$data$card$uid3 !== void 0 ? _z$data$card$uid3 : String(z.data.card.id)) === uid || z.data.card && z.data.card.uid === uid);\n        });\n        if (!zone) return;\n        const cx = zone.x + zone.w / 2;\n        const cy = zone.y + zone.h / 2;\n        // calculate aggregate pulse for this uid\n        let maxPulse = 0;\n        let totalAmount = 0;\n        const remaining = [];\n        anims.forEach(a => {\n          const p = Math.min(1, Math.max(0, (now - a.start) / a.duration));\n          const pulse = Math.pow(Math.max(0, 1 - p), 2);\n          if (pulse > maxPulse) maxPulse = pulse;\n          if (p < 1) {\n            remaining.push(a);\n            totalAmount += a.amount;\n          }\n        });\n\n        // update list\n        if (remaining.length > 0) influenceAnimRef.current.set(uid, remaining);else influenceAnimRef.current.delete(uid);\n        if (maxPulse > 0.001) {\n          // draw a soft ring to the right-bottom of influence number\n          const ringRadius = Math.max(8, zone.w * 0.08) * (1 + maxPulse * 0.6);\n          const ringX = zone.x + zone.w - 28; // near bottom-right where influence text lives\n          const ringY = zone.y + zone.h - 20;\n          ctx.save();\n          ctx.beginPath();\n          ctx.strokeStyle = `rgba(46, 204, 113, ${0.9 * maxPulse})`;\n          ctx.lineWidth = Math.max(2, Math.ceil(6 * maxPulse));\n          ctx.arc(ringX, ringY, ringRadius, 0, Math.PI * 2);\n          ctx.stroke();\n          ctx.restore();\n        }\n        if (totalAmount > 0) {\n          // floating +N to the right of influence number\n          const labelX = zone.x + zone.w - 12;\n          const labelY = zone.y + zone.h - 32 - Math.random() * 6; // slight jitter\n          ctx.save();\n          ctx.fillStyle = '#2ecc71';\n          ctx.font = 'bold 16px sans-serif';\n          ctx.textAlign = 'left';\n          ctx.textBaseline = 'middle';\n          ctx.fillText(`+${totalAmount}`, labelX, labelY);\n          ctx.restore();\n        }\n      });\n    } catch (e) {\n      // ignore overlay errors\n    }\n\n    // --- Outline pass: draw a subtle, slightly pulsing 257x257 square around 256x256 slots ---\n    try {\n      const now2 = performance.now();\n      clickZonesRef.current.forEach((z, i) => {\n        if (!z) return;\n        const w = z.w || 0;\n        const h = z.h || 0;\n        // only target 256x256 slot-sized zones (covers the icons)\n        if (Math.abs(w - 256) > 0.1 || Math.abs(h - 256) > 0.1) return;\n        const x = z.x;\n        const y = z.y;\n\n        // Color palette (rgb)\n        const rgbTeal = '20,184,166';\n        const rgbBurg = '127,29,29';\n        const rgbPurple = '139,92,246';\n        const rgbYellow = '250,204,21';\n        const rgbOrange = '251,146,60';\n\n        // Determine slot semantic\n        let slotType = 'default';\n        try {\n          const dt = z.data || {};\n          if (dt.slot && typeof dt.slot === 'string') {\n            if (dt.slot.includes('government')) slotType = 'government';else if (dt.slot.includes('public')) slotType = 'public';else if (dt.slot.includes('permanent')) slotType = 'permanent';else if (dt.slot.includes('instant')) slotType = 'instant';\n          }\n          if (dt.type === 'row_slot' && dt.lane === 'aussen') slotType = 'government';\n          if (dt.type === 'row_slot' && dt.lane === 'innen') slotType = 'public';\n          if (dt.type === 'trap_p1' || dt.type === 'trap_p2' || dt.card && dt.card.kind === 'trap') slotType = 'intervention';\n          if (dt.type === 'activate_instant' || dt.slot === 'instant') slotType = 'instant';\n          if (dt.slot === 'permanent_government' || dt.slot === 'permanent_public' || dt.slot === 'permanent') slotType = 'permanent';\n        } catch (e) {}\n        const pulse = 0.5 + 0.5 * Math.sin(now2 / 350 + i);\n        const alpha = 0.06 + 0.12 * pulse; // subtle alpha\n        const lw = 1 + 2 * pulse; // line width between 1 and 3\n\n        // Create gradient based on slot type\n        let grad = null;\n        try {\n          grad = ctx.createLinearGradient(x, y, x + w, y + h);\n          if (slotType === 'government') {\n            grad.addColorStop(0, `rgba(${rgbTeal},1)`);\n            grad.addColorStop(1, `rgba(${rgbBurg},1)`);\n          } else if (slotType === 'public') {\n            grad.addColorStop(0, `rgba(${rgbBurg},1)`);\n            grad.addColorStop(1, `rgba(${rgbTeal},1)`);\n          } else if (slotType === 'permanent') {\n            grad.addColorStop(0, `rgba(${rgbPurple},1)`);\n            grad.addColorStop(1, `rgba(${rgbPurple},1)`);\n          } else if (slotType === 'instant') {\n            grad.addColorStop(0, `rgba(${rgbYellow},1)`);\n            grad.addColorStop(1, `rgba(${rgbYellow},1)`);\n          } else if (slotType === 'intervention') {\n            grad.addColorStop(0, `rgba(${rgbOrange},1)`);\n            grad.addColorStop(1, `rgba(${rgbOrange},1)`);\n          } else {\n            grad.addColorStop(0, `rgba(255,255,255,1)`);\n            grad.addColorStop(1, `rgba(255,255,255,1)`);\n          }\n        } catch (e) {\n          grad = null;\n        }\n        ctx.save();\n        if (grad) ctx.strokeStyle = grad;else ctx.strokeStyle = `rgba(255,255,255,${alpha.toFixed(3)})`;\n        ctx.globalAlpha = alpha;\n        ctx.lineWidth = lw;\n        // draw 257x257 centered so that it encloses the 256 slot\n        ctx.strokeRect(x - 0.5, y - 0.5, w + 1, h + 1);\n        ctx.restore();\n      });\n    } catch (e) {\n      // ignore outline errors\n    }\n    ctx.restore();\n\n    // expose zones for debug snapshot\n    window.__politicardDebug = {\n      uiTransform: getUiTransform(canvas.width, canvas.height),\n      canvasSize: {\n        width: canvas.width,\n        height: canvas.height\n      },\n      zones: LAYOUT.zones,\n      clickZones: clickZonesRef.current.slice(0, 1000)\n    };\n\n    // Run diagnostics after canvas is fully rendered\n    runDiagnostics();\n  }, [drawLane, drawHandP1, drawHandP2, drawInterventionsP1, drawInterventionsP2, drawPermanentSlotsP1, drawPermanentSlotsP2, drawInstantSlots, drawInfoPanels, devMode, runDiagnostics]);\n  const DRAW_LAYOUT_OVERLAY = false; // force off per new layout system\n\n  // Load slot symbol images once\n  useEffect(() => {\n    const load = (key, src) => {\n      const img = new Image();\n      img.onload = () => {\n        slotSymbolImgsRef.current.set(key, img);\n      };\n      img.onerror = () => {\n        console.warn('Failed to load slot icon', src);\n      };\n      img.src = src;\n    };\n    load('public', publicSymbolUrl);\n    load('sofort', sofortSymbolUrl);\n    load('dauerhaft', dauerhaftSymbolUrl);\n    load('government', governmentSymbolUrl);\n    load('intervention', interventionSymbolUrl);\n\n    // ensure first draw\n    requestAnimationFrame(draw);\n  }, [draw]);\n\n  // Redraw when game state or selection changes\n  useEffect(() => {\n    requestAnimationFrame(draw);\n  }, [gameState, selectedHandIndex, draw]);\n\n  // Continuous render loop to keep canvas updated without relying on external state refs\n  useEffect(() => {\n    let frame;\n    const loop = () => {\n      draw();\n      frame = requestAnimationFrame(loop);\n    };\n    frame = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(frame);\n  }, [draw]);\n  const handleCardClick = useCallback(data => {\n    // Hand-Klick\n    if (data.type === 'hand_p1') {\n      var _data$card$uid, _data$card, _data$card2, _gameState$hands;\n      const uid = (_data$card$uid = (_data$card = data.card) === null || _data$card === void 0 ? void 0 : _data$card.uid) !== null && _data$card$uid !== void 0 ? _data$card$uid : (_data$card2 = data.card) === null || _data$card2 === void 0 ? void 0 : _data$card2.id;\n      const stateHand = ((_gameState$hands = gameState.hands) === null || _gameState$hands === void 0 ? void 0 : _gameState$hands[1]) || [];\n      const idxInState = stateHand.findIndex(c => {\n        var _c$uid3;\n        return ((_c$uid3 = c.uid) !== null && _c$uid3 !== void 0 ? _c$uid3 : c.id) === uid;\n      });\n      onCardClick(data);\n      return;\n    }\n\n    // Slot-Klick\n    if (data.type === 'row_slot') {\n      var _gameState$board$1$in, _gameState$board, _gameState$board$, _gameState$board$1$au, _gameState$board2, _gameState$board2$;\n      const lane = data.lane;\n      const cap = getLaneCapacity(lane);\n\n      // Hole aktuelle Row-LÃ¤nge aus gameState\n      const rowCards = lane === 'public' ? (_gameState$board$1$in = (_gameState$board = gameState.board) === null || _gameState$board === void 0 ? void 0 : (_gameState$board$ = _gameState$board[1]) === null || _gameState$board$ === void 0 ? void 0 : _gameState$board$.innen) !== null && _gameState$board$1$in !== void 0 ? _gameState$board$1$in : [] : (_gameState$board$1$au = (_gameState$board2 = gameState.board) === null || _gameState$board2 === void 0 ? void 0 : (_gameState$board2$ = _gameState$board2[1]) === null || _gameState$board2$ === void 0 ? void 0 : _gameState$board2$.aussen) !== null && _gameState$board$1$au !== void 0 ? _gameState$board$1$au : [];\n      if (rowCards.length >= cap) {\n        // Optional: UI Feedback\n        console.warn(`Row ${lane} is full (${rowCards.length}/${cap})`);\n        return;\n      }\n      onCardClick(data);\n      return;\n    }\n\n    // Andere Klicks (empty_slot, board_card, etc.)\n    onCardClick(data);\n  }, [gameState, onCardClick]);\n  const handleClick = useCallback(e => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    const {\n      scale,\n      offsetX,\n      offsetY\n    } = getUiTransform(canvas.width, canvas.height);\n    const mx = (e.clientX - rect.left - offsetX) / scale;\n    const my = (e.clientY - rect.top - offsetY) / scale;\n    const hit = clickZonesRef.current.find(z => mx >= z.x && mx <= z.x + z.w && my >= z.y && my <= z.y + z.h);\n    if (hit) handleCardClick(hit.data);\n  }, [handleCardClick]);\n  const handleMouseMove = useCallback(e => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    const {\n      scale,\n      offsetX,\n      offsetY\n    } = getUiTransform(canvas.width, canvas.height);\n    const mx = (e.clientX - rect.left - offsetX) / scale;\n    const my = (e.clientY - rect.top - offsetY) / scale;\n    const hit = clickZonesRef.current.find(z => mx >= z.x && mx <= z.x + z.w && my >= z.y && my <= z.y + z.h);\n    if (hit) {\n      var _hit$data$card;\n      console.log('[hover]', hit.data.type, (_hit$data$card = hit.data.card) === null || _hit$data$card === void 0 ? void 0 : _hit$data$card.name);\n      onCardHover({\n        ...hit.data,\n        x: e.clientX,\n        y: e.clientY\n      });\n    } else {\n      onCardHover(null);\n    }\n  }, [onCardHover]);\n  const handleWheel = useCallback(e => {\n    // only enable when player1 has more slots than visible\n    const handLen = gameState.hands && gameState.hands[1] ? gameState.hands[1].length : 0;\n    const zone = getZone('hand.player');\n    if (!zone) return;\n    if (handLen <= 5) return; // nothing to scroll\n\n    // Prevent page scrolling when over canvas\n    e.preventDefault();\n\n    // accumulate target offset (invert so wheel down moves cards up)\n    // Each wheel step moves by 48px per delta unit\n    const delta = Math.sign(e.deltaY) * 48;\n    // compute slot height more robustly\n    const slots = computeSlotRects(zone);\n    const slotH = slots && slots.length > 0 ? slots[0].h : zone.rectPx[3] / 5;\n    const visible = 5;\n    const maxOffset = -(Math.max(0, handLen - visible) * slotH);\n    handScrollTargetRef.current = Math.max(Math.min(handScrollTargetRef.current - delta, 0), maxOffset);\n  }, [gameState.hands]);\n  const handleTouchStart = useCallback(e => {\n    if (!e.touches || e.touches.length === 0) return;\n    const handLen = gameState.hands && gameState.hands[1] ? gameState.hands[1].length : 0;\n    if (handLen <= 5) return;\n    isTouchingRef.current = true;\n    const y = e.touches[0].clientY;\n    touchStartYRef.current = y;\n    lastTouchYRef.current = y;\n    e.preventDefault();\n  }, [gameState.hands]);\n  const handleTouchMove = useCallback(e => {\n    var _lastTouchYRef$curren;\n    if (!isTouchingRef.current) return;\n    if (!e.touches || e.touches.length === 0) return;\n    const y = e.touches[0].clientY;\n    const last = (_lastTouchYRef$curren = lastTouchYRef.current) !== null && _lastTouchYRef$curren !== void 0 ? _lastTouchYRef$curren : y;\n    const dy = y - last; // positive when moving down\n    lastTouchYRef.current = y;\n\n    // invert so dragging up moves cards up\n    const delta = -dy;\n    const handLen = gameState.hands && gameState.hands[1] ? gameState.hands[1].length : 0;\n    const zone = getZone('hand.player');\n    if (!zone) return;\n    const slots = computeSlotRects(zone);\n    const slotH = slots && slots.length > 0 ? slots[0].h : zone.rectPx[3] / 5;\n    const visible = 5;\n    const maxOffset = -(Math.max(0, handLen - visible) * slotH);\n    handScrollTargetRef.current = Math.max(Math.min(handScrollTargetRef.current + delta, 0), maxOffset);\n    e.preventDefault();\n  }, [gameState.hands]);\n  const handleTouchEnd = useCallback(e => {\n    isTouchingRef.current = false;\n    touchStartYRef.current = null;\n    lastTouchYRef.current = null;\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    width: 1920,\n    height: 1080,\n    style: {\n      display: 'block',\n      width: '100%',\n      height: '100%',\n      imageRendering: 'auto'\n    },\n    onClick: handleClick,\n    onMouseMove: handleMouseMove,\n    onWheel: handleWheel,\n    onTouchStart: handleTouchStart,\n    onTouchMove: handleTouchMove,\n    onTouchEnd: handleTouchEnd\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1335,\n    columnNumber: 5\n  }, this);\n};\n_s(GameCanvas, \"SWhi5Jx7t6UV7XWaJqVlmbR/cTA=\");\n_c = GameCanvas;\nvar _c;\n$RefreshReg$(_c, \"GameCanvas\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","LAYOUT","getZone","computeSlotRects","getUiTransform","getLaneCapacity","getPublicRects","getGovernmentRects","sortHandCards","getCardImagePath","influenceIconUrl","publicSymbolUrl","sofortSymbolUrl","dauerhaftSymbolUrl","governmentSymbolUrl","interventionSymbolUrl","jsxDEV","_jsxDEV","GameCanvas","gameState","selectedHandIndex","onCardClick","onCardHover","devMode","_s","canvasRef","clickZonesRef","handScrollTargetRef","handScrollCurrentRef","handScrollEnabledRef","touchStartYRef","lastTouchYRef","isTouchingRef","backgroundImageRef","imageCacheRef","Map","influenceImgRef","influenceAnimRef","prevInfluencesRef","slotSymbolImgsRef","drawSlotIconWithPulse","ctx","img","x","y","w","h","phase","complete","now","performance","base","pulseRange","period","pulse","Math","sin","save","globalAlpha","drawImage","grad","createLinearGradient","addColorStop","globalCompositeOperation","fillStyle","fillRect","restore","e","Image","src","current","drawCardAt","card","size","selected","showAPCost","player","_shield","dx","dy","s","floor","cached","get","onload","set","kind","_influence","barH","max","fontSize","font","textAlign","textBaseline","fillText","influence","protected","shield","deactivated","_influence2","badgeHeight","badgeWidth","badgeX","badgeY","beginPath","roundRect","fill","strokeStyle","lineWidth","strokeRect","getSlotDisplayName","zoneId","index","slotNumber","includes","drawLane","lane","clickable","zone","slots","arr","board","forEach","idx","bgColor","isSelected","hands","clickZone","textY","name","push","data","type","slotName","drawHandP1","hand","target","offsetY","round","i","originalIndex","findIndex","c","uid","isSel","sx","sy","drawHandP2","rectPx","drawInterventionsP1","traps","zx","zy","zw","zh","drawInterventionsP2","drawSingleSlot","clickType","slot","drawPermanentSlotsP1","permanentSlots","government","public","drawPermanentSlotsP2","drawInstantSlots","sofortPlayerCard","sofort","sofortOppCard","getActiveKeywordsAndSubcategories","allCards","innen","aussen","filter","keywords","Set","subcategories","tag","add","publicCard","oligarchNames","platformNames","movementNames","ngoNames","intelligenceNames","mediaNames","Array","from","drawInfoPanels","govPanelX","govPanelY","govPanelW","govPanelH","length","keyword","pubPanelX","pubPanelY","pubPanelW","pubPanelH","subcategory","displayName","substring","runDiagnostics","handZones","z","uiUIDs","map","_z$data$card$uid","id","Boolean","stateHand","stateUIDs","_c$uid","missingInState","u","missingInUI","_politicardDebug","mismatch","ts","Date","uiCount","stateCount","stack","Error","window","__politicardDebug","slice","concat","console","warn","error","draw","_LAYOUT$background","_LAYOUT$background2","canvas","getContext","currSnapshot","collect","_c$uid2","_c$influence","String","Object","keys","_currSnapshot$uid","_prevInfluencesRef$cu","curr","prev","delta","list","start","duration","amount","clearRect","width","height","background","enabled","scale","offsetX","translate","opponentPublicRects","opponentGovRects","playerPublicRects","playerGovRects","permGovZone","permPubZone","x2","y2","w2","h2","instantPlayerZone","interventionsZone","reducedMotion","__pc_reduced_motion","matchMedia","matches","parts","__pc_particles","p","age","life","splice","vy","gravity","vx","t","min","color","arc","PI","pops","__pc_pops","pop","started","eased","pow","find","_z$data$card$uid2","ripples","__pc_ripples","r","radius","g","createRadialGradient","cx","cy","showAp","_apSpawned","__pc_aplabels","apX","apY","text","apl","l","anims","_z$data$card$uid3","maxPulse","totalAmount","remaining","a","delete","ringRadius","ringX","ringY","ceil","stroke","labelX","labelY","random","now2","abs","rgbTeal","rgbBurg","rgbPurple","rgbYellow","rgbOrange","slotType","dt","alpha","lw","toFixed","uiTransform","canvasSize","zones","clickZones","DRAW_LAYOUT_OVERLAY","load","key","onerror","requestAnimationFrame","frame","loop","cancelAnimationFrame","handleCardClick","_data$card$uid","_data$card","_data$card2","_gameState$hands","idxInState","_c$uid3","_gameState$board$1$in","_gameState$board","_gameState$board$","_gameState$board$1$au","_gameState$board2","_gameState$board2$","cap","rowCards","handleClick","rect","getBoundingClientRect","mx","clientX","left","my","clientY","top","hit","handleMouseMove","_hit$data$card","log","handleWheel","handLen","preventDefault","sign","deltaY","slotH","visible","maxOffset","handleTouchStart","touches","handleTouchMove","_lastTouchYRef$curren","last","handleTouchEnd","ref","style","display","imageRendering","onClick","onMouseMove","onWheel","onTouchStart","onTouchMove","onTouchEnd","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/components/GameCanvas.tsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback } from 'react';\nimport { GameState, Card, PoliticianCard, Player, Lane } from '../types/game';\nimport { LAYOUT, getZone, computeSlotRects, getUiTransform, getLaneCapacity, getPublicRects, getGovernmentRects, getSofortRect } from '../ui/layout';\nimport { drawCardImage, sortHandCards } from '../utils/gameUtils';\nimport { getNetApCost } from '../utils/ap';\nimport { getCardImagePath } from '../data/gameData';\nimport influenceIconUrl from '../assets/icons/influence.svg';\nimport publicSymbolUrl from '../assets/icons/public_symbol.png';\nimport sofortSymbolUrl from '../assets/icons/sofort_initiative_symbol.png';\nimport dauerhaftSymbolUrl from '../assets/icons/dauerhaft_initative.png';\nimport governmentSymbolUrl from '../assets/icons/government_symbol.png';\nimport interventionSymbolUrl from '../assets/icons/intervention_symbol.png';\n\ninterface GameCanvasProps {\n  gameState: GameState;\n  selectedHandIndex: number | null;\n  onCardClick: (data: any) => void;\n  onCardHover: (data: any) => void;\n  devMode?: boolean; // ðŸ”§ DEV MODE: Show P2 hand when true\n}\n\n\n\nexport const GameCanvas: React.FC<GameCanvasProps> = ({\n  gameState,\n  selectedHandIndex,\n  onCardClick,\n  onCardHover,\n  devMode = false,\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const clickZonesRef = useRef<Array<{ x: number; y: number; w: number; h: number; data: any }>>([]);\n  // Smooth vertical scroll for P1 hand when it has more than visible slots\n  const handScrollTargetRef = useRef<number>(0);\n  const handScrollCurrentRef = useRef<number>(0);\n  const handScrollEnabledRef = useRef<boolean>(true);\n  // Touch handling refs\n  const touchStartYRef = useRef<number | null>(null);\n  const lastTouchYRef = useRef<number | null>(null);\n  const isTouchingRef = useRef<boolean>(false);\n  const backgroundImageRef = useRef<HTMLImageElement | null>(null);\n  const imageCacheRef = useRef<Map<string, HTMLImageElement>>(new Map());\n  const influenceImgRef = useRef<HTMLImageElement | null>(null);\n  // Animation state for visual influence changes: Map<uid, Array<Anim>>\n  const influenceAnimRef = useRef<Map<string, Array<{ start: number; duration: number; amount: number }>>>(new Map());\n  // Previous per-card influence snapshot to detect increases\n  const prevInfluencesRef = useRef<Record<string, number>>({});\n  // Slot symbol images\n  const slotSymbolImgsRef = useRef<Map<string, HTMLImageElement>>(new Map());\n\n  // Helper: draw slot icons with uniform pulsing opacity and a light reflection\n  const drawSlotIconWithPulse = useCallback((ctx: CanvasRenderingContext2D, img: HTMLImageElement | undefined, x: number, y: number, w: number, h: number, phase = 0) => {\n    if (!img || !img.complete) return;\n    try {\n      const now = performance.now();\n      const base = 0.10; // base opacity\n      const pulseRange = 0.08; // pulse amplitude (-> up to base + pulseRange)\n      const period = 700; // ms\n      const pulse = base + pulseRange * (0.5 + 0.5 * Math.sin(now / period + phase));\n\n      // draw icon with pulsing alpha\n      ctx.save();\n      ctx.globalAlpha = pulse;\n      ctx.drawImage(img, x, y, w, h);\n\n      // subtle reflection: gradient overlay on top half\n      const grad = ctx.createLinearGradient(x, y, x, y + h * 0.5);\n      grad.addColorStop(0, `rgba(255,255,255,${0.18 * pulse})`);\n      grad.addColorStop(1, `rgba(255,255,255,0)`);\n      ctx.globalCompositeOperation = 'lighter';\n      ctx.fillStyle = grad as any;\n      ctx.fillRect(x, y, w, h * 0.5);\n\n      ctx.restore();\n    } catch (e) {\n      // silent fallback\n    }\n  }, []);\n\n  // Load influence icon once\n  useEffect(() => {\n    const img = new Image();\n    img.src = influenceIconUrl;\n    influenceImgRef.current = img;\n  }, []);\n\n\n  const drawCardAt = useCallback((\n    ctx: CanvasRenderingContext2D,\n    card: Card,\n    x: number,\n    y: number,\n    size: number,\n    selected: boolean = false,\n    showAPCost: boolean = false,\n    player?: Player\n  ) => {\n    let dx = x, dy = y, s = size;\n    if (selected) {\n      s = Math.floor(size * 1.05);\n      dx = x - Math.floor((s - size) / 2);\n      dy = y - Math.floor((s - size) / 2);\n    }\n\n    // Note: pulse overlay is drawn at top layer after all cards are rendered\n\n    // Draw card image with caching to prevent flicker in continuous loop\n    const src = getCardImagePath(card, 'ui');\n    const cached = imageCacheRef.current.get(src);\n    if (cached && cached.complete) {\n      ctx.drawImage(cached, dx, dy, s, s);\n    } else {\n      const img = new Image();\n      img.onload = () => {\n        imageCacheRef.current.set(src, img);\n        ctx.drawImage(img, dx, dy, s, s);\n      };\n      img.src = src;\n      imageCacheRef.current.set(src, img);\n    }\n\n    // Status-Indikatoren (fÃ¼r alle Board-Karten)\n    // Einfluss-Wert dauerhaft anzeigen (oben links) â€“ nur fÃ¼r Regierungskarten\n    if ((card as any).kind === 'pol') {\n      const barH = Math.max(20, Math.floor(s * 0.12) + 6);\n      ctx.fillStyle = 'rgba(0,0,0,0.6)';\n      ctx.fillRect(dx, dy + s - barH, s, barH);\n\n      ctx.fillStyle = '#ffffff';\n      const fontSize = Math.floor(s * 0.12);\n      ctx.font = `bold ${fontSize}px sans-serif`;\n      ctx.textAlign = 'left';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(`${(card as any).influence ?? 0}`, dx + 8, dy + s - barH / 2);\n    }\n    // Schutz-Status (blauer Punkt)\n    if ((card as any).protected || ((card as any).shield ?? 0) > 0) {\n      ctx.fillStyle = '#1da1f2';\n      ctx.fillRect(dx + s - 22, dy + 6, 16, 16);\n    }\n    // Deaktiviert-Status (roter Punkt)\n    if ((card as any).deactivated) {\n      ctx.fillStyle = '#b63838';\n      ctx.fillRect(dx + s - 22, dy + 26, 16, 16);\n    }\n\n    // Einfluss-Badge fÃ¼r Handkarten oben rechts (nur Regierungskarten)\n    if (showAPCost && player && (card as any).kind === 'pol') {\n      const badgeHeight = Math.max(16, Math.floor(s * 0.12));\n      const badgeWidth = badgeHeight * 2;\n      const badgeX = dx + s - badgeWidth - 6;\n      const badgeY = dy + 6;\n\n      // Semi-transparent dunkler Hintergrund\n      ctx.fillStyle = 'rgba(0,0,0,0.6)';\n      ctx.beginPath();\n      ctx.roundRect(badgeX, badgeY, badgeWidth, badgeHeight, badgeHeight / 2);\n      ctx.fill();\n\n      // Influence icon (90% opacity) links im Badge\n      if (influenceImgRef.current && influenceImgRef.current.complete) {\n        ctx.globalAlpha = 0.9;\n        ctx.drawImage(influenceImgRef.current, badgeX + 2, badgeY + 2, badgeHeight - 4, badgeHeight - 4);\n        ctx.globalAlpha = 1;\n      }\n\n      // Influence number rechts im Badge\n      ctx.fillStyle = '#ffffff';\n      ctx.font = `bold ${Math.floor(badgeHeight * 0.5)}px sans-serif`;\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(`${(card as any).influence ?? 0}`, badgeX + badgeWidth - 4, badgeY + badgeHeight / 2);\n\n      // Reset align\n      ctx.textAlign = 'start';\n      ctx.textBaseline = 'alphabetic';\n    }\n\n    // NOTE: influence overlays (pulse + labels) are drawn in a separate pass\n\n    // Auswahl-Rahmen\n    if (selected) {\n      ctx.strokeStyle = '#61dafb';\n      ctx.lineWidth = 3;\n      ctx.strokeRect(dx + 1, dy + 1, s - 2, s - 2);\n      ctx.lineWidth = 1;\n    }\n\n    // Return exact 256x256 click zone over the card\n    // Since all cards are 256x256, the click zone should match exactly\n    return { x: dx, y: dy, w: 256, h: 256 };\n  }, [gameState]);\n\n\n\n\n\n\n\n  // Slot-Benennungs-Funktion basierend auf Glossar\n  const getSlotDisplayName = useCallback((zoneId: string, index: number, player: Player): string => {\n    const slotNumber = index + 1;\n\n    if (zoneId.includes('government')) {\n      if (zoneId.includes('player')) {\n        return `Regierungsreihe Slot ${slotNumber}`;\n      } else {\n        return `Gegner Regierung Slot ${slotNumber}`;\n      }\n    } else if (zoneId.includes('public')) {\n      if (zoneId.includes('player')) {\n        return `Ã–ffentlichkeitsreihe Slot ${slotNumber}`;\n      } else {\n        return `Gegner Ã–ffentlichkeit Slot ${slotNumber}`;\n      }\n    } else if (zoneId.includes('permanent.government')) {\n      if (zoneId.includes('player')) {\n        return 'Regierung Spezial-Slot';\n      } else {\n        return 'Gegner Regierung Spezial-Slot';\n      }\n    } else if (zoneId.includes('permanent.public')) {\n      if (zoneId.includes('player')) {\n        return 'Ã–ffentlichkeit Spezial-Slot';\n      } else {\n        return 'Gegner Ã–ffentlichkeit Spezial-Slot';\n      }\n    } else if (zoneId.includes('instant')) {\n      if (zoneId.includes('player')) {\n        return 'Sofort-Slot';\n      } else {\n        return 'Gegner Sofort-Slot';\n      }\n    } else if (zoneId.includes('hand')) {\n      return 'Hand';\n    } else if (zoneId.includes('interventions')) {\n      return 'Interventionen';\n    }\n\n    return `Slot ${slotNumber}`;\n  }, []);\n\n  const drawLane = useCallback((\n    ctx: CanvasRenderingContext2D,\n    zoneId: string,\n    player: Player,\n    lane: Lane,\n    clickable: boolean\n  ) => {\n    const zone = getZone(zoneId);\n    if (!zone) return;\n\n    const slots = computeSlotRects(zone);\n    const arr = gameState.board[player][lane];\n\n    slots.forEach((s, idx) => {\n      const card = arr[idx];\n\n      // Hintergrundfarbe nach Kategorie\n      let bgColor = 'rgba(0,0,0,0.1)'; // Standard\n      if (zoneId.includes('government')) {\n        bgColor = 'rgba(255, 197, 0, 0.15)'; // Hellgelb fÃ¼r Regierung\n      } else if (zoneId.includes('public')) {\n        bgColor = 'rgba(0, 255, 0, 0.15)'; // HellgrÃ¼n fÃ¼r Ã–ffentlichkeit\n      }\n\n      ctx.fillStyle = bgColor;\n      ctx.fillRect(s.x, s.y, s.w, s.h);\n\n      // Slot-Rahmen\n      ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n      ctx.strokeRect(s.x + 0.5, s.y + 0.5, s.w - 1, s.h - 1);\n\n      if (card) {\n        const isSelected = player === 1 && selectedHandIndex !== null && gameState.hands[1][selectedHandIndex] === card;\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, isSelected, false);\n\n        // Kartenname unter dem Slot anzeigen\n        ctx.fillStyle = 'rgba(255,255,255,0.9)';\n        ctx.font = 'bold 12px sans-serif';\n        ctx.textAlign = 'center';\n        const textY = s.y + s.h + 16;\n        ctx.fillText(card.name, s.x + s.w/2, textY);\n\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: { type: 'board_card', player, lane, index: idx, card }\n        });\n      } else if (clickable && gameState.current === player) {\n        // Slot-Benennung anzeigen (fÃ¼r den aktuellen Spieler)\n        const slotName = getSlotDisplayName(zoneId, idx, player);\n        ctx.fillStyle = 'rgba(255,255,255,0.6)';\n        ctx.font = '11px sans-serif';\n        ctx.textAlign = 'center';\n        const textY = s.y + s.h/2;\n        ctx.fillText(slotName, s.x + s.w/2, textY);\n\n        clickZonesRef.current.push({\n          x: s.x, y: s.y, w: s.w, h: s.h,\n          data: { type: 'row_slot', lane, index: idx }\n        });\n      }\n    });\n  }, [gameState, selectedHandIndex, drawCardAt, getSlotDisplayName]);\n\n  const drawHandP1 = useCallback((ctx: CanvasRenderingContext2D) => {\n    const hand = sortHandCards(gameState.hands[1]);\n    const zone = getZone('hand.player');\n    if (!zone) return;\n\n    const slots = computeSlotRects(zone);\n    // Apply smooth offset (lerp towards target)\n    const target = handScrollTargetRef.current;\n    handScrollCurrentRef.current += (target - handScrollCurrentRef.current) * 0.15; // easing\n    const offsetY = Math.round(handScrollCurrentRef.current);\n    slots.forEach((s: { x: number; y: number; w: number; h: number }, i: number) => {\n      const card = hand[i];\n      if (!card) return;\n      // Find original index in unsorted hand for click handling\n      const originalIndex = gameState.hands[1].findIndex(c => c.uid === card.uid);\n      const isSel = selectedHandIndex === originalIndex;\n      // apply vertical offset\n      const sx = s.x;\n      const sy = s.y + offsetY;\n      const clickZone = drawCardAt(ctx, card, sx, sy, s.w, isSel, true, 1); // Show AP cost for player 1 hand\n      clickZonesRef.current.push({ ...clickZone, data: { type: 'hand_p1', index: originalIndex, card } });\n    });\n  }, [gameState.hands, selectedHandIndex, drawCardAt]);\n\n      // ðŸ”§ DEV MODE: Player 2 Hand (rechts unten, kompakter)\n  const drawHandP2 = useCallback((ctx: CanvasRenderingContext2D) => {\n    const hand = sortHandCards(gameState.hands[2]);\n    const zone = getZone('hand.opponent');\n    if (!zone) return;\n\n    const slots = computeSlotRects(zone);\n\n    // Hintergrund fÃ¼r P2 Hand\n    const [x, y, w, h] = zone.rectPx;\n    ctx.fillStyle = 'rgba(255, 100, 100, 0.15)'; // RÃ¶tlicher Hintergrund fÃ¼r P2\n    ctx.fillRect(x, y, w, h);\n    ctx.strokeStyle = 'rgba(255, 100, 100, 0.3)';\n    ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);\n\n    // Label fÃ¼r P2 Hand\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n    ctx.font = 'bold 14px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Player 2 Hand', x + w/2, y - 8);\n\n    slots.forEach((s: { x: number; y: number; w: number; h: number }, i: number) => {\n      const card = hand[i];\n      if (!card) return;\n      // Find original index in unsorted hand for click handling\n      const originalIndex = gameState.hands[2].findIndex(c => c.uid === card.uid);\n      const isSel = gameState.current === 2 && selectedHandIndex === originalIndex;\n      const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, isSel, true, 2); // Show AP cost for player 2 hand\n      clickZonesRef.current.push({ ...clickZone, data: { type: 'hand_p2', index: originalIndex, card } });\n    });\n  }, [gameState, selectedHandIndex, drawCardAt]);\n  // Interventions strip (player traps)\n  const drawInterventionsP1 = useCallback((ctx: CanvasRenderingContext2D) => {\n    const traps = gameState.traps[1] || [];\n    const zone = getZone('interventions.player');\n    if (!zone) return;\n\n    // Single intervention slot\n    const [zx, zy, zw, zh] = zone.rectPx;\n    const card = traps[0]; // Only first trap\n\n    // Hintergrund fÃ¼r Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.15)'; // Lavendelfarben fÃ¼r Interventionen\n    ctx.fillRect(zx, zy, zw, zh);\n    ctx.strokeStyle = 'rgba(200, 160, 255, 0.3)';\n    ctx.strokeRect(zx + 0.5, zy + 0.5, zw - 1, zh - 1);\n\n    // Slot-Benennung fÃ¼r Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.8)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Intervention', zx + 8, zy + zh - 6);\n\n    if (card) {\n      const clickZone = drawCardAt(ctx, card, zx, zy, zw, false, false);\n      clickZonesRef.current.push({ ...clickZone, data: { type: 'trap_p1', index: 0, card } });\n    }\n  }, [gameState.traps, drawCardAt]);\n\n  // Interventions strip (opponent traps)\n  const drawInterventionsP2 = useCallback((ctx: CanvasRenderingContext2D) => {\n    const traps = gameState.traps[2] || [];\n    const zone = getZone('interventions.opponent');\n    if (!zone) return;\n\n    // Single intervention slot\n    const [zx, zy, zw, zh] = zone.rectPx;\n    const card = traps[0]; // Only first trap\n\n    // Hintergrund fÃ¼r Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.15)'; // Lavendelfarben fÃ¼r Interventionen\n    ctx.fillRect(zx, zy, zw, zh);\n    ctx.strokeStyle = 'rgba(200, 160, 255, 0.3)';\n    ctx.strokeRect(zx + 0.5, zy + 0.5, zw - 1, zh - 1);\n\n    // Slot-Benennung fÃ¼r Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.8)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Intervention', zx + 8, zy + zh - 6);\n\n    if (card) {\n      const clickZone = drawCardAt(ctx, card, zx, zy, zw, false, false);\n      clickZonesRef.current.push({ ...clickZone, data: { type: 'trap_p2', index: 0, card } });\n    }\n  }, [gameState.traps, drawCardAt]);\n\n  // Single slot drawing function\n  const drawSingleSlot = useCallback((\n    ctx: CanvasRenderingContext2D,\n    zoneId: string,\n    card: Card | null,\n    clickType: string,\n    player: Player\n  ) => {\n    const zone = getZone(zoneId);\n    if (!zone) return;\n    const [x, y, w, h] = zone.rectPx;\n\n    // Hintergrundfarbe nach Kategorie\n    let bgColor = 'rgba(0,0,0,0.1)'; // Standard\n    if (zoneId.includes('government')) {\n      bgColor = 'rgba(255, 197, 0, 0.15)'; // Hellgelb fÃ¼r Regierung\n    } else if (zoneId.includes('public')) {\n      bgColor = 'rgba(0, 255, 0, 0.15)'; // HellgrÃ¼n fÃ¼r Ã–ffentlichkeit\n    } else if (zoneId.includes('instant')) {\n      bgColor = 'rgba(127, 116, 91, 0.15)'; // Neutral fÃ¼r Sofort-Slots\n    } else if (zoneId.includes('permanent')) {\n      // Unterscheide zwischen government und public permanent slots\n      if (zoneId.includes('government')) {\n        bgColor = 'rgba(255, 197, 0, 0.15)';\n      } else if (zoneId.includes('public')) {\n        bgColor = 'rgba(0, 255, 0, 0.15)';\n      }\n    }\n\n    ctx.fillStyle = bgColor;\n    ctx.fillRect(x, y, w, h);\n\n    // Draw slot border\n    ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n    ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);\n\n    if (card) {\n      const isSelected = player === 1 && selectedHandIndex !== null && gameState.hands[1][selectedHandIndex] === card;\n      const clickZone = drawCardAt(ctx, card, x, y, w, isSelected, false);\n\n      // Kartenname unter dem Slot anzeigen\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.font = 'bold 12px sans-serif';\n      ctx.textAlign = 'center';\n      const textY = y + h + 16;\n      ctx.fillText(card.name, x + w/2, textY);\n\n      clickZonesRef.current.push({ ...clickZone, data: { type: 'slot_card', slot: clickType, card } });\n\n      // ðŸ”§ NEU: Sofort-Initiative-Slots sind klickbar fÃ¼r Aktivierung\n      if (clickType === 'instant' && gameState.current === player) {\n        clickZonesRef.current.push({\n          x, y, w, h,\n          data: { type: 'activate_instant', player, card }\n        });\n      }\n    } else if (gameState.current === player) {\n      // Slot-Benennung fÃ¼r leere Slots anzeigen (fÃ¼r den aktuellen Spieler)\n      const slotName = getSlotDisplayName(zoneId, 0, player);\n      ctx.fillStyle = 'rgba(255,255,255,0.6)';\n      ctx.font = '11px sans-serif';\n      ctx.textAlign = 'center';\n      const textY = y + h/2;\n      ctx.fillText(slotName, x + w/2, textY);\n\n      clickZonesRef.current.push({ x, y, w, h, data: { type: 'empty_slot', slot: clickType } });\n    }\n  }, [selectedHandIndex, gameState, drawCardAt, getSlotDisplayName]);\n\n  // Draw permanent slots for player\n  const drawPermanentSlotsP1 = useCallback((ctx: CanvasRenderingContext2D) => {\n    drawSingleSlot(ctx, 'slot.permanent.government.player', gameState.permanentSlots[1].government, 'permanent_government', 1);\n    drawSingleSlot(ctx, 'slot.permanent.public.player', gameState.permanentSlots[1].public, 'permanent_public', 1);\n  }, [gameState.permanentSlots, drawSingleSlot]);\n\n  // Draw permanent slots for opponent\n  const drawPermanentSlotsP2 = useCallback((ctx: CanvasRenderingContext2D) => {\n    drawSingleSlot(ctx, 'slot.permanent.government.opponent', gameState.permanentSlots[2].government, 'permanent_government', 2);\n    drawSingleSlot(ctx, 'slot.permanent.public.opponent', gameState.permanentSlots[2].public, 'permanent_public', 2);\n  }, [gameState.permanentSlots, drawSingleSlot]);\n\n  // Draw instant slots\n  const drawInstantSlots = useCallback((ctx: CanvasRenderingContext2D) => {\n    // Sofort-Initiative-Slots aus dem Board zeichnen\n    const sofortPlayerCard = gameState.board[1].sofort[0];\n    const sofortOppCard = gameState.board[2].sofort[0];\n\n    drawSingleSlot(ctx, 'slot.instant.player', sofortPlayerCard, 'instant', 1);\n    drawSingleSlot(ctx, 'slot.instant.opponent', sofortOppCard, 'instant', 2);\n  }, [gameState.board, drawSingleSlot]);\n\n  // Aktive SchlÃ¼sselwÃ¶rter und Unterkategorien ermitteln\n  const getActiveKeywordsAndSubcategories = useCallback((player: Player) => {\n    const board = gameState.board[player];\n    const permanentSlots = gameState.permanentSlots[player];\n    const allCards = [\n      ...board.innen,\n      ...board.aussen,\n      permanentSlots.government,\n      permanentSlots.public\n    ].filter(c => c && c.kind === 'pol') as PoliticianCard[];\n\n    const keywords = new Set<string>();\n    const subcategories = new Set<string>();\n\n    allCards.forEach(card => {\n      if (!card.deactivated) {\n        // Regierungskarten-SchlÃ¼sselwÃ¶rter\n        if (card.tag === 'Leadership') {\n          keywords.add('Leadership');\n        }\n        if (card.tag === 'Diplomat') {\n          keywords.add('Diplomat');\n        }\n\n        // Ã–ffentlichkeits-Unterkategorien (fÃ¼r Karten in Ã–ffentlichkeitsreihe)\n        if (board.innen.includes(card)) {\n          const publicCard = card as any;\n          if (publicCard.tag) {\n            // Oligarch\n            const oligarchNames = ['Elon Musk', 'Bill Gates', 'George Soros', 'Warren Buffett', 'Mukesh Ambani', 'Jeff Bezos', 'Alisher Usmanov', 'Gautam Adani', 'Jack Ma', 'Zhang Yiming', 'Roman Abramovich'];\n            if (oligarchNames.includes(publicCard.name)) {\n              subcategories.add('Oligarch');\n            }\n\n            // Plattform\n            const platformNames = ['Mark Zuckerberg', 'Tim Cook', 'Sam Altman', 'Jack Ma'];\n            if (platformNames.includes(publicCard.name)) {\n              subcategories.add('Plattform');\n            }\n\n            // Bewegung\n            const movementNames = ['Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'];\n            if (movementNames.includes(publicCard.name)) {\n              subcategories.add('Bewegung');\n            }\n\n            // NGO/Think-Tank\n            const ngoNames = ['Bill Gates', 'George Soros', 'Jennifer Doudna', 'Noam Chomsky', 'Anthony Fauci'];\n            if (ngoNames.includes(publicCard.name)) {\n              subcategories.add('NGO/Think-Tank');\n            }\n\n            // Intelligenz\n            const intelligenceNames = ['Jennifer Doudna', 'Noam Chomsky', 'Edward Snowden', 'Julian Assange', 'Yuval Noah Harari', 'Ai Weiwei', 'Alexei Navalny', 'Anthony Fauci'];\n            if (intelligenceNames.includes(publicCard.name)) {\n              subcategories.add('Intelligenz');\n            }\n\n            // Medien\n            const mediaNames = ['Oprah Winfrey'];\n            if (mediaNames.includes(publicCard.name)) {\n              subcategories.add('Medien');\n            }\n          }\n        }\n      }\n    });\n\n    return {\n      keywords: Array.from(keywords),\n      subcategories: Array.from(subcategories)\n    };\n  }, [gameState]);\n\n  // Info-Panels zeichnen\n  const drawInfoPanels = useCallback((ctx: CanvasRenderingContext2D) => {\n    const { keywords, subcategories } = getActiveKeywordsAndSubcategories(1);\n\n    // Panel fÃ¼r RegierungsschlÃ¼sselwÃ¶rter (rechts neben Regierungsslots)\n    const govPanelX = 1640 + 256 + 20; // Nach dem letzten permanenten Slot\n    const govPanelY = 300; // Auf HÃ¶he der Regierungsslots\n    const govPanelW = 120;\n    const govPanelH = 256;\n\n    // Regierungspanel Hintergrund\n    ctx.fillStyle = 'rgba(255, 197, 0, 0.15)';\n    ctx.fillRect(govPanelX, govPanelY, govPanelW, govPanelH);\n    ctx.strokeStyle = 'rgba(255, 197, 0, 0.3)';\n    ctx.strokeRect(govPanelX + 0.5, govPanelY + 0.5, govPanelW - 1, govPanelH - 1);\n\n    // Regierungspanel Titel\n    ctx.fillStyle = 'rgba(255, 197, 0, 0.9)';\n    ctx.font = 'bold 12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Regierung', govPanelX + govPanelW/2, govPanelY + 16);\n\n    // SchlÃ¼sselwÃ¶rter auflisten\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    if (keywords.length > 0) {\n      keywords.forEach((keyword, idx) => {\n        ctx.fillText(`â€¢ ${keyword}`, govPanelX + 8, govPanelY + 36 + idx * 16);\n      });\n    } else {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\n      ctx.fillText('Keine aktiven', govPanelX + 8, govPanelY + 36);\n      ctx.fillText('SchlÃ¼sselwÃ¶rter', govPanelX + 8, govPanelY + 52);\n    }\n\n    // Panel fÃ¼r Ã–ffentlichkeits-Unterkategorien (rechts neben Ã–ffentlichkeitsslots)\n    const pubPanelX = 1640 + 256 + 20;\n    const pubPanelY = 580; // Auf HÃ¶he der Ã–ffentlichkeitsslots\n    const pubPanelW = 120;\n    const pubPanelH = 256;\n\n    // Ã–ffentlichkeitspanel Hintergrund\n    ctx.fillStyle = 'rgba(0, 255, 0, 0.15)';\n    ctx.fillRect(pubPanelX, pubPanelY, pubPanelW, pubPanelH);\n    ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';\n    ctx.strokeRect(pubPanelX + 0.5, pubPanelY + 0.5, pubPanelW - 1, pubPanelH - 1);\n\n    // Ã–ffentlichkeitspanel Titel\n    ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';\n    ctx.font = 'bold 12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Ã–ffentlichkeit', pubPanelX + pubPanelW/2, pubPanelY + 16);\n\n    // Unterkategorien auflisten\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    if (subcategories.length > 0) {\n      subcategories.forEach((subcategory, idx) => {\n        const displayName = subcategory.length > 12 ? subcategory.substring(0, 10) + '...' : subcategory;\n        ctx.fillText(`â€¢ ${displayName}`, pubPanelX + 8, pubPanelY + 36 + idx * 16);\n      });\n    } else {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\n      ctx.fillText('Keine aktiven', pubPanelX + 8, pubPanelY + 36);\n      ctx.fillText('Unterkategorien', pubPanelX + 8, pubPanelY + 52);\n    }\n  }, [getActiveKeywordsAndSubcategories]);\n\n  // Move diagnostics to draw callback to ensure they run after canvas is actually rendered\n  const runDiagnostics = useCallback(() => {\n    try {\n      const handZones = clickZonesRef.current.filter(z => z.data && z.data.type === 'hand_p1');\n      const uiUIDs = handZones.map(z => (z.data.card && (z.data.card.uid ?? z.data.card.id)) ).filter(Boolean);\n      const stateHand = gameState.hands && gameState.hands[1] ? gameState.hands[1] : [];\n      const stateUIDs = stateHand.map((c: any) => c.uid ?? c.id).filter(Boolean);\n\n      const missingInState = uiUIDs.filter((u: any) => !stateUIDs.includes(u));\n      const missingInUI = stateUIDs.filter((u: any) => !uiUIDs.includes(u));\n\n      // Only warn if there are cards in UI that don't exist in state (real error)\n      // Don't warn about missing UI cards due to limited slot capacity\n      if (missingInState.length > 0) {\n        const mismatch = {\n          ts: Date.now(),\n          uiCount: uiUIDs.length,\n          stateCount: stateUIDs.length,\n          uiUIDs,\n          stateUIDs,\n          missingInState,\n          missingInUI,\n          stack: (new Error('mismatch-stack')).stack\n        };\n        (window as any).__politicardDebug = {\n          ...(window as any).__politicardDebug,\n          mismatch: [ ...(window as any).__politicardDebug?.mismatch || [] ].slice(-19).concat([mismatch])\n        };\n        // Clear, then log to console so user can copy/paste trace\n        console.warn('POLITICARD DIAGNOSTIC: hand mismatch detected', mismatch);\n      }\n    } catch (e) {\n      // swallow diagnostic errors to avoid breaking rendering\n      console.error('Diagnostic error', e);\n    }\n  }, [gameState.hands]);\n\n  const draw = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Detect influence increases and start animations\n    try {\n      const currSnapshot: Record<string, number> = {};\n      const collect = (c: any) => {\n        if (!c) return;\n        if ((c as any).kind !== 'pol') return;\n        const uid = c.uid ?? (c.id != null ? String(c.id) : null);\n        if (!uid) return;\n        currSnapshot[uid] = (c.influence ?? 0) as number;\n      };\n      // board rows\n      (gameState.board[1].aussen || []).forEach(collect);\n      (gameState.board[2].aussen || []).forEach(collect);\n      (gameState.board[1].innen || []).forEach(collect);\n      (gameState.board[2].innen || []).forEach(collect);\n      // permanent slots\n      collect(gameState.permanentSlots[1].government as any);\n      collect(gameState.permanentSlots[2].government as any);\n      collect(gameState.permanentSlots[1].public as any);\n      collect(gameState.permanentSlots[2].public as any);\n\n      const now = performance.now();\n      Object.keys(currSnapshot).forEach(uid => {\n        const curr = currSnapshot[uid] ?? 0;\n        const prev = prevInfluencesRef.current[uid] ?? curr;\n        if (curr > prev) {\n          const delta = curr - prev;\n          const list = influenceAnimRef.current.get(uid) || [];\n          list.push({ start: now, duration: 900, amount: delta });\n          influenceAnimRef.current.set(uid, list);\n        }\n        prevInfluencesRef.current[uid] = curr;\n      });\n    } catch (e) {\n      // ignore\n    }\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Clear click zones\n    clickZonesRef.current = [];\n\n    // Background: prefer PNG if configured\n    if (LAYOUT.background?.enabled && LAYOUT.background?.src) {\n      if (backgroundImageRef.current) {\n        ctx.drawImage(backgroundImageRef.current, 0, 0, canvas.width, canvas.height);\n      } else {\n        ctx.fillStyle = '#0c131b';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n      }\n    } else {\n      ctx.fillStyle = '#0c131b';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Apply UI transform (new signature)\n    const { scale, offsetX, offsetY } = getUiTransform(canvas.width, canvas.height);\n    ctx.save();\n    ctx.translate(offsetX, offsetY);\n    ctx.scale(scale, scale);\n\n    // Draw opponent board (top rows) - clickable im Dev Mode\n    // Draw opponent board using new layout system\n    const opponentPublicRects = getPublicRects('opponent');\n    const opponentGovRects = getGovernmentRects('opponent');\n\n    // Draw opponent public slots\n    opponentPublicRects.forEach((s: { x: number; y: number; w: number; h: number }, idx: number) => {\n      const card = gameState.board[2].innen[idx];\n      if (card) {\n        drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 2);\n      }\n      else {\n        // draw placeholder symbol for empty public slot\n        const img = slotSymbolImgsRef.current.get('public');\n        if (img && img.complete) ctx.drawImage(img, s.x, s.y, s.w, s.h);\n      }\n    });\n\n    // Draw opponent government slots\n    opponentGovRects.forEach((s: { x: number; y: number; w: number; h: number }, idx: number) => {\n      const card = gameState.board[2].aussen[idx];\n      if (card) {\n        drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 2);\n      }\n      else {\n        const img = slotSymbolImgsRef.current.get('government');\n        if (img && img.complete) ctx.drawImage(img, s.x, s.y, s.w, s.h);\n      }\n    });\n\n    // Draw opponent permanent slots\n    drawPermanentSlotsP2(ctx);\n\n    // Draw player board (middle rows)\n    // Draw player board using new layout system\n    const playerPublicRects = getPublicRects('player');\n    const playerGovRects = getGovernmentRects('player');\n\n    // Draw player public slots\n    playerPublicRects.forEach((s: { x: number; y: number; w: number; h: number }, idx: number) => {\n      const card = gameState.board[1].innen[idx];\n      if (card) {\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 1);\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: { type: 'row_slot', player: 1, lane: 'innen', index: idx }\n        });\n      } else {\n        // Empty slot click zone and draw public symbol\n        // Draw unified pulsing icon for empty public slot\n        const img = slotSymbolImgsRef.current.get('public');\n        drawSlotIconWithPulse(ctx, img, s.x, s.y, s.w, s.h, 0.4);\n        clickZonesRef.current.push({\n          x: s.x, y: s.y, w: s.w, h: s.h,\n          data: { type: 'row_slot', player: 1, lane: 'innen', index: idx }\n        });\n      }\n    });\n\n    // Draw player government slots\n    playerGovRects.forEach((s: { x: number; y: number; w: number; h: number }, idx: number) => {\n      const card = gameState.board[1].aussen[idx];\n      if (card) {\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 1);\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: { type: 'row_slot', player: 1, lane: 'aussen', index: idx }\n        });\n      } else {\n        // Empty slot click zone and draw government symbol\n        const img = slotSymbolImgsRef.current.get('government');\n        drawSlotIconWithPulse(ctx, img, s.x, s.y, s.w, s.h, 0.1);\n        clickZonesRef.current.push({\n          x: s.x, y: s.y, w: s.w, h: s.h,\n          data: { type: 'row_slot', player: 1, lane: 'aussen', index: idx }\n        });\n      }\n    });\n\n    // Draw player permanent slots (draw symbols if empty)\n    // permanent government\n    const permGovZone = getZone('slot.permanent.government.player');\n    if (permGovZone) {\n      const card = gameState.permanentSlots[1].government;\n      const [x, y, w, h] = permGovZone.rectPx;\n      if (card) {\n        drawSingleSlot(ctx, 'slot.permanent.government.player', card, 'permanent_government', 1);\n      } else {\n        // Draw all slot icons using unified helper (so 'dauerhaft' used visually for empty permanent gov slot)\n        const img = slotSymbolImgsRef.current.get('dauerhaft');\n        drawSlotIconWithPulse(ctx, img, x, y, w, h, 0.2);\n      }\n    }\n    // permanent public\n    const permPubZone = getZone('slot.permanent.public.player');\n    if (permPubZone) {\n      const card = gameState.permanentSlots[1].public;\n      const [x2, y2, w2, h2] = permPubZone.rectPx;\n      if (card) {\n        drawSingleSlot(ctx, 'slot.permanent.public.player', card, 'permanent_public', 1);\n      } else {\n        // Draw all slot icons using unified helper (so 'dauerhaft' used visually for empty permanent public slot)\n        const img = slotSymbolImgsRef.current.get('dauerhaft');\n        drawSlotIconWithPulse(ctx, img, x2, y2, w2, h2, 0.9);\n      }\n    }\n\n    // Draw instant slots (both players) and placeholder if empty\n    const instantPlayerZone = getZone('slot.instant.player');\n    if (instantPlayerZone) {\n      const card = gameState.board[1].sofort[0];\n      const [x, y, w, h] = instantPlayerZone.rectPx;\n      if (card) drawSingleSlot(ctx, 'slot.instant.player', card, 'instant', 1);\n      else {\n        // Use unified icon draw helper for instant slot\n        const img = slotSymbolImgsRef.current.get('sofort');\n        drawSlotIconWithPulse(ctx, img, x, y, w, h, 0.0);\n      }\n    }\n\n    // Draw interventions strip (player)\n    // We draw symbol if empty\n    const interventionsZone = getZone('interventions.player');\n    if (interventionsZone) {\n      const [zx, zy, zw, zh] = interventionsZone.rectPx;\n      const card = gameState.traps[1] && gameState.traps[1][0];\n      if (card) drawInterventionsP1(ctx);\n      else {\n        const img = slotSymbolImgsRef.current.get('intervention');\n        drawSlotIconWithPulse(ctx, img, zx, zy, zw, zh, 0.6);\n      }\n    }\n\n    // Draw interventions strip (opponent) - nur im Dev Mode\n    if (devMode) {\n      drawInterventionsP2(ctx);\n    }\n\n    // Draw hand (P1)\n    drawHandP1(ctx);\n\n    // ðŸ”§ DEV MODE: Draw hand (P2) - nur im Dev Mode\n    if (devMode) {\n      drawHandP2(ctx);\n    }\n\n    // Draw info panels\n    drawInfoPanels(ctx);\n\n    // --- VISUAL EFFECTS: Particle bursts, card pop scale, initiative ripple & AP pop ---\n    try {\n      const now = performance.now();\n\n      const reducedMotion = !!((window as any).__pc_reduced_motion) || (typeof window !== 'undefined' && (window as any).matchMedia && (window as any).matchMedia('(prefers-reduced-motion: reduce)').matches);\n\n      // Particle bursts stored temporarily on window for prototyping: window.__pc_particles = Array<{x,y, vx, vy, life, size, color}>\n      const parts: any[] = (window as any).__pc_particles || [];\n      // Skip heavy visuals when reduced motion is requested\n      if (!reducedMotion) {\n      // Update & draw particles\n      for (let i = parts.length - 1; i >= 0; i--) {\n        const p = parts[i];\n        const age = now - p.start;\n        if (age > p.life) {\n          parts.splice(i, 1);\n          continue;\n        }\n        // integrate\n        p.vy += (p.gravity || 0.09);\n        p.x += p.vx;\n        p.y += p.vy;\n        const t = 1 - age / p.life;\n        ctx.save();\n        ctx.globalAlpha = Math.max(0, Math.min(1, t));\n        ctx.fillStyle = p.color || '#ffd166';\n        ctx.beginPath();\n        ctx.arc(p.x, p.y, (p.size || 4) * t, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.restore();\n      }\n        // persist mutated array\n        (window as any).__pc_particles = parts;\n\n        // Card pop scales: window.__pc_pops = Array<{uid, started, duration, cx, cy, maxScale}>\n        const pops: any[] = (window as any).__pc_pops || [];\n        pops.forEach((pop) => {\n          const p = Math.min(1, Math.max(0, (now - pop.started) / pop.duration));\n          const eased = 1 + 0.12 * (1 - Math.pow(1 - p, 3));\n          // find card zone\n          const zone = clickZonesRef.current.find(z => z.data && z.data.card && ((z.data.card.uid ?? String(z.data.card.id)) === pop.uid));\n          if (!zone) return;\n          // draw a translucent scale overlay\n          ctx.save();\n          ctx.translate(zone.x + zone.w / 2, zone.y + zone.h / 2);\n          ctx.scale(eased, eased);\n          ctx.globalAlpha = 0.12 * (1 - p);\n          ctx.fillStyle = '#ffffff';\n          ctx.fillRect(-zone.w / 2, -zone.h / 2, zone.w, zone.h);\n          ctx.restore();\n        });\n\n        // Initiative ripple overlays: window.__pc_ripples = Array<{cx,cy, started, duration, radius}>\n        const ripples: any[] = (window as any).__pc_ripples || [];\n        for (let i = ripples.length - 1; i >= 0; i--) {\n          const r = ripples[i];\n          const p = Math.min(1, Math.max(0, (now - r.started) / r.duration));\n          if (p >= 1) { ripples.splice(i, 1); continue; }\n          const radius = r.radius * (0.8 + 1.8 * p);\n          ctx.save();\n          // soft radial gradient\n          const g = ctx.createRadialGradient(r.cx, r.cy, radius * 0.1, r.cx, r.cy, radius);\n          g.addColorStop(0, `rgba(255,255,255,${0.12 * (1 - p)})`);\n          g.addColorStop(1, `rgba(255,255,255,0)`);\n          ctx.fillStyle = g as any;\n          ctx.beginPath();\n          ctx.arc(r.cx, r.cy, radius, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.restore();\n\n          // AP pop: spawn temporary +1 label at r.apX/apY\n          if (r.showAp && !r._apSpawned) {\n            (window as any).__pc_aplabels = (window as any).__pc_aplabels || [];\n            (window as any).__pc_aplabels.push({ x: r.apX, y: r.apY, started: now, duration: 800, text: '+1' });\n            r._apSpawned = true;\n          }\n        }\n        (window as any).__pc_ripples = ripples;\n\n        // Draw AP labels\n        const apl: any[] = (window as any).__pc_aplabels || [];\n        for (let i = apl.length - 1; i >= 0; i--) {\n          const l = apl[i];\n          const p = Math.min(1, Math.max(0, (now - l.started) / l.duration));\n          if (p >= 1) { apl.splice(i, 1); continue; }\n          ctx.save();\n          ctx.globalAlpha = 1 - p;\n          ctx.fillStyle = '#ffdd57';\n          ctx.font = 'bold 22px sans-serif';\n          ctx.textAlign = 'center';\n          ctx.fillText(l.text, l.x, l.y - 20 * p);\n          ctx.restore();\n        }\n        (window as any).__pc_aplabels = apl;\n      } else {\n        // Reduced motion: still draw AP labels minimally if present\n        const apl: any[] = (window as any).__pc_aplabels || [];\n        for (let i = apl.length - 1; i >= 0; i--) {\n          const l = apl[i];\n          const p = Math.min(1, Math.max(0, (now - l.started) / l.duration));\n          if (p >= 1) { apl.splice(i, 1); continue; }\n          ctx.save();\n          ctx.globalAlpha = 1 - p;\n          ctx.fillStyle = '#ffdd57';\n          ctx.font = 'bold 18px sans-serif';\n          ctx.textAlign = 'center';\n          ctx.fillText(l.text, l.x, l.y - 10 * p);\n          ctx.restore();\n        }\n        (window as any).__pc_aplabels = apl;\n      }\n    } catch (e) {}\n\n    // --- Overlay pass: draw influence pulse ring and +N labels on top of all cards ---\n    try {\n      const now = performance.now();\n      // iterate over stored anims\n      influenceAnimRef.current.forEach((anims, uid) => {\n        // find card position by scanning clickZones\n        const zone = clickZonesRef.current.find(z => z.data && ((z.data.card && ((z.data.card.uid ?? String(z.data.card.id)) === uid)) || (z.data.card && z.data.card.uid === uid)) );\n        if (!zone) return;\n        const cx = zone.x + zone.w / 2;\n        const cy = zone.y + zone.h / 2;\n        // calculate aggregate pulse for this uid\n        let maxPulse = 0;\n        let totalAmount = 0;\n        const remaining: Array<{ start: number; duration: number; amount: number }> = [];\n        anims.forEach(a => {\n          const p = Math.min(1, Math.max(0, (now - a.start) / a.duration));\n          const pulse = Math.pow(Math.max(0, 1 - p), 2);\n          if (pulse > maxPulse) maxPulse = pulse;\n          if (p < 1) {\n            remaining.push(a);\n            totalAmount += a.amount;\n          }\n        });\n\n        // update list\n        if (remaining.length > 0) influenceAnimRef.current.set(uid, remaining);\n        else influenceAnimRef.current.delete(uid);\n\n        if (maxPulse > 0.001) {\n          // draw a soft ring to the right-bottom of influence number\n          const ringRadius = Math.max(8, zone.w * 0.08) * (1 + maxPulse * 0.6);\n          const ringX = zone.x + zone.w - 28; // near bottom-right where influence text lives\n          const ringY = zone.y + zone.h - 20;\n\n          ctx.save();\n          ctx.beginPath();\n          ctx.strokeStyle = `rgba(46, 204, 113, ${0.9 * maxPulse})`;\n          ctx.lineWidth = Math.max(2, Math.ceil(6 * maxPulse));\n          ctx.arc(ringX, ringY, ringRadius, 0, Math.PI * 2);\n          ctx.stroke();\n          ctx.restore();\n        }\n\n        if (totalAmount > 0) {\n          // floating +N to the right of influence number\n          const labelX = zone.x + zone.w - 12;\n          const labelY = zone.y + zone.h - 32 - (Math.random() * 6); // slight jitter\n          ctx.save();\n          ctx.fillStyle = '#2ecc71';\n          ctx.font = 'bold 16px sans-serif';\n          ctx.textAlign = 'left';\n          ctx.textBaseline = 'middle';\n          ctx.fillText(`+${totalAmount}`, labelX, labelY);\n          ctx.restore();\n        }\n      });\n    } catch (e) {\n      // ignore overlay errors\n    }\n\n    // --- Outline pass: draw a subtle, slightly pulsing 257x257 square around 256x256 slots ---\n    try {\n      const now2 = performance.now();\n      clickZonesRef.current.forEach((z, i) => {\n        if (!z) return;\n        const w = z.w || 0;\n        const h = z.h || 0;\n        // only target 256x256 slot-sized zones (covers the icons)\n        if (Math.abs(w - 256) > 0.1 || Math.abs(h - 256) > 0.1) return;\n        const x = z.x;\n        const y = z.y;\n\n        // Color palette (rgb)\n        const rgbTeal = '20,184,166';\n        const rgbBurg = '127,29,29';\n        const rgbPurple = '139,92,246';\n        const rgbYellow = '250,204,21';\n        const rgbOrange = '251,146,60';\n\n        // Determine slot semantic\n        let slotType: 'government' | 'public' | 'permanent' | 'instant' | 'intervention' | 'default' = 'default';\n        try {\n          const dt = z.data || {};\n          if (dt.slot && typeof dt.slot === 'string') {\n            if (dt.slot.includes('government')) slotType = 'government';\n            else if (dt.slot.includes('public')) slotType = 'public';\n            else if (dt.slot.includes('permanent')) slotType = 'permanent';\n            else if (dt.slot.includes('instant')) slotType = 'instant';\n          }\n          if (dt.type === 'row_slot' && dt.lane === 'aussen') slotType = 'government';\n          if (dt.type === 'row_slot' && dt.lane === 'innen') slotType = 'public';\n          if (dt.type === 'trap_p1' || dt.type === 'trap_p2' || (dt.card && dt.card.kind === 'trap')) slotType = 'intervention';\n          if (dt.type === 'activate_instant' || dt.slot === 'instant') slotType = 'instant';\n          if (dt.slot === 'permanent_government' || dt.slot === 'permanent_public' || dt.slot === 'permanent') slotType = 'permanent';\n        } catch (e) {}\n\n        const pulse = 0.5 + 0.5 * Math.sin(now2 / 350 + i);\n        const alpha = 0.06 + 0.12 * pulse; // subtle alpha\n        const lw = 1 + 2 * pulse; // line width between 1 and 3\n\n        // Create gradient based on slot type\n        let grad: CanvasGradient | null = null;\n        try {\n          grad = ctx.createLinearGradient(x, y, x + w, y + h);\n          if (slotType === 'government') {\n            grad.addColorStop(0, `rgba(${rgbTeal},1)`);\n            grad.addColorStop(1, `rgba(${rgbBurg},1)`);\n          } else if (slotType === 'public') {\n            grad.addColorStop(0, `rgba(${rgbBurg},1)`);\n            grad.addColorStop(1, `rgba(${rgbTeal},1)`);\n          } else if (slotType === 'permanent') {\n            grad.addColorStop(0, `rgba(${rgbPurple},1)`);\n            grad.addColorStop(1, `rgba(${rgbPurple},1)`);\n          } else if (slotType === 'instant') {\n            grad.addColorStop(0, `rgba(${rgbYellow},1)`);\n            grad.addColorStop(1, `rgba(${rgbYellow},1)`);\n          } else if (slotType === 'intervention') {\n            grad.addColorStop(0, `rgba(${rgbOrange},1)`);\n            grad.addColorStop(1, `rgba(${rgbOrange},1)`);\n          } else {\n            grad.addColorStop(0, `rgba(255,255,255,1)`);\n            grad.addColorStop(1, `rgba(255,255,255,1)`);\n          }\n        } catch (e) {\n          grad = null;\n        }\n\n        ctx.save();\n        if (grad) ctx.strokeStyle = grad as any;\n        else ctx.strokeStyle = `rgba(255,255,255,${alpha.toFixed(3)})`;\n        ctx.globalAlpha = alpha;\n        ctx.lineWidth = lw;\n        // draw 257x257 centered so that it encloses the 256 slot\n        ctx.strokeRect(x - 0.5, y - 0.5, w + 1, h + 1);\n        ctx.restore();\n      });\n    } catch (e) {\n      // ignore outline errors\n    }\n\n    ctx.restore();\n\n    // expose zones for debug snapshot\n    (window as any).__politicardDebug = {\n      uiTransform: getUiTransform(canvas.width, canvas.height),\n      canvasSize: { width: canvas.width, height: canvas.height },\n      zones: LAYOUT.zones,\n      clickZones: clickZonesRef.current.slice(0, 1000)\n    };\n\n    // Run diagnostics after canvas is fully rendered\n    runDiagnostics();\n  }, [drawLane, drawHandP1, drawHandP2, drawInterventionsP1, drawInterventionsP2, drawPermanentSlotsP1, drawPermanentSlotsP2, drawInstantSlots, drawInfoPanels, devMode, runDiagnostics]);\n\n  const DRAW_LAYOUT_OVERLAY = false; // force off per new layout system\n\n  // Load slot symbol images once\n  useEffect(() => {\n    const load = (key: string, src: string) => {\n      const img = new Image();\n      img.onload = () => { slotSymbolImgsRef.current.set(key, img); };\n      img.onerror = () => { console.warn('Failed to load slot icon', src); };\n      img.src = src;\n    };\n    load('public', publicSymbolUrl);\n    load('sofort', sofortSymbolUrl);\n    load('dauerhaft', dauerhaftSymbolUrl);\n    load('government', governmentSymbolUrl);\n    load('intervention', interventionSymbolUrl);\n\n    // ensure first draw\n    requestAnimationFrame(draw);\n  }, [draw]);\n\n  // Redraw when game state or selection changes\n  useEffect(() => {\n    requestAnimationFrame(draw);\n  }, [gameState, selectedHandIndex, draw]);\n\n  // Continuous render loop to keep canvas updated without relying on external state refs\n  useEffect(() => {\n    let frame: number;\n    const loop = () => {\n      draw();\n      frame = requestAnimationFrame(loop);\n    };\n    frame = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(frame);\n  }, [draw]);\n\n  const handleCardClick = useCallback((data: any) => {\n    // Hand-Klick\n    if (data.type === 'hand_p1') {\n      const uid = data.card?.uid ?? data.card?.id;\n      const stateHand = gameState.hands?.[1] || [];\n      const idxInState = stateHand.findIndex((c: any) => (c.uid ?? c.id) === uid);\n      onCardClick(data);\n      return;\n    }\n\n    // Slot-Klick\n    if (data.type === 'row_slot') {\n      const lane: 'public' | 'government' = data.lane;\n      const cap = getLaneCapacity(lane);\n\n      // Hole aktuelle Row-LÃ¤nge aus gameState\n      const rowCards = lane === 'public'\n        ? gameState.board?.[1]?.innen ?? []\n        : gameState.board?.[1]?.aussen ?? [];\n\n      if (rowCards.length >= cap) {\n        // Optional: UI Feedback\n        console.warn(`Row ${lane} is full (${rowCards.length}/${cap})`);\n        return;\n      }\n\n      onCardClick(data);\n      return;\n    }\n\n    // Andere Klicks (empty_slot, board_card, etc.)\n    onCardClick(data);\n  }, [gameState, onCardClick]);\n\n  const handleClick = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const { scale, offsetX, offsetY } = getUiTransform(canvas.width, canvas.height);\n    const mx = (e.clientX - rect.left - offsetX) / scale;\n    const my = (e.clientY - rect.top - offsetY) / scale;\n\n    const hit = clickZonesRef.current.find(z => mx >= z.x && mx <= z.x + z.w && my >= z.y && my <= z.y + z.h);\n    if (hit) handleCardClick(hit.data);\n  }, [handleCardClick]);\n\n  const handleMouseMove = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const { scale, offsetX, offsetY } = getUiTransform(canvas.width, canvas.height);\n    const mx = (e.clientX - rect.left - offsetX) / scale;\n    const my = (e.clientY - rect.top - offsetY) / scale;\n\n    const hit = clickZonesRef.current.find(z => mx >= z.x && mx <= z.x + z.w && my >= z.y && my <= z.y + z.h);\n    if (hit) {\n      console.log('[hover]', hit.data.type, hit.data.card?.name);\n      onCardHover({ ...hit.data, x: e.clientX, y: e.clientY });\n    } else {\n      onCardHover(null);\n    }\n  }, [onCardHover]);\n\n  const handleWheel = useCallback((e: React.WheelEvent<HTMLCanvasElement>) => {\n    // only enable when player1 has more slots than visible\n    const handLen = (gameState.hands && gameState.hands[1]) ? gameState.hands[1].length : 0;\n    const zone = getZone('hand.player');\n    if (!zone) return;\n    if (handLen <= 5) return; // nothing to scroll\n\n    // Prevent page scrolling when over canvas\n    e.preventDefault();\n\n    // accumulate target offset (invert so wheel down moves cards up)\n    // Each wheel step moves by 48px per delta unit\n    const delta = Math.sign(e.deltaY) * 48;\n    // compute slot height more robustly\n    const slots = computeSlotRects(zone);\n    const slotH = slots && slots.length > 0 ? slots[0].h : zone.rectPx[3] / 5;\n    const visible = 5;\n    const maxOffset = -(Math.max(0, handLen - visible) * slotH);\n    handScrollTargetRef.current = Math.max(Math.min(handScrollTargetRef.current - delta, 0), maxOffset);\n  }, [gameState.hands]);\n\n  const handleTouchStart = useCallback((e: React.TouchEvent<HTMLCanvasElement>) => {\n    if (!e.touches || e.touches.length === 0) return;\n    const handLen = (gameState.hands && gameState.hands[1]) ? gameState.hands[1].length : 0;\n    if (handLen <= 5) return;\n    isTouchingRef.current = true;\n    const y = e.touches[0].clientY;\n    touchStartYRef.current = y;\n    lastTouchYRef.current = y;\n    e.preventDefault();\n  }, [gameState.hands]);\n\n  const handleTouchMove = useCallback((e: React.TouchEvent<HTMLCanvasElement>) => {\n    if (!isTouchingRef.current) return;\n    if (!e.touches || e.touches.length === 0) return;\n    const y = e.touches[0].clientY;\n    const last = lastTouchYRef.current ?? y;\n    const dy = y - last; // positive when moving down\n    lastTouchYRef.current = y;\n\n    // invert so dragging up moves cards up\n    const delta = -dy;\n    const handLen = (gameState.hands && gameState.hands[1]) ? gameState.hands[1].length : 0;\n    const zone = getZone('hand.player');\n    if (!zone) return;\n    const slots = computeSlotRects(zone);\n    const slotH = slots && slots.length > 0 ? slots[0].h : zone.rectPx[3] / 5;\n    const visible = 5;\n    const maxOffset = -(Math.max(0, handLen - visible) * slotH);\n    handScrollTargetRef.current = Math.max(Math.min(handScrollTargetRef.current + delta, 0), maxOffset);\n    e.preventDefault();\n  }, [gameState.hands]);\n\n  const handleTouchEnd = useCallback((e: React.TouchEvent<HTMLCanvasElement>) => {\n    isTouchingRef.current = false;\n    touchStartYRef.current = null;\n    lastTouchYRef.current = null;\n  }, []);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      width={1920}\n      height={1080}\n      style={{\n        display: 'block',\n        width: '100%',\n        height: '100%',\n        imageRendering: 'auto',\n      }}\n      onClick={handleClick}\n      onMouseMove={handleMouseMove}\n      onWheel={handleWheel}\n      onTouchStart={handleTouchStart}\n      onTouchMove={handleTouchMove}\n      onTouchEnd={handleTouchEnd}\n    />\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}