{"ast":null,"code":"import _objectSpread from\"C:/Users/skank/Videos/Cards/Milchcards/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// Character System - State Management und Facing Logic\n// Erweitert die Animation Engine um Character-spezifische Logik\nimport{getFrameHitboxes}from'../data/animationRegistry';export class CharacterSystem{constructor(){this.characters=new Map();this.hurtboxes=new Map();}// === CHARACTER STATE MANAGEMENT ===\ncreateCharacter(id,position){let facing=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;const character={id,position:_objectSpread({},position),facing,currentAnimation:'idle',animationFrame:0,animationTime:0};this.characters.set(id,character);return character;}getCharacter(id){return this.characters.get(id);}updateCharacterPosition(id,position){const character=this.characters.get(id);if(character){character.position=_objectSpread({},position);}}setCharacterFacing(id,facing){const character=this.characters.get(id);if(character){character.facing=facing;}}// === FACING LOGIC ===\n// Berechnet Facing basierend auf Position relativ zu einem Ziel\ncalculateFacingToTarget(characterId,targetPosition){const character=this.characters.get(characterId);if(!character)return 1;return targetPosition.x>character.position.x?1:-1;}// Setzt Facing automatisch basierend auf Bewegung\nupdateFacingFromMovement(characterId,velocity){if(Math.abs(velocity.x)>0.1){// Deadzone für kleine Bewegungen\nthis.setCharacterFacing(characterId,velocity.x>0?1:-1);}}// === HITBOX/HURTBOX SYSTEM ===\n// Aktualisiert Hurtboxen basierend auf aktueller Animation und Frame\nupdateHurtboxes(characterId,animationName,frame){const hitboxes=getFrameHitboxes(animationName,frame);const hurtboxes=hitboxes.filter(hitbox=>hitbox.type==='hurt').map(hitbox=>this.transformHitboxToWorldSpace(characterId,hitbox.bounds));this.hurtboxes.set(characterId,hurtboxes);}// Transformiert Hitbox von Sprite-Space zu World-Space\ntransformHitboxToWorldSpace(characterId,bounds){const character=this.characters.get(characterId);if(!character)return bounds;// Berücksichtigt Facing für X-Koordinaten\nconst facingMultiplier=character.facing;return{x:character.position.x+bounds.x*facingMultiplier,y:character.position.y+bounds.y,width:bounds.width,height:bounds.height};}// Prüft Kollision zwischen zwei BoundingBoxen\ncheckCollision(box1,box2){return!(box1.x+box1.width<box2.x||box2.x+box2.width<box1.x||box1.y+box1.height<box2.y||box2.y+box2.height<box1.y);}// Prüft Kollision zwischen Character und einem Punkt\ncheckPointCollision(characterId,point){const hurtboxes=this.hurtboxes.get(characterId)||[];return hurtboxes.some(hurtbox=>point.x>=hurtbox.x&&point.x<=hurtbox.x+hurtbox.width&&point.y>=hurtbox.y&&point.y<=hurtbox.y+hurtbox.height);}// Prüft Kollision zwischen zwei Characters\ncheckCharacterCollision(characterId1,characterId2){const hurtboxes1=this.hurtboxes.get(characterId1)||[];const hurtboxes2=this.hurtboxes.get(characterId2)||[];for(const box1 of hurtboxes1){for(const box2 of hurtboxes2){if(this.checkCollision(box1,box2)){return true;}}}return false;}// === ANIMATION STATE HELPERS ===\n// Prüft ob Character in einer bestimmten Animation ist\nisInAnimation(characterId,animationName){const character=this.characters.get(characterId);return(character===null||character===void 0?void 0:character.currentAnimation)===animationName;}// Prüft ob Character in einem bestimmten Frame ist\nisInFrame(characterId,frame){const character=this.characters.get(characterId);return(character===null||character===void 0?void 0:character.animationFrame)===frame;}// Prüft ob Character in einem Frame-Bereich ist\nisInFrameRange(characterId,startFrame,endFrame){const character=this.characters.get(characterId);if(!character)return false;return character.animationFrame>=startFrame&&character.animationFrame<=endFrame;}// === MOVEMENT HELPERS ===\n// Bewegt Character in eine Richtung\nmoveCharacter(characterId,direction,speed){const character=this.characters.get(characterId);if(!character)return;// Normalisiere Richtung\nconst length=Math.sqrt(direction.x*direction.x+direction.y*direction.y);if(length===0)return;const normalizedDirection={x:direction.x/length,y:direction.y/length};// Update Position\ncharacter.position.x+=normalizedDirection.x*speed;character.position.y+=normalizedDirection.y*speed;// Update Facing basierend auf Bewegung\nthis.updateFacingFromMovement(characterId,normalizedDirection);}// Teleportiert Character zu einer Position\nteleportCharacter(characterId,position){const character=this.characters.get(characterId);if(character){character.position=_objectSpread({},position);}}// === UTILITY METHODS ===\n// Gibt alle Characters zurück\ngetAllCharacters(){return Array.from(this.characters.values());}// Gibt Characters in einem bestimmten Bereich zurück\ngetCharactersInArea(center,radius){return this.getAllCharacters().filter(character=>{const distance=Math.sqrt(Math.pow(character.position.x-center.x,2)+Math.pow(character.position.y-center.y,2));return distance<=radius;});}// Gibt den nächsten Character zu einer Position zurück\ngetNearestCharacter(position,excludeId){let nearest=null;let nearestDistance=Infinity;for(const character of this.getAllCharacters()){if(excludeId&&character.id===excludeId)continue;const distance=Math.sqrt(Math.pow(character.position.x-position.x,2)+Math.pow(character.position.y-position.y,2));if(distance<nearestDistance){nearest=character;nearestDistance=distance;}}return nearest;}// Entfernt Character aus dem System\nremoveCharacter(characterId){this.characters.delete(characterId);this.hurtboxes.delete(characterId);}// Leert das gesamte System\nclear(){this.characters.clear();this.hurtboxes.clear();}}","map":{"version":3,"names":["getFrameHitboxes","CharacterSystem","constructor","characters","Map","hurtboxes","createCharacter","id","position","facing","arguments","length","undefined","character","_objectSpread","currentAnimation","animationFrame","animationTime","set","getCharacter","get","updateCharacterPosition","setCharacterFacing","calculateFacingToTarget","characterId","targetPosition","x","updateFacingFromMovement","velocity","Math","abs","updateHurtboxes","animationName","frame","hitboxes","filter","hitbox","type","map","transformHitboxToWorldSpace","bounds","facingMultiplier","y","width","height","checkCollision","box1","box2","checkPointCollision","point","some","hurtbox","checkCharacterCollision","characterId1","characterId2","hurtboxes1","hurtboxes2","isInAnimation","isInFrame","isInFrameRange","startFrame","endFrame","moveCharacter","direction","speed","sqrt","normalizedDirection","teleportCharacter","getAllCharacters","Array","from","values","getCharactersInArea","center","radius","distance","pow","getNearestCharacter","excludeId","nearest","nearestDistance","Infinity","removeCharacter","delete","clear"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/engine/characterSystem.ts"],"sourcesContent":["// Character System - State Management und Facing Logic\r\n// Erweitert die Animation Engine um Character-spezifische Logik\r\n\r\nimport type {\r\n  CharacterState,\r\n  Vector2,\r\n  BoundingBox,\r\n  FrameHitbox\r\n} from '../types/animation';\r\nimport { getFrameHitboxes } from '../data/animationRegistry';\r\n\r\nexport class CharacterSystem {\r\n  private characters: Map<string, CharacterState> = new Map();\r\n  private hurtboxes: Map<string, BoundingBox[]> = new Map();\r\n\r\n  // === CHARACTER STATE MANAGEMENT ===\r\n\r\n  createCharacter(id: string, position: Vector2, facing: -1 | 1 = 1): CharacterState {\r\n    const character: CharacterState = {\r\n      id,\r\n      position: { ...position },\r\n      facing,\r\n      currentAnimation: 'idle',\r\n      animationFrame: 0,\r\n      animationTime: 0\r\n    };\r\n\r\n    this.characters.set(id, character);\r\n    return character;\r\n  }\r\n\r\n  getCharacter(id: string): CharacterState | undefined {\r\n    return this.characters.get(id);\r\n  }\r\n\r\n  updateCharacterPosition(id: string, position: Vector2): void {\r\n    const character = this.characters.get(id);\r\n    if (character) {\r\n      character.position = { ...position };\r\n    }\r\n  }\r\n\r\n  setCharacterFacing(id: string, facing: -1 | 1): void {\r\n    const character = this.characters.get(id);\r\n    if (character) {\r\n      character.facing = facing;\r\n    }\r\n  }\r\n\r\n  // === FACING LOGIC ===\r\n\r\n  // Berechnet Facing basierend auf Position relativ zu einem Ziel\r\n  calculateFacingToTarget(characterId: string, targetPosition: Vector2): -1 | 1 {\r\n    const character = this.characters.get(characterId);\r\n    if (!character) return 1;\r\n\r\n    return targetPosition.x > character.position.x ? 1 : -1;\r\n  }\r\n\r\n  // Setzt Facing automatisch basierend auf Bewegung\r\n  updateFacingFromMovement(characterId: string, velocity: Vector2): void {\r\n    if (Math.abs(velocity.x) > 0.1) { // Deadzone für kleine Bewegungen\r\n      this.setCharacterFacing(characterId, velocity.x > 0 ? 1 : -1);\r\n    }\r\n  }\r\n\r\n  // === HITBOX/HURTBOX SYSTEM ===\r\n\r\n  // Aktualisiert Hurtboxen basierend auf aktueller Animation und Frame\r\n  updateHurtboxes(characterId: string, animationName: string, frame: number): void {\r\n    const hitboxes = getFrameHitboxes(animationName, frame);\r\n    const hurtboxes = hitboxes\r\n      .filter(hitbox => hitbox.type === 'hurt')\r\n      .map(hitbox => this.transformHitboxToWorldSpace(characterId, hitbox.bounds));\r\n\r\n    this.hurtboxes.set(characterId, hurtboxes);\r\n  }\r\n\r\n  // Transformiert Hitbox von Sprite-Space zu World-Space\r\n  private transformHitboxToWorldSpace(characterId: string, bounds: BoundingBox): BoundingBox {\r\n    const character = this.characters.get(characterId);\r\n    if (!character) return bounds;\r\n\r\n    // Berücksichtigt Facing für X-Koordinaten\r\n    const facingMultiplier = character.facing;\r\n\r\n    return {\r\n      x: character.position.x + (bounds.x * facingMultiplier),\r\n      y: character.position.y + bounds.y,\r\n      width: bounds.width,\r\n      height: bounds.height\r\n    };\r\n  }\r\n\r\n  // Prüft Kollision zwischen zwei BoundingBoxen\r\n  checkCollision(box1: BoundingBox, box2: BoundingBox): boolean {\r\n    return !(\r\n      box1.x + box1.width < box2.x ||\r\n      box2.x + box2.width < box1.x ||\r\n      box1.y + box1.height < box2.y ||\r\n      box2.y + box2.height < box1.y\r\n    );\r\n  }\r\n\r\n  // Prüft Kollision zwischen Character und einem Punkt\r\n  checkPointCollision(characterId: string, point: Vector2): boolean {\r\n    const hurtboxes = this.hurtboxes.get(characterId) || [];\r\n\r\n    return hurtboxes.some(hurtbox =>\r\n      point.x >= hurtbox.x &&\r\n      point.x <= hurtbox.x + hurtbox.width &&\r\n      point.y >= hurtbox.y &&\r\n      point.y <= hurtbox.y + hurtbox.height\r\n    );\r\n  }\r\n\r\n  // Prüft Kollision zwischen zwei Characters\r\n  checkCharacterCollision(characterId1: string, characterId2: string): boolean {\r\n    const hurtboxes1 = this.hurtboxes.get(characterId1) || [];\r\n    const hurtboxes2 = this.hurtboxes.get(characterId2) || [];\r\n\r\n    for (const box1 of hurtboxes1) {\r\n      for (const box2 of hurtboxes2) {\r\n        if (this.checkCollision(box1, box2)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  // === ANIMATION STATE HELPERS ===\r\n\r\n  // Prüft ob Character in einer bestimmten Animation ist\r\n  isInAnimation(characterId: string, animationName: string): boolean {\r\n    const character = this.characters.get(characterId);\r\n    return character?.currentAnimation === animationName;\r\n  }\r\n\r\n  // Prüft ob Character in einem bestimmten Frame ist\r\n  isInFrame(characterId: string, frame: number): boolean {\r\n    const character = this.characters.get(characterId);\r\n    return character?.animationFrame === frame;\r\n  }\r\n\r\n  // Prüft ob Character in einem Frame-Bereich ist\r\n  isInFrameRange(characterId: string, startFrame: number, endFrame: number): boolean {\r\n    const character = this.characters.get(characterId);\r\n    if (!character) return false;\r\n\r\n    return character.animationFrame >= startFrame && character.animationFrame <= endFrame;\r\n  }\r\n\r\n  // === MOVEMENT HELPERS ===\r\n\r\n  // Bewegt Character in eine Richtung\r\n  moveCharacter(characterId: string, direction: Vector2, speed: number): void {\r\n    const character = this.characters.get(characterId);\r\n    if (!character) return;\r\n\r\n    // Normalisiere Richtung\r\n    const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y);\r\n    if (length === 0) return;\r\n\r\n    const normalizedDirection = {\r\n      x: direction.x / length,\r\n      y: direction.y / length\r\n    };\r\n\r\n    // Update Position\r\n    character.position.x += normalizedDirection.x * speed;\r\n    character.position.y += normalizedDirection.y * speed;\r\n\r\n    // Update Facing basierend auf Bewegung\r\n    this.updateFacingFromMovement(characterId, normalizedDirection);\r\n  }\r\n\r\n  // Teleportiert Character zu einer Position\r\n  teleportCharacter(characterId: string, position: Vector2): void {\r\n    const character = this.characters.get(characterId);\r\n    if (character) {\r\n      character.position = { ...position };\r\n    }\r\n  }\r\n\r\n  // === UTILITY METHODS ===\r\n\r\n  // Gibt alle Characters zurück\r\n  getAllCharacters(): CharacterState[] {\r\n    return Array.from(this.characters.values());\r\n  }\r\n\r\n  // Gibt Characters in einem bestimmten Bereich zurück\r\n  getCharactersInArea(center: Vector2, radius: number): CharacterState[] {\r\n    return this.getAllCharacters().filter(character => {\r\n      const distance = Math.sqrt(\r\n        Math.pow(character.position.x - center.x, 2) +\r\n        Math.pow(character.position.y - center.y, 2)\r\n      );\r\n      return distance <= radius;\r\n    });\r\n  }\r\n\r\n  // Gibt den nächsten Character zu einer Position zurück\r\n  getNearestCharacter(position: Vector2, excludeId?: string): CharacterState | null {\r\n    let nearest: CharacterState | null = null;\r\n    let nearestDistance = Infinity;\r\n\r\n    for (const character of this.getAllCharacters()) {\r\n      if (excludeId && character.id === excludeId) continue;\r\n\r\n      const distance = Math.sqrt(\r\n        Math.pow(character.position.x - position.x, 2) +\r\n        Math.pow(character.position.y - position.y, 2)\r\n      );\r\n\r\n      if (distance < nearestDistance) {\r\n        nearest = character;\r\n        nearestDistance = distance;\r\n      }\r\n    }\r\n\r\n    return nearest;\r\n  }\r\n\r\n  // Entfernt Character aus dem System\r\n  removeCharacter(characterId: string): void {\r\n    this.characters.delete(characterId);\r\n    this.hurtboxes.delete(characterId);\r\n  }\r\n\r\n  // Leert das gesamte System\r\n  clear(): void {\r\n    this.characters.clear();\r\n    this.hurtboxes.clear();\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}