{"ast":null,"code":"import { CARD_BY_ID } from '../data/cards';\nexport function registerTrap(state, player, key) {\n  if (!state.traps) state.traps = {\n    1: [],\n    2: []\n  };\n  const list = state.traps[player];\n  if (!Array.isArray(list)) state.traps[player] = [];\n  state.traps[player].push({\n    owner: player,\n    key\n  });\n}\nexport function applyTrapsOnCardPlayed(state, playedBy, card, enqueue, log) {\n  var _state$traps, _state$effectFlags$pl, _cardDef$tags, _cardDef$tags2;\n  const opp = playedBy === 1 ? 2 : 1;\n  const traps = (_state$traps = state.traps) === null || _state$traps === void 0 ? void 0 : _state$traps[opp];\n  if (!traps || traps.length === 0) return;\n\n  // Diagnostics: log existing traps for opponent when a card is played\n  try {\n    const keys = traps.map(t => t.key).join(', ');\n    enqueue({\n      type: 'LOG',\n      msg: `DEBUG: applyTrapsOnCardPlayed opp=${opp} traps=[${keys}] playedCard=${card.name || card.key || 'unknown'}`\n    });\n  } catch (e) {}\n\n  // Hard rule: Opposition Blockade â€“ if current player is locked, cancel initiative card immediately\n  if ((card === null || card === void 0 ? void 0 : card.type) === 'initiative' && (_state$effectFlags$pl = state.effectFlags[playedBy]) !== null && _state$effectFlags$pl !== void 0 && _state$effectFlags$pl.initiativesLocked) {\n    if (card.uid != null) {\n      enqueue({\n        type: 'CANCEL_CARD',\n        player: playedBy,\n        targetUid: card.uid\n      });\n    }\n    enqueue({\n      type: 'LOG',\n      msg: 'Blocked: initiatives are locked (Opposition Blockade).'\n    });\n    return; // skip further trap processing\n  }\n\n  // Get card definition to access type and tags\n  const cardDef = CARD_BY_ID[card.key];\n  const isInitiative = (cardDef === null || cardDef === void 0 ? void 0 : cardDef.type) === 'initiative';\n  const isPublic = (cardDef === null || cardDef === void 0 ? void 0 : cardDef.type) === 'public';\n  const isGovernment = (cardDef === null || cardDef === void 0 ? void 0 : cardDef.type) === 'government';\n  const isMediaLike = (cardDef === null || cardDef === void 0 ? void 0 : (_cardDef$tags = cardDef.tags) === null || _cardDef$tags === void 0 ? void 0 : _cardDef$tags.includes('Media')) || (cardDef === null || cardDef === void 0 ? void 0 : (_cardDef$tags2 = cardDef.tags) === null || _cardDef$tags2 === void 0 ? void 0 : _cardDef$tags2.includes('Platform')) || (card === null || card === void 0 ? void 0 : card.tag) === 'Media'; // Fallback fÃ¼r Legacy-Karten\n\n  const consumed = [];\n  traps.forEach(t => {\n    switch (t.key) {\n      // bereits live benutzt\n      case 'trap.fake_news.deactivate_media':\n        if (isMediaLike && card.uid != null) {\n          enqueue({\n            type: 'DEACTIVATE_CARD',\n            player: opp,\n            targetUid: card.uid\n          });\n          log('Trap: Fake News â€“ deactivated media/platform card.');\n          consumed.push(t);\n        }\n        break;\n\n      // neu: Initiative canceln (sofort beim Ausspielen der Initiative)\n      case 'trap.legal_injunction.cancel_next_initiative':\n        if (isInitiative && card.uid != null) {\n          enqueue({\n            type: 'CANCEL_CARD',\n            player: opp,\n            targetUid: card.uid\n          });\n          log('Trap: Legal Injunction â€“ cancelled initiative.');\n          consumed.push(t);\n        }\n        break;\n\n      // neu: Karte zurÃ¼ck auf Hand (egal welcher Typ)\n      case 'trap.whistleblower.return_last_played':\n        if (card.uid != null) {\n          enqueue({\n            type: 'RETURN_TO_HAND',\n            player: playedBy,\n            targetUid: card.uid\n          });\n          log('Trap: Whistleblower â€“ returned played card to hand.');\n          consumed.push(t);\n        }\n        break;\n\n      // neu: Gegner discards 2 bei nÃ¤chstem Play\n      case 'trap.data_breach.opp_discard2':\n        enqueue({\n          type: 'DISCARD_RANDOM_FROM_HAND',\n          player: playedBy === 1 ? 2 : 1,\n          amount: 2\n        });\n        log('Trap: Data Breach â€“ opponent discards 2.');\n        consumed.push(t);\n        break;\n\n      // neu: Public deaktivieren\n      case 'trap.media_blackout.deactivate_public':\n        if (isPublic && card.uid != null) {\n          enqueue({\n            type: 'DEACTIVATE_CARD',\n            player: opp,\n            targetUid: card.uid\n          });\n          log('Trap: Media Blackout â€“ deactivated public card.');\n          consumed.push(t);\n        }\n        break;\n\n      // neu: AP -2 fÃ¼r Gegner beim nÃ¤chsten Play\n      case 'trap.budget_freeze.opp_ap_minus2':\n        enqueue({\n          type: 'ADD_AP',\n          player: playedBy,\n          amount: -2\n        });\n        log('Trap: Budget Freeze â€“ opponent AP -2.');\n        consumed.push(t);\n        break;\n\n      // neu: Government deaktivieren\n      case 'trap.sabotage.deactivate_gov':\n        if (isGovernment && card.uid != null) {\n          enqueue({\n            type: 'DEACTIVATE_CARD',\n            player: opp,\n            targetUid: card.uid\n          });\n          log('Trap: Sabotage â€“ deactivated government card.');\n          consumed.push(t);\n        }\n        break;\n\n      // Strategic Disclosure: Government-Karte zurÃ¼ckgeben\n      case 'trap.strategic_disclosure.return_gov':\n        if (isGovernment && card.uid != null) {\n          enqueue({\n            type: 'RETURN_TO_HAND',\n            player: playedBy,\n            targetUid: card.uid\n          });\n          log('Trap: Strategic Disclosure â€“ returned government card to hand.');\n          consumed.push(t);\n        }\n        break;\n      case 'trap.whistleblower.debuff_next_gov_minus2':\n        // Robust trigger: treat any played politician (pol) as government trigger\n        const playedIsPol = (card === null || card === void 0 ? void 0 : card.kind) === 'pol' || isGovernment;\n        if (!playedIsPol) {\n          // not a government/pol card â€” skip\n          enqueue({\n            type: 'LOG',\n            msg: `DEBUG: Whistleblower present but played card is not government/pol (${card.name || card.key})`\n          });\n          break;\n        }\n        if (card.uid == null) {\n          enqueue({\n            type: 'LOG',\n            msg: `DEBUG: Whistleblower cannot apply - target missing uid for ${card.name || card.key}`\n          });\n          break;\n        }\n\n        // Compute number of Activist cards on both players' boards (innen + aussen)\n        const cd = require('../data/cardDetails');\n        let activistCount = 0;\n        for (const p of [1, 2]) {\n          var _state$board$p, _state$board$p2;\n          const innen = ((_state$board$p = state.board[p]) === null || _state$board$p === void 0 ? void 0 : _state$board$p.innen) || [];\n          const aussen = ((_state$board$p2 = state.board[p]) === null || _state$board$p2 === void 0 ? void 0 : _state$board$p2.aussen) || [];\n          const all = [...innen, ...aussen];\n          for (const c of all) {\n            var _cd$getCardDetails, _cd$getCardDetails$ca;\n            if (!c) continue;\n            const subcats = (_cd$getCardDetails = cd.getCardDetails) === null || _cd$getCardDetails === void 0 ? void 0 : (_cd$getCardDetails$ca = _cd$getCardDetails.call(cd, c.name)) === null || _cd$getCardDetails$ca === void 0 ? void 0 : _cd$getCardDetails$ca.subcategories;\n            const legacyTag = c.tag === 'Activist' || c.tag === 'Aktivist' || c.tag === 'Activists' || c.tag === 'Movement';\n            const hasActivistSubcat = Array.isArray(subcats) && (subcats.includes('Activist') || subcats.includes('Aktivist'));\n            if (hasActivistSubcat || legacyTag) {\n              // ignore deactivated public/pol cards\n              if (!c.deactivated) activistCount++;\n            }\n          }\n        }\n\n        // Base debuff -2 plus -1 per Activist (both boards), capped at -6 total\n        const totalDebuffMagnitude = Math.min(6, 2 + activistCount);\n        const amount = -totalDebuffMagnitude;\n        enqueue({\n          type: 'DEBUFF_CARD',\n          player: opp,\n          targetUid: card.uid,\n          amount\n        });\n        const debuffMsg = `Trap: Whistleblower â€“ government card gets ${amount} Influence (base -2 + activists ${activistCount}, capped at -6).`;\n        enqueue({\n          type: 'LOG',\n          msg: debuffMsg\n        });\n        // Immediate console log for better chronological trace before warnings\n        log(debuffMsg);\n        log(`ðŸŸ¢ trap.whistleblower triggered: applied ${amount} to uid ${card.uid} (activists=${activistCount})`);\n        consumed.push(t);\n        break;\n      default:\n        break;\n    }\n  });\n  if (consumed.length) {\n    // Build consumption indexes for robust removal\n    const consumedKeys = new Set(consumed.map(c => c.key).filter(Boolean));\n    // Also include base card keys (namespace + card) to catch visual trap card objects\n    // Example: 'trap.whistleblower.return_last_played' -> add 'trap.whistleblower'\n    for (const k of Array.from(consumedKeys)) {\n      if (typeof k === 'string') {\n        const parts = k.split('.');\n        if (parts.length >= 3) {\n          const baseKey = parts.slice(0, 2).join('.');\n          consumedKeys.add(baseKey);\n        }\n      }\n    }\n    const consumedUids = new Set(consumed.map(c => c.uid).filter(Boolean));\n    const consumedNames = new Set(consumed.map(c => c.name).filter(Boolean));\n    const consumedRefs = new Set(consumed);\n\n    // Debug logging for trap removal\n    enqueue({\n      type: 'LOG',\n      msg: `DEBUG: Trap removal - consumedKeys=[${Array.from(consumedKeys).join(', ')}] consumedNames=[${Array.from(consumedNames).join(', ')}]`\n    });\n\n    // Remove consumed trap registrations and any visual trap card objects from both players' trap lists\n    for (const p of [1, 2]) {\n      const list = state.traps[p] || [];\n      state.traps[p] = list.filter(entry => {\n        if (!entry) return false;\n        // Direct reference match\n        if (consumedRefs.has(entry)) return false;\n        // registration object with key\n        if (entry.key && consumedKeys.has(entry.key)) return false;\n        // match by uid\n        if (entry.uid && consumedUids.has(entry.uid)) return false;\n        // match by name\n        if (entry.name && consumedNames.has(entry.name)) return false;\n\n        // If entry looks like a card object (visual trap card) try permissive matches\n        if (entry && entry.kind === 'spec') {\n          const typeStr = String(entry.type || '').toLowerCase();\n          const entryName = String(entry.name || '').toLowerCase();\n          const entryKey = String(entry.key || '').toLowerCase();\n          const entryEffect = String(entry.effectKey || '').toLowerCase();\n\n          // Remove if its declared type includes 'trap'\n          if (typeStr.includes('trap')) return false;\n\n          // Remove if its name matches a consumed name or explicitly 'whistleblower'\n          if (consumedNames.has(entry.name) || entryName === 'whistleblower') return false;\n\n          // Remove if its key/effectKey matches or starts with any consumed key (permissive)\n          for (const ck of Array.from(consumedKeys)) {\n            if (!ck) continue;\n            const ckStr = String(ck).toLowerCase();\n            if (entryKey && (entryKey === ckStr || entryKey.startsWith(ckStr))) return false;\n            if (entryEffect && (entryEffect === ckStr || entryEffect.startsWith(ckStr))) return false;\n          }\n        }\n        return true;\n      });\n    }\n\n    // Explicit removal: if a consumed trap key was for whistleblower (or other\n    // traps), also remove any visual trap card objects that are stored in\n    // state.traps as `spec` objects whose name/key matches permissively.\n    try {\n      const consumedKeyArray = Array.from(consumedKeys).map(k => String(k).toLowerCase());\n      const consumedNameArray = Array.from(consumedNames).map(n => String(n).toLowerCase());\n      for (const p of [1, 2]) {\n        const arr = state.traps[p] || [];\n        const newArr = [];\n        for (const entry of arr) {\n          if (!entry) continue;\n          if (entry.kind === 'spec') {\n            const entryName = String(entry.name || '').toLowerCase();\n            const entryKey = String(entry.key || '').toLowerCase();\n            const entryEffect = String(entry.effectKey || '').toLowerCase();\n            let shouldRemove = false;\n            // direct name match\n            if (consumedNameArray.includes(entryName) || entryName === 'whistleblower') shouldRemove = true;\n            // match by consumed key parts (e.g. 'trap.whistleblower')\n            for (const ck of consumedKeyArray) {\n              if (!ck) continue;\n              const parts = ck.split('.');\n              const right = parts.slice(1).join('.');\n              if (entryKey && (entryKey === ck || entryKey.startsWith(ck) || entryKey.includes(right))) {\n                shouldRemove = true;\n                break;\n              }\n              if (entryEffect && (entryEffect === ck || entryEffect.startsWith(ck) || entryEffect.includes(right))) {\n                shouldRemove = true;\n                break;\n              }\n              if (right && entryName.includes(right)) {\n                shouldRemove = true;\n                break;\n              }\n            }\n            if (shouldRemove) {\n              const rmMsg = `EXPLICIT-REMOVE: removing visual trap object from state.traps P${p} name=\"${entry.name}\" key=\"${entry.key}\"`;\n              enqueue({\n                type: 'LOG',\n                msg: rmMsg\n              });\n              try {\n                log(rmMsg);\n              } catch (e) {}\n              // move to discard for visual cleanup\n              state.discard = state.discard || [];\n              state.discard.push(entry);\n              continue; // skip pushing to newArr (i.e., remove)\n            }\n          }\n          newArr.push(entry);\n        }\n        state.traps[p] = newArr;\n      }\n    } catch (e) {}\n\n    // Ensure the visual trap card is removed from any board lanes if it was added there\n    try {\n      const removeIfTrapOnBoard = arr => {\n        return arr.filter(c => {\n          if (!c) return true;\n          const key = c.key;\n          const name = c.name;\n          const typeStr = String(c.type || '').toLowerCase();\n          const effectKey = c.effectKey;\n\n          // Check if this is a trap card\n          const isTrapByType = typeStr.includes('trap');\n          const isTrapByKey = key && (key.startsWith('trap.') || consumedKeys.has(key));\n          const isTrapByEffectKey = effectKey && (effectKey.startsWith('trap.') || consumedKeys.has(effectKey));\n          const isTrapByName = name && (consumedNames.has(name) || name === 'Whistleblower');\n          if (isTrapByType || isTrapByKey || isTrapByEffectKey || isTrapByName) {\n            enqueue({\n              type: 'LOG',\n              msg: `DEBUG: Removing trap card from board - name=\"${name}\" key=\"${key}\" effectKey=\"${effectKey}\" type=\"${typeStr}\"`\n            });\n            return false;\n          }\n          return true;\n        });\n      };\n\n      // Remove from all board lanes (both players) to be safe\n      for (const p of [1, 2]) {\n        var _state$board;\n        if ((_state$board = state.board) !== null && _state$board !== void 0 && _state$board[p]) {\n          const beforeInnen = state.board[p].innen.length;\n          const beforeAussen = state.board[p].aussen.length;\n          const beforeSofort = state.board[p].sofort.length;\n          state.board[p].innen = removeIfTrapOnBoard(state.board[p].innen || []);\n          state.board[p].aussen = removeIfTrapOnBoard(state.board[p].aussen || []);\n          state.board[p].sofort = removeIfTrapOnBoard(state.board[p].sofort || []);\n          const afterInnen = state.board[p].innen.length;\n          const afterAussen = state.board[p].aussen.length;\n          const afterSofort = state.board[p].sofort.length;\n          if (beforeInnen !== afterInnen || beforeAussen !== afterAussen || beforeSofort !== afterSofort) {\n            enqueue({\n              type: 'LOG',\n              msg: `DEBUG: Board cleanup P${p} - innen:${beforeInnen}â†’${afterInnen}, aussen:${beforeAussen}â†’${afterAussen}, sofort:${beforeSofort}â†’${afterSofort}`\n            });\n          }\n        }\n      }\n      // Additionally, remove any consumed trap card objects from all board lanes and move them to discard\n      try {\n        for (const c of consumed) {\n          const cUid = c.uid;\n          const cKey = c.key || c.name;\n          for (const p of [1, 2]) {\n            for (const lane of ['innen', 'aussen', 'sofort']) {\n              const arr = state.board[p][lane];\n              const idx = arr.findIndex(card => card && (card.uid && cUid && card.uid === cUid || card.key && cKey && card.key === cKey || card.name && cKey && card.name === cKey));\n              if (idx !== -1) {\n                const [removed] = arr.splice(idx, 1);\n                state.discard = state.discard || [];\n                state.discard.push(removed);\n                enqueue({\n                  type: 'LOG',\n                  msg: `Trap consumed: removed ${removed && removed.name || cKey} from board and moved to discard.`\n                });\n              }\n            }\n          }\n        }\n      } catch (e) {}\n    } catch (e) {}\n  }\n\n  // Forced removal fallback: if a consumed trap wasn't removed by the above\n  // logic, attempt a more permissive board scan to remove any visual objects\n  // that look like trap cards. This covers cases where visual card objects use\n  // a simplified key or have no effectKey attached.\n  try {\n    // Build permissive fallback lists directly from `consumed` (available in\n    // this scope) to avoid relying on the inner-scope `consumedKeys`/`consumedNames`.\n    const fallbackKeysSet = new Set(consumed.map(c => c.key).filter(Boolean).map(String));\n    const fallbackNamesSet = new Set(consumed.map(c => c.name).filter(Boolean).map(String));\n    const fallbackKeys = Array.from(fallbackKeysSet);\n    const fallbackNames = Array.from(fallbackNamesSet);\n\n    // add generic base for whistleblower\n    if (!fallbackKeys.some(k => k.startsWith('trap.whistleblower'))) fallbackKeys.push('trap.whistleblower');\n    const removePermissive = arr => {\n      let removedAny = false;\n      for (let i = arr.length - 1; i >= 0; i--) {\n        const c = arr[i];\n        if (!c) continue;\n        const key = c.key;\n        const effectKey = c.effectKey;\n        const name = c.name;\n        const typeStr = String(c.type || '').toLowerCase();\n        const matchesKey = key && fallbackKeys.some(fk => key === fk || key.startsWith(fk));\n        const matchesEffect = effectKey && fallbackKeys.some(fk => effectKey === fk || effectKey.startsWith(fk));\n        const matchesName = name && fallbackNames.includes(name);\n        const looksLikeTrap = typeStr.includes('trap') || key && String(key).startsWith('trap.');\n        if (matchesKey || matchesEffect || matchesName || looksLikeTrap || name === 'Whistleblower') {\n          const [removed] = arr.splice(i, 1);\n          state.discard = state.discard || [];\n          state.discard.push(removed);\n          removedAny = true;\n          enqueue({\n            type: 'LOG',\n            msg: `FORCED-REMOVE: removed ${removed && removed.name || key || name} from board (permissive match)`\n          });\n        }\n      }\n      return removedAny;\n    };\n    for (const p of [1, 2]) {\n      var _state$board2;\n      if (!((_state$board2 = state.board) !== null && _state$board2 !== void 0 && _state$board2[p])) continue;\n      const lanes = ['innen', 'aussen', 'sofort'];\n      for (const lane of lanes) {\n        try {\n          const removed = removePermissive(state.board[p][lane]);\n          if (removed) enqueue({\n            type: 'LOG',\n            msg: `FORCED-REMOVE: cleaned up P${p}.${lane}`\n          });\n        } catch (e) {}\n      }\n    }\n  } catch (e) {}\n}","map":{"version":3,"names":["CARD_BY_ID","registerTrap","state","player","key","traps","list","Array","isArray","push","owner","applyTrapsOnCardPlayed","playedBy","card","enqueue","log","_state$traps","_state$effectFlags$pl","_cardDef$tags","_cardDef$tags2","opp","length","keys","map","t","join","type","msg","name","e","effectFlags","initiativesLocked","uid","targetUid","cardDef","isInitiative","isPublic","isGovernment","isMediaLike","tags","includes","tag","consumed","forEach","amount","playedIsPol","kind","cd","require","activistCount","p","_state$board$p","_state$board$p2","innen","board","aussen","all","c","_cd$getCardDetails","_cd$getCardDetails$ca","subcats","getCardDetails","call","subcategories","legacyTag","hasActivistSubcat","deactivated","totalDebuffMagnitude","Math","min","debuffMsg","consumedKeys","Set","filter","Boolean","k","from","parts","split","baseKey","slice","add","consumedUids","consumedNames","consumedRefs","entry","has","typeStr","String","toLowerCase","entryName","entryKey","entryEffect","effectKey","ck","ckStr","startsWith","consumedKeyArray","consumedNameArray","n","arr","newArr","shouldRemove","right","rmMsg","discard","removeIfTrapOnBoard","isTrapByType","isTrapByKey","isTrapByEffectKey","isTrapByName","_state$board","beforeInnen","beforeAussen","beforeSofort","sofort","afterInnen","afterAussen","afterSofort","cUid","cKey","lane","idx","findIndex","removed","splice","fallbackKeysSet","fallbackNamesSet","fallbackKeys","fallbackNames","some","removePermissive","removedAny","i","matchesKey","fk","matchesEffect","matchesName","looksLikeTrap","_state$board2","lanes"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/utils/traps.ts"],"sourcesContent":["import type { GameState, Player, Card } from '../types/game';\r\nimport type { EffectEvent } from '../types/effects';\r\nimport { CARD_BY_ID } from '../data/cards';\r\n\r\nexport function registerTrap(state: GameState, player: Player, key: string) {\r\n  if (!state.traps) state.traps = { 1: [], 2: [] } as any;\r\n  const list = (state.traps as any)[player] as Array<{ owner: Player; key: string }>;\r\n  if (!Array.isArray(list)) (state.traps as any)[player] = [];\r\n  (state.traps as any)[player].push({ owner: player, key });\r\n}\r\n\r\nexport function applyTrapsOnCardPlayed(\r\n  state: GameState,\r\n  playedBy: Player,\r\n  card: Card,\r\n  enqueue: (e: EffectEvent) => void,\r\n  log: (m: string) => void\r\n) {\r\n  const opp: Player = playedBy === 1 ? 2 : 1;\r\n  const traps = (state.traps as any)?.[opp] as Array<{ owner: Player; key: string }> | undefined;\r\n  if (!traps || traps.length === 0) return;\r\n\r\n  // Diagnostics: log existing traps for opponent when a card is played\r\n  try {\r\n    const keys = traps.map(t => t.key).join(', ');\r\n    enqueue({ type: 'LOG', msg: `DEBUG: applyTrapsOnCardPlayed opp=${opp} traps=[${keys}] playedCard=${(card as any).name || (card as any).key || 'unknown'}` });\r\n  } catch (e) {}\r\n\r\n  // Hard rule: Opposition Blockade â€“ if current player is locked, cancel initiative card immediately\r\n  if ((card as any)?.type === 'initiative' && state.effectFlags[playedBy]?.initiativesLocked) {\r\n    if ((card as any).uid != null) {\r\n      enqueue({ type: 'CANCEL_CARD', player: playedBy, targetUid: (card as any).uid } as any);\r\n    }\r\n    enqueue({ type: 'LOG', msg: 'Blocked: initiatives are locked (Opposition Blockade).' });\r\n    return; // skip further trap processing\r\n  }\r\n\r\n  // Get card definition to access type and tags\r\n  const cardDef = CARD_BY_ID[card.key];\r\n  const isInitiative = cardDef?.type === 'initiative';\r\n  const isPublic = cardDef?.type === 'public';\r\n  const isGovernment = cardDef?.type === 'government';\r\n  const isMediaLike = cardDef?.tags?.includes('Media') ||\r\n                     cardDef?.tags?.includes('Platform') ||\r\n                     (card as any)?.tag === 'Media'; // Fallback fÃ¼r Legacy-Karten\r\n\r\n  const consumed: Array<{ key: string }> = [];\r\n  traps.forEach(t => {\r\n    switch (t.key) {\r\n      // bereits live benutzt\r\n      case 'trap.fake_news.deactivate_media':\r\n        if (isMediaLike && (card as any).uid != null) {\r\n          enqueue({ type: 'DEACTIVATE_CARD', player: opp, targetUid: (card as any).uid });\r\n          log('Trap: Fake News â€“ deactivated media/platform card.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // neu: Initiative canceln (sofort beim Ausspielen der Initiative)\r\n      case 'trap.legal_injunction.cancel_next_initiative':\r\n        if (isInitiative && (card as any).uid != null) {\r\n          enqueue({ type: 'CANCEL_CARD', player: opp, targetUid: (card as any).uid });\r\n          log('Trap: Legal Injunction â€“ cancelled initiative.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // neu: Karte zurÃ¼ck auf Hand (egal welcher Typ)\r\n      case 'trap.whistleblower.return_last_played':\r\n        if ((card as any).uid != null) {\r\n          enqueue({ type: 'RETURN_TO_HAND', player: playedBy, targetUid: (card as any).uid });\r\n          log('Trap: Whistleblower â€“ returned played card to hand.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // neu: Gegner discards 2 bei nÃ¤chstem Play\r\n      case 'trap.data_breach.opp_discard2':\r\n        enqueue({ type: 'DISCARD_RANDOM_FROM_HAND', player: playedBy === 1 ? 2 : 1, amount: 2 });\r\n        log('Trap: Data Breach â€“ opponent discards 2.');\r\n        consumed.push(t);\r\n        break;\r\n\r\n      // neu: Public deaktivieren\r\n      case 'trap.media_blackout.deactivate_public':\r\n        if (isPublic && (card as any).uid != null) {\r\n          enqueue({ type: 'DEACTIVATE_CARD', player: opp, targetUid: (card as any).uid });\r\n          log('Trap: Media Blackout â€“ deactivated public card.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // neu: AP -2 fÃ¼r Gegner beim nÃ¤chsten Play\r\n      case 'trap.budget_freeze.opp_ap_minus2':\r\n        enqueue({ type: 'ADD_AP', player: playedBy, amount: -2 });\r\n        log('Trap: Budget Freeze â€“ opponent AP -2.');\r\n        consumed.push(t);\r\n        break;\r\n\r\n      // neu: Government deaktivieren\r\n      case 'trap.sabotage.deactivate_gov':\r\n        if (isGovernment && (card as any).uid != null) {\r\n          enqueue({ type: 'DEACTIVATE_CARD', player: opp, targetUid: (card as any).uid });\r\n          log('Trap: Sabotage â€“ deactivated government card.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // Strategic Disclosure: Government-Karte zurÃ¼ckgeben\r\n      case 'trap.strategic_disclosure.return_gov':\r\n        if (isGovernment && (card as any).uid != null) {\r\n          enqueue({ type: 'RETURN_TO_HAND', player: playedBy, targetUid: (card as any).uid });\r\n          log('Trap: Strategic Disclosure â€“ returned government card to hand.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      case 'trap.whistleblower.debuff_next_gov_minus2':\r\n        // Robust trigger: treat any played politician (pol) as government trigger\r\n        const playedIsPol = (card as any)?.kind === 'pol' || isGovernment;\r\n        if (!playedIsPol) {\r\n          // not a government/pol card â€” skip\r\n          enqueue({ type: 'LOG', msg: `DEBUG: Whistleblower present but played card is not government/pol (${(card as any).name || (card as any).key})` });\r\n          break;\r\n        }\r\n        if ((card as any).uid == null) {\r\n          enqueue({ type: 'LOG', msg: `DEBUG: Whistleblower cannot apply - target missing uid for ${(card as any).name || (card as any).key}` });\r\n          break;\r\n        }\r\n\r\n        // Compute number of Activist cards on both players' boards (innen + aussen)\r\n        const cd = require('../data/cardDetails') as any;\r\n        let activistCount = 0;\r\n        for (const p of [1, 2] as const) {\r\n          const innen = state.board[p]?.innen || [];\r\n          const aussen = state.board[p]?.aussen || [];\r\n          const all = [...innen, ...aussen];\r\n          for (const c of all) {\r\n            if (!c) continue;\r\n            const subcats = cd.getCardDetails?.((c as any).name)?.subcategories as string[] | undefined;\r\n            const legacyTag = (c as any).tag === 'Activist' || (c as any).tag === 'Aktivist' || (c as any).tag === 'Activists' || (c as any).tag === 'Movement';\r\n            const hasActivistSubcat = Array.isArray(subcats) && (subcats.includes('Activist') || subcats.includes('Aktivist'));\r\n            if (hasActivistSubcat || legacyTag) {\r\n              // ignore deactivated public/pol cards\r\n              if (!(c as any).deactivated) activistCount++;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Base debuff -2 plus -1 per Activist (both boards), capped at -6 total\r\n        const totalDebuffMagnitude = Math.min(6, 2 + activistCount);\r\n        const amount = -totalDebuffMagnitude;\r\n\r\n        enqueue({ type: 'DEBUFF_CARD', player: opp, targetUid: (card as any).uid, amount } as any);\r\n        const debuffMsg = `Trap: Whistleblower â€“ government card gets ${amount} Influence (base -2 + activists ${activistCount}, capped at -6).`;\r\n        enqueue({ type: 'LOG', msg: debuffMsg });\r\n        // Immediate console log for better chronological trace before warnings\r\n        log(debuffMsg);\r\n        log(`ðŸŸ¢ trap.whistleblower triggered: applied ${amount} to uid ${(card as any).uid} (activists=${activistCount})`);\r\n        consumed.push(t);\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  });\r\n\r\n  if (consumed.length) {\r\n    // Build consumption indexes for robust removal\r\n    const consumedKeys = new Set(consumed.map(c => (c as any).key).filter(Boolean));\r\n    // Also include base card keys (namespace + card) to catch visual trap card objects\r\n    // Example: 'trap.whistleblower.return_last_played' -> add 'trap.whistleblower'\r\n    for (const k of Array.from(consumedKeys)) {\r\n      if (typeof k === 'string') {\r\n        const parts = k.split('.');\r\n        if (parts.length >= 3) {\r\n          const baseKey = parts.slice(0, 2).join('.');\r\n          consumedKeys.add(baseKey);\r\n        }\r\n      }\r\n    }\r\n    const consumedUids = new Set(consumed.map(c => (c as any).uid).filter(Boolean));\r\n    const consumedNames = new Set(consumed.map(c => (c as any).name).filter(Boolean));\r\n    const consumedRefs = new Set(consumed);\r\n\r\n    // Debug logging for trap removal\r\n    enqueue({ type: 'LOG', msg: `DEBUG: Trap removal - consumedKeys=[${Array.from(consumedKeys).join(', ')}] consumedNames=[${Array.from(consumedNames).join(', ')}]` });\r\n\r\n    // Remove consumed trap registrations and any visual trap card objects from both players' trap lists\r\n    for (const p of [1, 2] as const) {\r\n      const list = (state.traps as any)[p] || [];\r\n      (state.traps as any)[p] = list.filter((entry: any) => {\r\n        if (!entry) return false;\r\n        // Direct reference match\r\n        if (consumedRefs.has(entry)) return false;\r\n        // registration object with key\r\n        if (entry.key && consumedKeys.has(entry.key)) return false;\r\n        // match by uid\r\n        if ((entry as any).uid && consumedUids.has((entry as any).uid)) return false;\r\n        // match by name\r\n        if ((entry as any).name && consumedNames.has((entry as any).name)) return false;\r\n\r\n        // If entry looks like a card object (visual trap card) try permissive matches\r\n        if (entry && entry.kind === 'spec') {\r\n          const typeStr = String((entry as any).type || '').toLowerCase();\r\n          const entryName = String((entry as any).name || '').toLowerCase();\r\n          const entryKey = String((entry as any).key || '').toLowerCase();\r\n          const entryEffect = String((entry as any).effectKey || '').toLowerCase();\r\n\r\n          // Remove if its declared type includes 'trap'\r\n          if (typeStr.includes('trap')) return false;\r\n\r\n          // Remove if its name matches a consumed name or explicitly 'whistleblower'\r\n          if (consumedNames.has(entry.name) || entryName === 'whistleblower') return false;\r\n\r\n          // Remove if its key/effectKey matches or starts with any consumed key (permissive)\r\n          for (const ck of Array.from(consumedKeys)) {\r\n            if (!ck) continue;\r\n            const ckStr = String(ck).toLowerCase();\r\n            if (entryKey && (entryKey === ckStr || entryKey.startsWith(ckStr))) return false;\r\n            if (entryEffect && (entryEffect === ckStr || entryEffect.startsWith(ckStr))) return false;\r\n          }\r\n        }\r\n\r\n        return true;\r\n      });\r\n    }\r\n\r\n    // Explicit removal: if a consumed trap key was for whistleblower (or other\r\n    // traps), also remove any visual trap card objects that are stored in\r\n    // state.traps as `spec` objects whose name/key matches permissively.\r\n    try {\r\n      const consumedKeyArray = Array.from(consumedKeys).map(k => String(k).toLowerCase());\r\n      const consumedNameArray = Array.from(consumedNames).map(n => String(n).toLowerCase());\r\n      for (const p of [1,2] as const) {\r\n        const arr = (state.traps as any)[p] || [];\r\n        const newArr: any[] = [];\r\n        for (const entry of arr) {\r\n          if (!entry) continue;\r\n          if ((entry as any).kind === 'spec') {\r\n            const entryName = String((entry as any).name || '').toLowerCase();\r\n            const entryKey = String((entry as any).key || '').toLowerCase();\r\n            const entryEffect = String((entry as any).effectKey || '').toLowerCase();\r\n\r\n            let shouldRemove = false;\r\n            // direct name match\r\n            if (consumedNameArray.includes(entryName) || entryName === 'whistleblower') shouldRemove = true;\r\n            // match by consumed key parts (e.g. 'trap.whistleblower')\r\n            for (const ck of consumedKeyArray) {\r\n              if (!ck) continue;\r\n              const parts = ck.split('.');\r\n              const right = parts.slice(1).join('.');\r\n              if (entryKey && (entryKey === ck || entryKey.startsWith(ck) || entryKey.includes(right))) { shouldRemove = true; break; }\r\n              if (entryEffect && (entryEffect === ck || entryEffect.startsWith(ck) || entryEffect.includes(right))) { shouldRemove = true; break; }\r\n              if (right && entryName.includes(right)) { shouldRemove = true; break; }\r\n            }\r\n\r\n            if (shouldRemove) {\r\n              const rmMsg = `EXPLICIT-REMOVE: removing visual trap object from state.traps P${p} name=\"${entry.name}\" key=\"${entry.key}\"`;\r\n              enqueue({ type: 'LOG', msg: rmMsg });\r\n              try { log(rmMsg); } catch (e) {}\r\n              // move to discard for visual cleanup\r\n              state.discard = state.discard || [];\r\n              state.discard.push(entry);\r\n              continue; // skip pushing to newArr (i.e., remove)\r\n            }\r\n          }\r\n          newArr.push(entry);\r\n        }\r\n        (state.traps as any)[p] = newArr;\r\n      }\r\n    } catch (e) {}\r\n\r\n    // Ensure the visual trap card is removed from any board lanes if it was added there\r\n    try {\r\n      const removeIfTrapOnBoard = (arr: any[]) => {\r\n        return arr.filter(c => {\r\n          if (!c) return true;\r\n          const key = (c as any).key;\r\n          const name = (c as any).name;\r\n          const typeStr = String((c as any).type || '').toLowerCase();\r\n          const effectKey = (c as any).effectKey;\r\n\r\n          // Check if this is a trap card\r\n          const isTrapByType = typeStr.includes('trap');\r\n          const isTrapByKey = key && (key.startsWith('trap.') || consumedKeys.has(key));\r\n          const isTrapByEffectKey = effectKey && (effectKey.startsWith('trap.') || consumedKeys.has(effectKey));\r\n          const isTrapByName = name && (consumedNames.has(name) || name === 'Whistleblower');\r\n\r\n          if (isTrapByType || isTrapByKey || isTrapByEffectKey || isTrapByName) {\r\n            enqueue({ type: 'LOG', msg: `DEBUG: Removing trap card from board - name=\"${name}\" key=\"${key}\" effectKey=\"${effectKey}\" type=\"${typeStr}\"` });\r\n            return false;\r\n          }\r\n          return true;\r\n        });\r\n      };\r\n\r\n      // Remove from all board lanes (both players) to be safe\r\n      for (const p of [1, 2] as const) {\r\n        if (state.board?.[p]) {\r\n          const beforeInnen = state.board[p].innen.length;\r\n          const beforeAussen = state.board[p].aussen.length;\r\n          const beforeSofort = state.board[p].sofort.length;\r\n\r\n          state.board[p].innen = removeIfTrapOnBoard(state.board[p].innen || []);\r\n          state.board[p].aussen = removeIfTrapOnBoard(state.board[p].aussen || []);\r\n          state.board[p].sofort = removeIfTrapOnBoard(state.board[p].sofort || []);\r\n\r\n          const afterInnen = state.board[p].innen.length;\r\n          const afterAussen = state.board[p].aussen.length;\r\n          const afterSofort = state.board[p].sofort.length;\r\n\r\n          if (beforeInnen !== afterInnen || beforeAussen !== afterAussen || beforeSofort !== afterSofort) {\r\n            enqueue({ type: 'LOG', msg: `DEBUG: Board cleanup P${p} - innen:${beforeInnen}â†’${afterInnen}, aussen:${beforeAussen}â†’${afterAussen}, sofort:${beforeSofort}â†’${afterSofort}` });\r\n          }\r\n        }\r\n      }\r\n      // Additionally, remove any consumed trap card objects from all board lanes and move them to discard\r\n      try {\r\n        for (const c of consumed) {\r\n          const cUid = (c as any).uid;\r\n          const cKey = (c as any).key || (c as any).name;\r\n          for (const p of [1, 2] as const) {\r\n            for (const lane of ['innen', 'aussen', 'sofort'] as const) {\r\n              const arr = state.board[p][lane] as any[];\r\n              const idx = arr.findIndex(card => (card && ((card.uid && cUid && card.uid === cUid) || (card.key && cKey && card.key === cKey) || (card.name && cKey && card.name === cKey))));\r\n              if (idx !== -1) {\r\n                const [removed] = arr.splice(idx, 1);\r\n                state.discard = state.discard || [];\r\n                state.discard.push(removed);\r\n                enqueue({ type: 'LOG', msg: `Trap consumed: removed ${(removed && removed.name) || cKey} from board and moved to discard.` });\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } catch (e) {}\r\n    } catch (e) {}\r\n  }\r\n\r\n  // Forced removal fallback: if a consumed trap wasn't removed by the above\r\n  // logic, attempt a more permissive board scan to remove any visual objects\r\n  // that look like trap cards. This covers cases where visual card objects use\r\n  // a simplified key or have no effectKey attached.\r\n  try {\r\n    // Build permissive fallback lists directly from `consumed` (available in\r\n    // this scope) to avoid relying on the inner-scope `consumedKeys`/`consumedNames`.\r\n    const fallbackKeysSet = new Set(consumed.map(c => (c as any).key).filter(Boolean).map(String));\r\n    const fallbackNamesSet = new Set(consumed.map(c => (c as any).name).filter(Boolean).map(String));\r\n    const fallbackKeys = Array.from(fallbackKeysSet) as string[];\r\n    const fallbackNames = Array.from(fallbackNamesSet) as string[];\r\n\r\n    // add generic base for whistleblower\r\n    if (!fallbackKeys.some(k => k.startsWith('trap.whistleblower'))) fallbackKeys.push('trap.whistleblower');\r\n\r\n    const removePermissive = (arr: any[]) => {\r\n      let removedAny = false;\r\n      for (let i = arr.length - 1; i >= 0; i--) {\r\n        const c = arr[i];\r\n        if (!c) continue;\r\n        const key = c.key;\r\n        const effectKey = c.effectKey;\r\n        const name = c.name;\r\n        const typeStr = String((c as any).type || '').toLowerCase();\r\n\r\n        const matchesKey = key && fallbackKeys.some(fk => key === fk || key.startsWith(fk));\r\n        const matchesEffect = effectKey && fallbackKeys.some(fk => effectKey === fk || effectKey.startsWith(fk));\r\n        const matchesName = name && fallbackNames.includes(name);\r\n        const looksLikeTrap = typeStr.includes('trap') || (key && String(key).startsWith('trap.'));\r\n\r\n        if (matchesKey || matchesEffect || matchesName || looksLikeTrap || name === 'Whistleblower') {\r\n          const [removed] = arr.splice(i, 1);\r\n          state.discard = state.discard || [];\r\n          state.discard.push(removed);\r\n          removedAny = true;\r\n          enqueue({ type: 'LOG', msg: `FORCED-REMOVE: removed ${(removed && removed.name) || key || name} from board (permissive match)` });\r\n        }\r\n      }\r\n      return removedAny;\r\n    };\r\n\r\n    for (const p of [1, 2] as const) {\r\n      if (!state.board?.[p]) continue;\r\n      const lanes = ['innen', 'aussen', 'sofort'] as const;\r\n      for (const lane of lanes) {\r\n        try {\r\n          const removed = removePermissive(state.board[p][lane]);\r\n          if (removed) enqueue({ type: 'LOG', msg: `FORCED-REMOVE: cleaned up P${p}.${lane}` });\r\n        } catch (e) {}\r\n      }\r\n    }\r\n  } catch (e) {}\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}