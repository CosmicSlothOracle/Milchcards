{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\skank\\\\Videos\\\\Cards\\\\Milchcards\\\\src\\\\components\\\\GameCanvas.tsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback } from 'react';\nimport { useVisualEffectsSafe } from '../context/VisualEffectsContext';\nimport { LAYOUT, getZone, computeSlotRects, getUiTransform, getLaneCapacity, getPublicRects, getGovernmentRects, getSofortRect } from '../ui/layout';\nimport { sortHandCards } from '../utils/gameUtils';\nimport { getCardImagePath } from '../data/gameData';\nimport influenceIconUrl from '../assets/icons/influence.svg';\nimport publicSymbolUrl from '../assets/icons/public_symbol.png';\nimport sofortSymbolUrl from '../assets/icons/sofort_initiative_symbol.png';\nimport dauerhaftSymbolUrl from '../assets/icons/dauerhaft_initative.png';\nimport governmentSymbolUrl from '../assets/icons/government_symbol.png';\nimport interventionSymbolUrl from '../assets/icons/intervention_symbol.png';\nimport govPlaceGifUrl from '../assets/effect_gif/place_card_gov_256x256.gif';\nimport govPlaceSpritesheetUrl from '../ui/sprites/playcard_gov_256x256_14.png';\nimport instantSpritesheetUrl from '../ui/sprites/activate_trap_hit_target_256x256_16x2.png';\nimport hitSpritesheetUrl from '../ui/sprites/activate_inititive_hit_target_256x256_16_2rows.png';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// Helper: is corruption target selection active\nfunction isCorruptionSelection(state, player) {\n  const sel = state.pendingAbilitySelect;\n  return sel && sel.type === 'corruption_steal' && sel.actorPlayer === player;\n}\n\n// Helper: is maulwurf corruption active\nfunction isMaulwurfCorruption(state, player) {\n  const sel = state.pendingAbilitySelect;\n  return sel && sel.type === 'maulwurf_steal' && sel.actorPlayer === player;\n}\n\n// Helper: is tunnelvision probe active\nfunction isTunnelvisionProbe(state, player) {\n  const sel = state.pendingAbilitySelect;\n  return sel && sel.type === 'tunnelvision_probe' && sel.actorPlayer === player;\n}\nexport const GameCanvas = ({\n  gameState,\n  selectedHandIndex,\n  onCardClick,\n  onCardHover,\n  devMode = false\n}) => {\n  _s();\n  // listen for dice roll requests from resolver and trigger Dice3D\n  useEffect(() => {\n    const handler = ev => {\n      try {\n        var _ev$detail;\n        const player = (_ev$detail = ev.detail) === null || _ev$detail === void 0 ? void 0 : _ev$detail.player;\n        // find Dice3D canvas on page and trigger click (it rolls on click)\n        const dice = document.querySelector('canvas');\n        // better: dispatch global event so App-level Dice3D component can roll programmatically\n        window.dispatchEvent(new CustomEvent('pc:ui_request_dice_roll', {\n          detail: {\n            player\n          }\n        }));\n      } catch (e) {}\n    };\n    window.addEventListener('pc:request_dice_roll', handler);\n    return () => window.removeEventListener('pc:request_dice_roll', handler);\n  }, []);\n  const canvasRef = useRef(null);\n  const visualEffects = useVisualEffectsSafe();\n  const clickZonesRef = useRef([]);\n  // Smooth vertical scroll for P1 hand when it has more than visible slots\n  const handScrollTargetRef = useRef(0);\n  const handScrollCurrentRef = useRef(0);\n  const handScrollEnabledRef = useRef(true);\n  // Touch handling refs\n  const touchStartYRef = useRef(null);\n  const lastTouchYRef = useRef(null);\n  const isTouchingRef = useRef(false);\n  const backgroundImageRef = useRef(null);\n  const imageCacheRef = useRef(new Map());\n  const influenceImgRef = useRef(null);\n  // Animation state for visual influence changes: Map<uid, Array<Anim>>\n  const influenceAnimRef = useRef(new Map());\n  // Previous per-card influence snapshot to detect increases\n  const prevInfluencesRef = useRef({});\n  // Slot symbol images\n  const slotSymbolImgsRef = useRef(new Map());\n  // Map of canonical slot positions for animations: key -> {x,y,w,h,cx,cy}\n  const slotPositionsRef = useRef({});\n  // Mapping between animation UIDs and slot keys to ensure one-shot playback\n  const uidToKeyRef = useRef({});\n  const keyToUidRef = useRef({});\n  // Temporary test GIF for government slots\n  const govGifRef = useRef(null);\n  const govSpritesRef = useRef(null);\n  // hit (target) spritesheet (25 frames)\n  const hitSpritesRef = useRef(null);\n  // sprite animation state keyed by slot-key (player.lane.index)\n  const govSpriteStateRef = useRef({});\n  const instantSpritesRef = useRef(null);\n  const instantSpriteStateRef = useRef({});\n  const hitSpriteStateRef = useRef({});\n\n  // Corruption (Bestechungsskandal) target selection mode\n  const corruptionSelectActorRef = useRef(null);\n  const gameStateRef = useRef(gameState);\n  useEffect(() => {\n    gameStateRef.current = gameState;\n  }, [gameState]);\n  useEffect(() => {\n    const onEnterCorruptionSelect = ev => {\n      try {\n        var _ev$detail2;\n        const actor = (_ev$detail2 = ev.detail) === null || _ev$detail2 === void 0 ? void 0 : _ev$detail2.player;\n        console.log('🔥 GAMECANVAS RECEIVED pc:corruption_select_target - Actor:', actor);\n        corruptionSelectActorRef.current = actor !== null && actor !== void 0 ? actor : null;\n        console.log('🔥 SET corruptionSelectActorRef.current:', corruptionSelectActorRef.current);\n      } catch (e) {\n        console.error('🔥 ERROR in corruption select handler:', e);\n      }\n    };\n    window.addEventListener('pc:corruption_select_target', onEnterCorruptionSelect);\n    // Keyboard hotkeys 1-5 to choose opponent government slot when corruption select is active\n    const onKeyDown = ev => {\n      try {\n        var _gs$board, _gs$board$victim, _gs$board$victim$auss, _card$uid;\n        const k = ev.key;\n        if (!['1', '2', '3', '4', '5'].includes(k)) return;\n        const actor = corruptionSelectActorRef.current;\n        if (!actor) return;\n        const victim = actor === 1 ? 2 : 1;\n        const idx = Number(k) - 1; // map '1' -> slot 0\n        const gs = gameStateRef.current;\n        const card = gs === null || gs === void 0 ? void 0 : (_gs$board = gs.board) === null || _gs$board === void 0 ? void 0 : (_gs$board$victim = _gs$board[victim]) === null || _gs$board$victim === void 0 ? void 0 : (_gs$board$victim$auss = _gs$board$victim.aussen) === null || _gs$board$victim$auss === void 0 ? void 0 : _gs$board$victim$auss[idx];\n        console.debug('[CORR][KEY] pressed', k, 'actor', actor, 'victim', victim, 'idx', idx, 'card', card);\n        if (!card) return;\n        const uid = (_card$uid = card.uid) !== null && _card$uid !== void 0 ? _card$uid : card.id;\n        if (!uid) return;\n        console.debug('[CORR][KEY] dispatching pick_target for uid', uid);\n        window.dispatchEvent(new CustomEvent('pc:corruption_pick_target', {\n          detail: {\n            player: actor,\n            targetUid: uid\n          }\n        }));\n        try {\n          console.debug('[CORR][KEY] dispatching target_selected for uid', uid);\n          window.dispatchEvent(new CustomEvent('pc:corruption_target_selected', {\n            detail: {\n              player: actor,\n              targetUid: uid\n            }\n          }));\n        } catch (e) {\n          console.debug('[CORR][KEY] target_selected dispatch error', e);\n        }\n        ev.preventDefault();\n      } catch (e) {}\n    };\n    window.addEventListener('keydown', onKeyDown);\n    return () => {\n      window.removeEventListener('pc:corruption_select_target', onEnterCorruptionSelect);\n      window.removeEventListener('keydown', onKeyDown);\n    };\n  }, []);\n\n  // Maulwurf corruption target selection mode\n  const maulwurfSelectActorRef = useRef(null);\n  useEffect(() => {\n    const onEnterMaulwurfSelect = ev => {\n      try {\n        var _ev$detail3, _ev$detail4, _ev$detail5, _ev$detail6;\n        const actor = (_ev$detail3 = ev.detail) === null || _ev$detail3 === void 0 ? void 0 : _ev$detail3.player;\n        const targetUid = (_ev$detail4 = ev.detail) === null || _ev$detail4 === void 0 ? void 0 : _ev$detail4.targetUid;\n        const requiredRoll = (_ev$detail5 = ev.detail) === null || _ev$detail5 === void 0 ? void 0 : _ev$detail5.requiredRoll;\n        const targetName = (_ev$detail6 = ev.detail) === null || _ev$detail6 === void 0 ? void 0 : _ev$detail6.targetName;\n        console.log('🔥 GAMECANVAS RECEIVED pc:maulwurf_select_target - Actor:', actor, 'Target:', targetName, 'Required:', requiredRoll);\n        maulwurfSelectActorRef.current = actor !== null && actor !== void 0 ? actor : null;\n\n        // Show modal for dice roll\n        const el = document.createElement('div');\n        el.id = 'pc-maulwurf-modal';\n        el.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;';\n        el.style.fontSize = '14px';\n        document.body.appendChild(el);\n        el.innerHTML = `<div style=\"display:flex;flex-direction:column;gap:8px;min-width:260px;\">\n          <div style=\"font-weight:700\">Maulwurf — Ziel automatisch gewählt</div>\n          <div>Gewähltes Ziel: <b>${targetName || 'Unbekannt'}</b></div>\n          <div>Probe: W6 ≥ ${requiredRoll || 2} (2 + Anzahl Regierungskarten)</div>\n          <div style=\"display:flex;gap:8px;justify-content:flex-end;\">\n            <button id=\"pc-maulwurf-roll\" style=\"background:#2563eb;color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;\">Würfeln</button>\n            <button id=\"pc-maulwurf-cancel\" style=\"background:#374151;color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;\">Abbrechen</button>\n          </div>\n        </div>`;\n\n        // Event listeners for buttons\n        const rollBtn = el.querySelector('#pc-maulwurf-roll');\n        const cancelBtn = el.querySelector('#pc-maulwurf-cancel');\n        if (rollBtn) {\n          rollBtn.addEventListener('click', () => {\n            try {\n              window.dispatchEvent(new CustomEvent('pc:maulwurf_request_roll', {\n                detail: {\n                  player: actor,\n                  targetUid\n                }\n              }));\n              document.body.removeChild(el);\n            } catch (e) {\n              console.error('Maulwurf roll button error:', e);\n            }\n          });\n        }\n        if (cancelBtn) {\n          cancelBtn.addEventListener('click', () => {\n            try {\n              document.body.removeChild(el);\n              // Clear pending selection\n              if (typeof window !== 'undefined') {\n                window.dispatchEvent(new CustomEvent('pc:clear_pending_selection'));\n              }\n            } catch (e) {\n              console.error('Maulwurf cancel button error:', e);\n            }\n          });\n        }\n      } catch (e) {\n        console.error('🔥 ERROR in maulwurf select handler:', e);\n      }\n    };\n    window.addEventListener('pc:maulwurf_select_target', onEnterMaulwurfSelect);\n    return () => {\n      window.removeEventListener('pc:maulwurf_select_target', onEnterMaulwurfSelect);\n    };\n  }, []);\n\n  // Tunnelvision probe mode\n  const tunnelvisionProbeActorRef = useRef(null);\n  useEffect(() => {\n    const onEnterTunnelvisionProbe = ev => {\n      try {\n        var _ev$detail7, _ev$detail8, _ev$detail9, _ev$detail0;\n        const actor = (_ev$detail7 = ev.detail) === null || _ev$detail7 === void 0 ? void 0 : _ev$detail7.player;\n        const targetUid = (_ev$detail8 = ev.detail) === null || _ev$detail8 === void 0 ? void 0 : _ev$detail8.targetUid;\n        const requiredRoll = (_ev$detail9 = ev.detail) === null || _ev$detail9 === void 0 ? void 0 : _ev$detail9.requiredRoll;\n        const influence = (_ev$detail0 = ev.detail) === null || _ev$detail0 === void 0 ? void 0 : _ev$detail0.influence;\n        console.log('🔥 GAMECANVAS RECEIVED pc:tunnelvision_probe_start - Actor:', actor, 'Target:', targetUid, 'Required:', requiredRoll, 'Influence:', influence);\n        tunnelvisionProbeActorRef.current = actor !== null && actor !== void 0 ? actor : null;\n        console.log('🔥 SET tunnelvisionProbeActorRef.current:', tunnelvisionProbeActorRef.current);\n\n        // Create modal for tunnelvision probe\n        const el = document.getElementById('pc-modal-root');\n        if (!el) return;\n        el.innerHTML = `<div style=\"display:flex;flex-direction:column;gap:8px;min-width:280px;\">\n          <div style=\"font-weight:700\">Tunnelvision — Regierungskarte Probe</div>\n          <div>Einfluss: <b>${influence || 'Unbekannt'}</b></div>\n          <div>Probe: W6 ≥ ${requiredRoll || 4} ${(influence || 0) >= 9 ? '(Einfluss 9+)' : '(Standard)'}</div>\n          <div style=\"font-size:12px;color:#666;\">Bei Misserfolg: 2-3 Karte bleibt in Hand, 1 kritischer Misserfolg entfernt Karte dauerhaft</div>\n          <div style=\"display:flex;gap:8px;justify-content:flex-end;\">\n            <button id=\"pc-tunnelvision-roll\" style=\"background:#2563eb;color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;\">Würfeln</button>\n            <button id=\"pc-tunnelvision-cancel\" style=\"background:#374151;color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;\">Abbrechen</button>\n          </div>\n        </div>`;\n\n        // Add event listeners for buttons\n        const rollBtn = document.getElementById('pc-tunnelvision-roll');\n        const cancelBtn = document.getElementById('pc-tunnelvision-cancel');\n        if (rollBtn) {\n          rollBtn.onclick = () => {\n            try {\n              window.dispatchEvent(new CustomEvent('pc:tunnelvision_request_roll', {\n                detail: {\n                  player: actor,\n                  targetUid,\n                  requiredRoll,\n                  influence\n                }\n              }));\n              el.innerHTML = '';\n            } catch (e) {\n              console.error('Error dispatching tunnelvision request roll:', e);\n            }\n          };\n        }\n        if (cancelBtn) {\n          cancelBtn.onclick = () => {\n            el.innerHTML = '';\n            // Cancel the probe - card stays in hand\n            try {\n              window.dispatchEvent(new CustomEvent('pc:tunnelvision_request_roll', {\n                detail: {\n                  player: actor,\n                  targetUid,\n                  requiredRoll,\n                  influence,\n                  cancel: true\n                }\n              }));\n            } catch (e) {\n              console.error('Error canceling tunnelvision probe:', e);\n            }\n          };\n        }\n      } catch (e) {\n        console.error('🔥 ERROR in tunnelvision probe handler:', e);\n      }\n    };\n    window.addEventListener('pc:tunnelvision_probe_start', onEnterTunnelvisionProbe);\n    return () => {\n      window.removeEventListener('pc:tunnelvision_probe_start', onEnterTunnelvisionProbe);\n    };\n  }, []);\n\n  // Helper: draw slot icons with uniform pulsing opacity and a light reflection\n  const drawSlotIconWithPulse = useCallback((ctx, img, x, y, w, h, phase = 0) => {\n    if (!img || !img.complete) return;\n    try {\n      const now = performance.now();\n      const base = 0.10; // base opacity\n      const pulseRange = 0.08; // pulse amplitude (-> up to base + pulseRange)\n      const period = 700; // ms\n      const pulse = base + pulseRange * (0.5 + 0.5 * Math.sin(now / period + phase));\n\n      // draw icon with pulsing alpha\n      ctx.save();\n      ctx.globalAlpha = pulse;\n      ctx.drawImage(img, x, y, w, h);\n\n      // subtle reflection: gradient overlay on top half\n      const grad = ctx.createLinearGradient(x, y, x, y + h * 0.5);\n      grad.addColorStop(0, `rgba(255,255,255,${0.18 * pulse})`);\n      grad.addColorStop(1, `rgba(255,255,255,0)`);\n      ctx.globalCompositeOperation = 'lighter';\n      ctx.fillStyle = grad;\n      ctx.fillRect(x, y, w, h * 0.5);\n      ctx.restore();\n    } catch (e) {\n      // silent fallback\n    }\n  }, []);\n\n  // Load influence icon once\n  useEffect(() => {\n    const img = new Image();\n    img.src = influenceIconUrl;\n    influenceImgRef.current = img;\n  }, []);\n  const drawCardAt = useCallback((ctx, card, x, y, size, selected = false, showAPCost = false, player) => {\n    var _shield;\n    // Apply per-card fade-in if a play animation is active for this uid\n    let extraAlpha = 1;\n    try {\n      var _uid;\n      const uid = (_uid = card.uid) !== null && _uid !== void 0 ? _uid : card.id;\n      const list = visualEffects && visualEffects.playAnimsRef && visualEffects.playAnimsRef.current || window.__pc_play_anims || [];\n      const anim = list.find(a => a.uid === uid);\n      if (anim) {\n        const p = Math.min(1, Math.max(0, (performance.now() - anim.started) / anim.duration));\n        // ease-out\n        extraAlpha = Math.pow(p, 2);\n      }\n    } catch (e) {}\n    let dx = x,\n      dy = y,\n      s = size;\n    if (selected) {\n      s = Math.floor(size * 1.05);\n      dx = x - Math.floor((s - size) / 2);\n      dy = y - Math.floor((s - size) / 2);\n    }\n\n    // Note: pulse overlay is drawn at top layer after all cards are rendered\n\n    // Draw card image with caching to prevent flicker in continuous loop\n    const src = getCardImagePath(card, 'ui');\n    const cached = imageCacheRef.current.get(src);\n    ctx.save();\n    ctx.globalAlpha = extraAlpha;\n    if (cached && cached.complete && cached.naturalWidth > 0) {\n      ctx.drawImage(cached, dx, dy, s, s);\n    } else {\n      const img = new Image();\n      img.onload = () => {\n        imageCacheRef.current.set(src, img);\n        // Note: onload happens async; draw will occur on next frame\n        // don't draw here into stale ctx\n      };\n      img.src = src;\n      imageCacheRef.current.set(src, img);\n    }\n    ctx.restore();\n\n    // Status-Indikatoren (für alle Board-Karten)\n    // Einfluss-Wert dauerhaft anzeigen (oben links) – nur für Regierungskarten\n    if (card.kind === 'pol') {\n      var _influence;\n      const barH = Math.max(20, Math.floor(s * 0.12) + 6);\n      ctx.fillStyle = 'rgba(0,0,0,0.6)';\n      ctx.fillRect(dx, dy + s - barH, s, barH);\n      ctx.fillStyle = '#ffffff';\n      const fontSize = Math.floor(s * 0.12);\n      ctx.font = `bold ${fontSize}px sans-serif`;\n      ctx.textAlign = 'left';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(`${(_influence = card.influence) !== null && _influence !== void 0 ? _influence : 0}`, dx + 8, dy + s - barH / 2);\n    }\n    // Schutz-Status (blauer Punkt)\n    if (card.protected || ((_shield = card.shield) !== null && _shield !== void 0 ? _shield : 0) > 0) {\n      ctx.fillStyle = '#1da1f2';\n      ctx.fillRect(dx + s - 22, dy + 6, 16, 16);\n    }\n    // Deaktiviert-Status (roter Punkt)\n    if (card.deactivated) {\n      ctx.fillStyle = '#b63838';\n      ctx.fillRect(dx + s - 22, dy + 26, 16, 16);\n    }\n\n    // Einfluss-Badge für Handkarten oben rechts (nur Regierungskarten)\n    if (showAPCost && player && card.kind === 'pol') {\n      var _influence2;\n      const badgeHeight = Math.max(16, Math.floor(s * 0.12));\n      const badgeWidth = badgeHeight * 2;\n      const badgeX = dx + s - badgeWidth - 6;\n      const badgeY = dy + 6;\n\n      // Semi-transparent dunkler Hintergrund\n      ctx.fillStyle = 'rgba(0,0,0,0.6)';\n      ctx.beginPath();\n      ctx.roundRect(badgeX, badgeY, badgeWidth, badgeHeight, badgeHeight / 2);\n      ctx.fill();\n\n      // Influence icon (90% opacity) links im Badge\n      if (influenceImgRef.current && influenceImgRef.current.complete) {\n        ctx.globalAlpha = 0.9;\n        ctx.drawImage(influenceImgRef.current, badgeX + 2, badgeY + 2, badgeHeight - 4, badgeHeight - 4);\n        ctx.globalAlpha = 1;\n      }\n\n      // Influence number rechts im Badge\n      ctx.fillStyle = '#ffffff';\n      ctx.font = `bold ${Math.floor(badgeHeight * 0.5)}px sans-serif`;\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(`${(_influence2 = card.influence) !== null && _influence2 !== void 0 ? _influence2 : 0}`, badgeX + badgeWidth - 4, badgeY + badgeHeight / 2);\n\n      // Reset align\n      ctx.textAlign = 'start';\n      ctx.textBaseline = 'alphabetic';\n    }\n\n    // NOTE: influence overlays (pulse + labels) are drawn in a separate pass\n\n    // Auswahl-Rahmen\n    if (selected) {\n      ctx.strokeStyle = '#61dafb';\n      ctx.lineWidth = 3;\n      ctx.strokeRect(dx + 1, dy + 1, s - 2, s - 2);\n      ctx.lineWidth = 1;\n    }\n\n    // Return exact 256x256 click zone over the card\n    // Since all cards are 256x256, the click zone should match exactly\n    return {\n      x: dx,\n      y: dy,\n      w: 256,\n      h: 256\n    };\n  }, [gameState]);\n\n  // Slot-Benennungs-Funktion basierend auf Glossar\n  const getSlotDisplayName = useCallback((zoneId, index, player) => {\n    const slotNumber = index + 1;\n    if (zoneId.includes('government')) {\n      if (zoneId.includes('player')) {\n        return `Regierungsreihe Slot ${slotNumber}`;\n      } else {\n        return `Gegner Regierung Slot ${slotNumber}`;\n      }\n    } else if (zoneId.includes('public')) {\n      if (zoneId.includes('player')) {\n        return `Öffentlichkeitsreihe Slot ${slotNumber}`;\n      } else {\n        return `Gegner Öffentlichkeit Slot ${slotNumber}`;\n      }\n    } else if (zoneId.includes('permanent.government')) {\n      if (zoneId.includes('player')) {\n        return 'Regierung Spezial-Slot';\n      } else {\n        return 'Gegner Regierung Spezial-Slot';\n      }\n    } else if (zoneId.includes('permanent.public')) {\n      if (zoneId.includes('player')) {\n        return 'Öffentlichkeit Spezial-Slot';\n      } else {\n        return 'Gegner Öffentlichkeit Spezial-Slot';\n      }\n    } else if (zoneId.includes('instant')) {\n      if (zoneId.includes('player')) {\n        return 'Sofort-Slot';\n      } else {\n        return 'Gegner Sofort-Slot';\n      }\n    } else if (zoneId.includes('hand')) {\n      return 'Hand';\n    } else if (zoneId.includes('interventions')) {\n      return 'Interventionen';\n    }\n    return `Slot ${slotNumber}`;\n  }, []);\n  const drawLane = useCallback((ctx, zoneId, player, lane, clickable) => {\n    const zone = getZone(zoneId);\n    if (!zone) return;\n    const slots = computeSlotRects(zone);\n    const arr = gameState.board[player][lane];\n    slots.forEach((s, idx) => {\n      const card = arr[idx];\n\n      // Hintergrundfarbe nach Kategorie\n      let bgColor = 'rgba(0,0,0,0.1)'; // Standard\n      if (zoneId.includes('government')) {\n        bgColor = 'rgba(255, 197, 0, 0.15)'; // Hellgelb für Regierung\n      } else if (zoneId.includes('public')) {\n        bgColor = 'rgba(0, 255, 0, 0.15)'; // Hellgrün für Öffentlichkeit\n      }\n      ctx.fillStyle = bgColor;\n      ctx.fillRect(s.x, s.y, s.w, s.h);\n\n      // Slot-Rahmen\n      ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n      ctx.strokeRect(s.x + 0.5, s.y + 0.5, s.w - 1, s.h - 1);\n      if (card) {\n        const isSelected = player === 1 && selectedHandIndex !== null && gameState.hands[1][selectedHandIndex] === card;\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, isSelected, false);\n\n        // Kartenname unter dem Slot anzeigen\n        ctx.fillStyle = 'rgba(255,255,255,0.9)';\n        ctx.font = 'bold 12px sans-serif';\n        ctx.textAlign = 'center';\n        const textY = s.y + s.h + 16;\n        ctx.fillText(card.name, s.x + s.w / 2, textY);\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: {\n            type: 'board_card',\n            player,\n            lane,\n            index: idx,\n            card\n          }\n        });\n      } else if (clickable && gameState.current === player) {\n        // Slot-Benennung anzeigen (für den aktuellen Spieler)\n        const slotName = getSlotDisplayName(zoneId, idx, player);\n        ctx.fillStyle = 'rgba(255,255,255,0.6)';\n        ctx.font = '11px sans-serif';\n        ctx.textAlign = 'center';\n        const textY = s.y + s.h / 2;\n        ctx.fillText(slotName, s.x + s.w / 2, textY);\n        clickZonesRef.current.push({\n          x: s.x,\n          y: s.y,\n          w: s.w,\n          h: s.h,\n          data: {\n            type: 'row_slot',\n            lane,\n            index: idx\n          }\n        });\n      }\n    });\n  }, [gameState, selectedHandIndex, drawCardAt, getSlotDisplayName]);\n  const drawHandP1 = useCallback(ctx => {\n    const hand = sortHandCards(gameState.hands[1]);\n    const zone = getZone('hand.player');\n    if (!zone) return;\n    const slots = computeSlotRects(zone);\n    // Apply smooth offset (lerp towards target)\n    const target = handScrollTargetRef.current;\n    handScrollCurrentRef.current += (target - handScrollCurrentRef.current) * 0.15; // easing\n    const offsetY = Math.round(handScrollCurrentRef.current);\n    slots.forEach((s, i) => {\n      const card = hand[i];\n      if (!card) return;\n      // Find original index in unsorted hand for click handling\n      const originalIndex = gameState.hands[1].findIndex(c => c.uid === card.uid);\n      const isSel = selectedHandIndex === originalIndex;\n      // apply vertical offset\n      const sx = s.x;\n      const sy = s.y + offsetY;\n      const clickZone = drawCardAt(ctx, card, sx, sy, s.w, isSel, true, 1); // Show AP cost for player 1 hand\n      clickZonesRef.current.push({\n        ...clickZone,\n        data: {\n          type: 'hand_p1',\n          index: originalIndex,\n          card\n        }\n      });\n    });\n  }, [gameState.hands, selectedHandIndex, drawCardAt]);\n\n  // 🔧 DEV MODE: Player 2 Hand (rechts unten, kompakter)\n  const drawHandP2 = useCallback(ctx => {\n    const hand = sortHandCards(gameState.hands[2]);\n    const zone = getZone('hand.opponent');\n    if (!zone) return;\n    const slots = computeSlotRects(zone);\n\n    // Hintergrund für P2 Hand\n    const [x, y, w, h] = zone.rectPx;\n    ctx.fillStyle = 'rgba(255, 100, 100, 0.15)'; // Rötlicher Hintergrund für P2\n    ctx.fillRect(x, y, w, h);\n    ctx.strokeStyle = 'rgba(255, 100, 100, 0.3)';\n    ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);\n\n    // Label für P2 Hand\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n    ctx.font = 'bold 14px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Player 2 Hand', x + w / 2, y - 8);\n    slots.forEach((s, i) => {\n      const card = hand[i];\n      if (!card) return;\n      // Find original index in unsorted hand for click handling\n      const originalIndex = gameState.hands[2].findIndex(c => c.uid === card.uid);\n      const isSel = gameState.current === 2 && selectedHandIndex === originalIndex;\n      const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, isSel, true, 2); // Show AP cost for player 2 hand\n      clickZonesRef.current.push({\n        ...clickZone,\n        data: {\n          type: 'hand_p2',\n          index: originalIndex,\n          card\n        }\n      });\n    });\n  }, [gameState, selectedHandIndex, drawCardAt]);\n  // Interventions strip (player traps)\n  const drawInterventionsP1 = useCallback(ctx => {\n    const traps = gameState.traps[1] || [];\n    const zone = getZone('interventions.player');\n    if (!zone) return;\n\n    // Single intervention slot\n    const [zx, zy, zw, zh] = zone.rectPx;\n    const card = traps[0]; // Only first trap\n\n    // Hintergrund für Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.15)'; // Lavendelfarben für Interventionen\n    ctx.fillRect(zx, zy, zw, zh);\n    ctx.strokeStyle = 'rgba(200, 160, 255, 0.3)';\n    ctx.strokeRect(zx + 0.5, zy + 0.5, zw - 1, zh - 1);\n\n    // Slot-Benennung für Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.8)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Intervention', zx + 8, zy + zh - 6);\n    if (card) {\n      const clickZone = drawCardAt(ctx, card, zx, zy, zw, false, false);\n      clickZonesRef.current.push({\n        ...clickZone,\n        data: {\n          type: 'trap_p1',\n          index: 0,\n          card\n        }\n      });\n    }\n  }, [gameState.traps, drawCardAt]);\n\n  // Interventions strip (opponent traps)\n  const drawInterventionsP2 = useCallback(ctx => {\n    const traps = gameState.traps[2] || [];\n    const zone = getZone('interventions.opponent');\n    if (!zone) return;\n\n    // Single intervention slot\n    const [zx, zy, zw, zh] = zone.rectPx;\n    const card = traps[0]; // Only first trap\n\n    // Hintergrund für Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.15)'; // Lavendelfarben für Interventionen\n    ctx.fillRect(zx, zy, zw, zh);\n    ctx.strokeStyle = 'rgba(200, 160, 255, 0.3)';\n    ctx.strokeRect(zx + 0.5, zy + 0.5, zw - 1, zh - 1);\n\n    // Slot-Benennung für Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.8)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Intervention', zx + 8, zy + zh - 6);\n    if (card) {\n      const clickZone = drawCardAt(ctx, card, zx, zy, zw, false, false);\n      clickZonesRef.current.push({\n        ...clickZone,\n        data: {\n          type: 'trap_p2',\n          index: 0,\n          card\n        }\n      });\n    }\n  }, [gameState.traps, drawCardAt]);\n\n  // Single slot drawing function\n  const drawSingleSlot = useCallback((ctx, zoneId, card, clickType, player) => {\n    const zone = getZone(zoneId);\n    if (!zone) return;\n    const [x, y, w, h] = zone.rectPx;\n\n    // Hintergrundfarbe nach Kategorie\n    let bgColor = 'rgba(0,0,0,0.1)'; // Standard\n    if (zoneId.includes('government')) {\n      bgColor = 'rgba(255, 197, 0, 0.15)'; // Hellgelb für Regierung\n    } else if (zoneId.includes('public')) {\n      bgColor = 'rgba(0, 255, 0, 0.15)'; // Hellgrün für Öffentlichkeit\n    } else if (zoneId.includes('instant')) {\n      bgColor = 'rgba(127, 116, 91, 0.15)'; // Neutral für Sofort-Slots\n    } else if (zoneId.includes('permanent')) {\n      // Unterscheide zwischen government und public permanent slots\n      if (zoneId.includes('government')) {\n        bgColor = 'rgba(255, 197, 0, 0.15)';\n      } else if (zoneId.includes('public')) {\n        bgColor = 'rgba(0, 255, 0, 0.15)';\n      }\n    }\n    ctx.fillStyle = bgColor;\n    ctx.fillRect(x, y, w, h);\n\n    // Draw slot border\n    ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n    ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);\n    if (card) {\n      const isSelected = player === 1 && selectedHandIndex !== null && gameState.hands[1][selectedHandIndex] === card;\n      const clickZone = drawCardAt(ctx, card, x, y, w, isSelected, false);\n\n      // Kartenname unter dem Slot anzeigen\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.font = 'bold 12px sans-serif';\n      ctx.textAlign = 'center';\n      const textY = y + h + 16;\n      ctx.fillText(card.name, x + w / 2, textY);\n\n      // Register click zone for the card - always in dev mode, otherwise only for current player\n      if (devMode || player === gameState.current) {\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: {\n            type: 'slot_card',\n            slot: clickType,\n            player,\n            card\n          }\n        });\n      }\n\n      // 🔧 NEU: Sofort-Initiative-Slots sind immer klickbar für Aktivierung (handled by activateInstantInitiative)\n      if (clickType === 'instant') {\n        clickZonesRef.current.push({\n          x,\n          y,\n          w,\n          h,\n          data: {\n            type: 'activate_instant',\n            player,\n            card\n          }\n        });\n      }\n    } else if (gameState.current === player || devMode) {\n      // Slot-Benennung für leere Slots anzeigen (für den aktuellen Spieler oder im Dev Mode)\n      const slotName = getSlotDisplayName(zoneId, 0, player);\n      ctx.fillStyle = 'rgba(255,255,255,0.6)';\n      ctx.font = '11px sans-serif';\n      ctx.textAlign = 'center';\n      const textY = y + h / 2;\n      ctx.fillText(slotName, x + w / 2, textY);\n      clickZonesRef.current.push({\n        x,\n        y,\n        w,\n        h,\n        data: {\n          type: 'empty_slot',\n          slot: clickType,\n          player\n        }\n      });\n    }\n  }, [selectedHandIndex, gameState, drawCardAt, getSlotDisplayName, devMode]);\n\n  // Small UI hook: show a lightweight corruption modal overlay when a target is selected\n  useEffect(() => {\n    const onTargetSelected = ev => {\n      const {\n        player,\n        targetUid\n      } = ev.detail || {};\n      if (!player || !targetUid) return;\n      // create transient overlay element if not present\n      try {\n        var _board, _board2, _board2$aussen, _board3, _board4, _board4$aussen;\n        const id = 'pc-corruption-modal';\n        let el = document.getElementById(id);\n        if (!el) {\n          el = document.createElement('div');\n          el.id = id;\n          el.style.position = 'fixed';\n          el.style.left = '50%';\n          el.style.top = '40%';\n          el.style.transform = 'translate(-50%, -50%)';\n          el.style.padding = '12px 16px';\n          el.style.background = 'rgba(6,10,15,0.9)';\n          el.style.border = '1px solid rgba(255,255,255,0.12)';\n          el.style.borderRadius = '8px';\n          el.style.zIndex = '3000';\n          el.style.color = '#e5e7eb';\n          el.style.fontFamily = 'monospace';\n          el.style.fontSize = '14px';\n          document.body.appendChild(el);\n        }\n        const card = ((_board = gameState.board) === null || _board === void 0 ? void 0 : (_board2 = _board[player === 1 ? 1 : 2]) === null || _board2 === void 0 ? void 0 : (_board2$aussen = _board2.aussen) === null || _board2$aussen === void 0 ? void 0 : _board2$aussen.find(c => c.uid === targetUid)) || ((_board3 = gameState.board) === null || _board3 === void 0 ? void 0 : (_board4 = _board3[player === 1 ? 2 : 1]) === null || _board4 === void 0 ? void 0 : (_board4$aussen = _board4.aussen) === null || _board4$aussen === void 0 ? void 0 : _board4$aussen.find(c => c.uid === targetUid));\n        el.innerHTML = `<div style=\"display:flex;flex-direction:column;gap:8px;min-width:260px;\">\n          <div style=\"font-weight:700\">Bestechungsskandal 2.0 — Ziel gewählt</div>\n          <div>Gewähltes Ziel: <b>${card ? card.name : 'UID ' + targetUid}</b></div>\n          <div>Probe: W6 ≥ Einfluss (inkl. Oligarch-Bonus)</div>\n          <div style=\"display:flex;gap:8px;justify-content:flex-end;\">\n            <button id=\"pc-corruption-roll\" style=\"background:#2563eb;color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;\">Würfeln</button>\n            <button id=\"pc-corruption-cancel\" style=\"background:#374151;color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;\">Abbrechen</button>\n          </div>\n        </div>`;\n        const rollBtn = document.getElementById('pc-corruption-roll');\n        const cancelBtn = document.getElementById('pc-corruption-cancel');\n        if (rollBtn) {\n          rollBtn.onclick = () => {\n            try {\n              console.log('🔥 CORRUPTION WÜRFELN CLICKED - triggering dice roll');\n              // Trigger the dice component to roll\n              window.dispatchEvent(new CustomEvent('pc:ui_request_dice_roll', {\n                detail: {\n                  player,\n                  targetUid\n                }\n              }));\n              window.dispatchEvent(new CustomEvent('pc:corruption_request_roll', {\n                detail: {\n                  player,\n                  targetUid\n                }\n              }));\n            } catch (e) {\n              console.error('🔥 ERROR triggering dice roll:', e);\n            }\n            // disable until result\n            rollBtn.disabled = true;\n            rollBtn.innerText = 'Würfelt...';\n          };\n        }\n        if (cancelBtn) {\n          cancelBtn.onclick = () => {\n            el.remove();\n          };\n        }\n      } catch (e) {\n        console.debug('corruption modal create failed', e);\n      }\n    };\n    window.addEventListener('pc:corruption_target_selected', onTargetSelected);\n    return () => window.removeEventListener('pc:corruption_target_selected', onTargetSelected);\n  }, [gameState]);\n\n  // Draw permanent slots for player\n  const drawPermanentSlotsP1 = useCallback(ctx => {\n    drawSingleSlot(ctx, 'slot.permanent.government.player', gameState.permanentSlots[1].government, 'permanent_government', 1);\n    drawSingleSlot(ctx, 'slot.permanent.public.player', gameState.permanentSlots[1].public, 'permanent_public', 1);\n  }, [gameState.permanentSlots, drawSingleSlot]);\n\n  // Draw permanent slots for opponent\n  const drawPermanentSlotsP2 = useCallback(ctx => {\n    drawSingleSlot(ctx, 'slot.permanent.government.opponent', gameState.permanentSlots[2].government, 'permanent_government', 2);\n    drawSingleSlot(ctx, 'slot.permanent.public.opponent', gameState.permanentSlots[2].public, 'permanent_public', 2);\n  }, [gameState.permanentSlots, drawSingleSlot]);\n\n  // Draw instant slots\n  const drawInstantSlots = useCallback(ctx => {\n    // Sofort-Initiative-Slots aus dem Board zeichnen\n    const sofortPlayerCard = gameState.board[1].sofort[0];\n    const sofortOppCard = gameState.board[2].sofort[0];\n    drawSingleSlot(ctx, 'slot.instant.player', sofortPlayerCard, 'instant', 1);\n    drawSingleSlot(ctx, 'slot.instant.opponent', sofortOppCard, 'instant', 2);\n  }, [gameState.board, drawSingleSlot]);\n\n  // Aktive Schlüsselwörter und Unterkategorien ermitteln\n  const getActiveKeywordsAndSubcategories = useCallback(player => {\n    const board = gameState.board[player];\n    const permanentSlots = gameState.permanentSlots[player];\n    const allCards = [...board.innen, ...board.aussen, permanentSlots.government, permanentSlots.public].filter(c => c && c.kind === 'pol');\n    const keywords = new Set();\n    const subcategories = new Set();\n    allCards.forEach(card => {\n      if (!card.deactivated) {\n        // Regierungskarten-Schlüsselwörter\n        if (card.tag === 'Leadership') {\n          keywords.add('Leadership');\n        }\n        if (card.tag === 'Diplomat') {\n          keywords.add('Diplomat');\n        }\n\n        // Öffentlichkeits-Unterkategorien (für Karten in Öffentlichkeitsreihe)\n        if (board.innen.includes(card)) {\n          const publicCard = card;\n          if (publicCard.tag) {\n            // Oligarch\n            const oligarchNames = ['Elon Musk', 'Bill Gates', 'George Soros', 'Warren Buffett', 'Mukesh Ambani', 'Jeff Bezos', 'Alisher Usmanov', 'Gautam Adani', 'Jack Ma', 'Zhang Yiming', 'Roman Abramovich'];\n            if (oligarchNames.includes(publicCard.name)) {\n              subcategories.add('Oligarch');\n            }\n\n            // Plattform\n            const platformNames = ['Mark Zuckerberg', 'Tim Cook', 'Sam Altman', 'Jack Ma'];\n            if (platformNames.includes(publicCard.name)) {\n              subcategories.add('Plattform');\n            }\n\n            // Bewegung\n            const movementNames = ['Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'];\n            if (movementNames.includes(publicCard.name)) {\n              subcategories.add('Bewegung');\n            }\n\n            // NGO/Think-Tank\n            const ngoNames = ['Bill Gates', 'George Soros', 'Jennifer Doudna', 'Noam Chomsky', 'Anthony Fauci'];\n            if (ngoNames.includes(publicCard.name)) {\n              subcategories.add('NGO/Think-Tank');\n            }\n\n            // Intelligenz\n            const intelligenceNames = ['Jennifer Doudna', 'Noam Chomsky', 'Edward Snowden', 'Julian Assange', 'Yuval Noah Harari', 'Ai Weiwei', 'Alexei Navalny', 'Anthony Fauci'];\n            if (intelligenceNames.includes(publicCard.name)) {\n              subcategories.add('Intelligenz');\n            }\n\n            // Medien\n            const mediaNames = ['Oprah Winfrey'];\n            if (mediaNames.includes(publicCard.name)) {\n              subcategories.add('Medien');\n            }\n          }\n        }\n      }\n    });\n    return {\n      keywords: Array.from(keywords),\n      subcategories: Array.from(subcategories)\n    };\n  }, [gameState]);\n\n  // Info-Panels zeichnen\n  const drawInfoPanels = useCallback(ctx => {\n    const {\n      keywords,\n      subcategories\n    } = getActiveKeywordsAndSubcategories(1);\n\n    // Panel für Regierungsschlüsselwörter (rechts neben Regierungsslots)\n    const govPanelX = 1640 + 256 + 20; // Nach dem letzten permanenten Slot\n    const govPanelY = 300; // Auf Höhe der Regierungsslots\n    const govPanelW = 120;\n    const govPanelH = 256;\n\n    // Regierungspanel Hintergrund\n    ctx.fillStyle = 'rgba(255, 197, 0, 0.15)';\n    ctx.fillRect(govPanelX, govPanelY, govPanelW, govPanelH);\n    ctx.strokeStyle = 'rgba(255, 197, 0, 0.3)';\n    ctx.strokeRect(govPanelX + 0.5, govPanelY + 0.5, govPanelW - 1, govPanelH - 1);\n\n    // Regierungspanel Titel\n    ctx.fillStyle = 'rgba(255, 197, 0, 0.9)';\n    ctx.font = 'bold 12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Regierung', govPanelX + govPanelW / 2, govPanelY + 16);\n\n    // Schlüsselwörter auflisten\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    if (keywords.length > 0) {\n      keywords.forEach((keyword, idx) => {\n        ctx.fillText(`• ${keyword}`, govPanelX + 8, govPanelY + 36 + idx * 16);\n      });\n    } else {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\n      ctx.fillText('Keine aktiven', govPanelX + 8, govPanelY + 36);\n      ctx.fillText('Schlüsselwörter', govPanelX + 8, govPanelY + 52);\n    }\n\n    // Panel für Öffentlichkeits-Unterkategorien (rechts neben Öffentlichkeitsslots)\n    const pubPanelX = 1640 + 256 + 20;\n    const pubPanelY = 580; // Auf Höhe der Öffentlichkeitsslots\n    const pubPanelW = 120;\n    const pubPanelH = 256;\n\n    // Öffentlichkeitspanel Hintergrund\n    ctx.fillStyle = 'rgba(0, 255, 0, 0.15)';\n    ctx.fillRect(pubPanelX, pubPanelY, pubPanelW, pubPanelH);\n    ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';\n    ctx.strokeRect(pubPanelX + 0.5, pubPanelY + 0.5, pubPanelW - 1, pubPanelH - 1);\n\n    // Öffentlichkeitspanel Titel\n    ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';\n    ctx.font = 'bold 12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Öffentlichkeit', pubPanelX + pubPanelW / 2, pubPanelY + 16);\n\n    // Unterkategorien auflisten\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    if (subcategories.length > 0) {\n      subcategories.forEach((subcategory, idx) => {\n        const displayName = subcategory.length > 12 ? subcategory.substring(0, 10) + '...' : subcategory;\n        ctx.fillText(`• ${displayName}`, pubPanelX + 8, pubPanelY + 36 + idx * 16);\n      });\n    } else {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\n      ctx.fillText('Keine aktiven', pubPanelX + 8, pubPanelY + 36);\n      ctx.fillText('Unterkategorien', pubPanelX + 8, pubPanelY + 52);\n    }\n  }, [getActiveKeywordsAndSubcategories]);\n\n  // Move diagnostics to draw callback to ensure they run after canvas is actually rendered\n  const runDiagnostics = useCallback(() => {\n    try {\n      const handZones = clickZonesRef.current.filter(z => z.data && z.data.type === 'hand_p1');\n      const uiUIDs = handZones.map(z => {\n        var _z$data$card$uid;\n        return z.data.card && ((_z$data$card$uid = z.data.card.uid) !== null && _z$data$card$uid !== void 0 ? _z$data$card$uid : z.data.card.id);\n      }).filter(Boolean);\n      const stateHand = gameState.hands && gameState.hands[1] ? gameState.hands[1] : [];\n      const stateUIDs = stateHand.map(c => {\n        var _c$uid;\n        return (_c$uid = c.uid) !== null && _c$uid !== void 0 ? _c$uid : c.id;\n      }).filter(Boolean);\n      const missingInState = uiUIDs.filter(u => !stateUIDs.includes(u));\n      const missingInUI = stateUIDs.filter(u => !uiUIDs.includes(u));\n\n      // Only warn if there are cards in UI that don't exist in state (real error)\n      // Don't warn about missing UI cards due to limited slot capacity\n      if (missingInState.length > 0) {\n        var _politicardDebug;\n        const mismatch = {\n          ts: Date.now(),\n          uiCount: uiUIDs.length,\n          stateCount: stateUIDs.length,\n          uiUIDs,\n          stateUIDs,\n          missingInState,\n          missingInUI,\n          stack: new Error('mismatch-stack').stack\n        };\n        window.__politicardDebug = {\n          ...window.__politicardDebug,\n          mismatch: [...(((_politicardDebug = window.__politicardDebug) === null || _politicardDebug === void 0 ? void 0 : _politicardDebug.mismatch) || [])].slice(-19).concat([mismatch])\n        };\n        // Clear, then log to console so user can copy/paste trace\n        console.warn('POLITICARD DIAGNOSTIC: hand mismatch detected', mismatch);\n      }\n    } catch (e) {\n      // swallow diagnostic errors to avoid breaking rendering\n      console.error('Diagnostic error', e);\n    }\n  }, [gameState.hands]);\n  const draw = useCallback(() => {\n    var _LAYOUT$background, _LAYOUT$background2;\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Detect influence increases and start animations\n    try {\n      const currSnapshot = {};\n      const collect = c => {\n        var _c$uid2, _c$influence;\n        if (!c) return;\n        if (c.kind !== 'pol') return;\n        const uid = (_c$uid2 = c.uid) !== null && _c$uid2 !== void 0 ? _c$uid2 : c.id != null ? String(c.id) : null;\n        if (!uid) return;\n        currSnapshot[uid] = (_c$influence = c.influence) !== null && _c$influence !== void 0 ? _c$influence : 0;\n      };\n      // board rows\n      (gameState.board[1].aussen || []).forEach(collect);\n      (gameState.board[2].aussen || []).forEach(collect);\n      (gameState.board[1].innen || []).forEach(collect);\n      (gameState.board[2].innen || []).forEach(collect);\n      // permanent slots\n      collect(gameState.permanentSlots[1].government);\n      collect(gameState.permanentSlots[2].government);\n      collect(gameState.permanentSlots[1].public);\n      collect(gameState.permanentSlots[2].public);\n      const now = performance.now();\n      Object.keys(currSnapshot).forEach(uid => {\n        var _currSnapshot$uid, _prevInfluencesRef$cu;\n        const curr = (_currSnapshot$uid = currSnapshot[uid]) !== null && _currSnapshot$uid !== void 0 ? _currSnapshot$uid : 0;\n        const prev = (_prevInfluencesRef$cu = prevInfluencesRef.current[uid]) !== null && _prevInfluencesRef$cu !== void 0 ? _prevInfluencesRef$cu : curr;\n        if (curr > prev) {\n          const delta = curr - prev;\n          const list = influenceAnimRef.current.get(uid) || [];\n          list.push({\n            start: now,\n            duration: 900,\n            amount: delta\n          });\n          influenceAnimRef.current.set(uid, list);\n        }\n        prevInfluencesRef.current[uid] = curr;\n      });\n    } catch (e) {\n      // ignore\n    }\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Clear click zones\n    clickZonesRef.current = [];\n\n    // Background: prefer PNG if configured\n    if ((_LAYOUT$background = LAYOUT.background) !== null && _LAYOUT$background !== void 0 && _LAYOUT$background.enabled && (_LAYOUT$background2 = LAYOUT.background) !== null && _LAYOUT$background2 !== void 0 && _LAYOUT$background2.src) {\n      if (backgroundImageRef.current) {\n        ctx.drawImage(backgroundImageRef.current, 0, 0, canvas.width, canvas.height);\n      } else {\n        ctx.fillStyle = '#0c131b';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n      }\n    } else {\n      ctx.fillStyle = '#0c131b';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Apply UI transform (new signature)\n    const {\n      scale,\n      offsetX,\n      offsetY\n    } = getUiTransform(canvas.width, canvas.height);\n    ctx.save();\n    ctx.translate(offsetX, offsetY);\n    ctx.scale(scale, scale);\n\n    // Draw opponent board (top rows) - clickable im Dev Mode\n    // Draw opponent board using new layout system\n    const opponentPublicRects = getPublicRects('opponent');\n    const opponentGovRects = getGovernmentRects('opponent');\n\n    // Draw opponent public slots\n    opponentPublicRects.forEach((s, idx) => {\n      const card = gameState.board[2].innen[idx];\n      if (card) {\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 2);\n        // Register hover/click zone for opponent card (always) - include card for hover info\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: {\n            type: 'board_card',\n            player: 2,\n            lane: 'innen',\n            index: idx,\n            card\n          }\n        });\n      } else {\n        // draw placeholder symbol for empty public slot\n        const img = slotSymbolImgsRef.current.get('public');\n        drawSlotIconWithPulse(ctx, img, s.x, s.y, s.w, s.h, 0.4);\n        // Register empty slot click zone in dev mode\n        if (devMode) {\n          clickZonesRef.current.push({\n            x: s.x,\n            y: s.y,\n            w: s.w,\n            h: s.h,\n            data: {\n              type: 'row_slot',\n              player: 2,\n              lane: 'innen',\n              index: idx\n            }\n          });\n        }\n      }\n    });\n\n    // Draw opponent government slots\n    opponentGovRects.forEach((s, idx) => {\n      const card = gameState.board[2].aussen[idx];\n      const corrActive = !!(gameState.pendingAbilitySelect && gameState.pendingAbilitySelect.type === 'corruption_steal');\n      if (card) {\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 2);\n        // Register hover/click zone for opponent card (always) - include card for hover info\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: {\n            type: 'board_card',\n            player: 2,\n            lane: 'aussen',\n            index: idx,\n            card\n          }\n        });\n        // When corruption target selection is active, register exact slot rectangle for click detection\n        if (corrActive) {\n          clickZonesRef.current.push({\n            x: s.x,\n            y: s.y,\n            w: s.w,\n            h: s.h,\n            data: {\n              type: 'board_card',\n              player: 2,\n              lane: 'aussen',\n              index: idx,\n              card\n            }\n          });\n        }\n      } else {\n        const img = slotSymbolImgsRef.current.get('government');\n        drawSlotIconWithPulse(ctx, img, s.x, s.y, s.w, s.h, 0.1);\n        // Register empty slot click zone only in dev mode\n        if (devMode) {\n          clickZonesRef.current.push({\n            x: s.x,\n            y: s.y,\n            w: s.w,\n            h: s.h,\n            data: {\n              type: 'row_slot',\n              player: 2,\n              lane: 'aussen',\n              index: idx\n            }\n          });\n        }\n      }\n    });\n\n    // Draw opponent permanent slots (show icons even when not current)\n    try {\n      const permGovZoneOpp = getZone('slot.permanent.government.opponent');\n      if (permGovZoneOpp) {\n        const card = gameState.permanentSlots[2].government;\n        const [ox, oy, ow, oh] = permGovZoneOpp.rectPx;\n        if (card) {\n          drawSingleSlot(ctx, 'slot.permanent.government.opponent', card, 'permanent_government', 2);\n        } else {\n          const img = slotSymbolImgsRef.current.get('dauerhaft');\n          drawSlotIconWithPulse(ctx, img, ox, oy, ow, oh, 0.3);\n          // Register empty slot click zone in dev mode\n          if (devMode) {\n            clickZonesRef.current.push({\n              x: ox,\n              y: oy,\n              w: ow,\n              h: oh,\n              data: {\n                type: 'empty_slot',\n                slot: 'permanent_government',\n                player: 2\n              }\n            });\n          }\n        }\n      }\n    } catch (e) {}\n    try {\n      const permPubZoneOpp = getZone('slot.permanent.public.opponent');\n      if (permPubZoneOpp) {\n        const card = gameState.permanentSlots[2].public;\n        const [ox2, oy2, ow2, oh2] = permPubZoneOpp.rectPx;\n        if (card) {\n          drawSingleSlot(ctx, 'slot.permanent.public.opponent', card, 'permanent_public', 2);\n        } else {\n          const img = slotSymbolImgsRef.current.get('dauerhaft');\n          drawSlotIconWithPulse(ctx, img, ox2, oy2, ow2, oh2, 0.7);\n          // Register empty slot click zone in dev mode\n          if (devMode) {\n            clickZonesRef.current.push({\n              x: ox2,\n              y: oy2,\n              w: ow2,\n              h: oh2,\n              data: {\n                type: 'empty_slot',\n                slot: 'permanent_public',\n                player: 2\n              }\n            });\n          }\n        }\n      }\n    } catch (e) {}\n\n    // Draw player board (middle rows)\n    // Draw player board using new layout system\n    const playerPublicRects = getPublicRects('player');\n    const playerGovRects = getGovernmentRects('player');\n\n    // Draw player public slots\n    playerPublicRects.forEach((s, idx) => {\n      const card = gameState.board[1].innen[idx];\n      if (card) {\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 1);\n        // register card zone including card so hover panel can show details\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: {\n            type: 'board_card',\n            player: 1,\n            lane: 'innen',\n            index: idx,\n            card\n          }\n        });\n      } else {\n        // Empty slot click zone and draw public symbol\n        // Draw unified pulsing icon for empty public slot\n        const img = slotSymbolImgsRef.current.get('public');\n        drawSlotIconWithPulse(ctx, img, s.x, s.y, s.w, s.h, 0.4);\n        clickZonesRef.current.push({\n          x: s.x,\n          y: s.y,\n          w: s.w,\n          h: s.h,\n          data: {\n            type: 'row_slot',\n            player: 1,\n            lane: 'innen',\n            index: idx\n          }\n        });\n      }\n    });\n\n    // Draw player government slots\n    playerGovRects.forEach((s, idx) => {\n      const card = gameState.board[1].aussen[idx];\n      if (card) {\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 1);\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: {\n            type: 'board_card',\n            player: 1,\n            lane: 'aussen',\n            index: idx,\n            card\n          }\n        });\n      } else {\n        // Empty slot click zone and draw government symbol\n        const img = slotSymbolImgsRef.current.get('government');\n        drawSlotIconWithPulse(ctx, img, s.x, s.y, s.w, s.h, 0.1);\n        clickZonesRef.current.push({\n          x: s.x,\n          y: s.y,\n          w: s.w,\n          h: s.h,\n          data: {\n            type: 'row_slot',\n            player: 1,\n            lane: 'aussen',\n            index: idx\n          }\n        });\n      }\n    });\n\n    // --- GOV PLACEMENT SPRITESHEET OVERLAY (frame-based) ---\n    try {\n      const sprites = govSpritesRef.current;\n      const gif = govGifRef.current;\n      const anims = visualEffects && visualEffects.playAnimsRef && visualEffects.playAnimsRef.current || [];\n\n      // Start sprite animation when a playAnim for a gov-card is active and maps to a slot\n      const now = performance.now();\n      // Prefer mutating the source anim array so entries are consumed and don't retrigger repeatedly\n      const animsArr = visualEffects && visualEffects.playAnimsRef && visualEffects.playAnimsRef.current || (window.__pc_play_anims = window.__pc_play_anims || []);\n\n      // Iterate backwards and consume processed animations to ensure one-shot playback\n      for (let i = animsArr.length - 1; i >= 0; i--) {\n        var _zone$data$player, _zone$data$lane, _zone$data$index;\n        const a = animsArr[i];\n        try {\n          // handle specialized 'hit:' playAnims which indicate target-hit sprites by slot key\n          if (typeof a.uid === 'string' && a.uid.indexOf('hit:') === 0) {\n            const inner = a.uid.slice(4); // '1.aussen.0'\n            if (!hitSpriteStateRef.current[inner]) {\n              hitSpriteStateRef.current[inner] = {\n                started: now,\n                frameCount: 25,\n                frameDuration: 30\n              };\n              animsArr.splice(i, 1);\n            }\n            continue;\n          }\n        } catch (e) {}\n\n        // find the zone/slot for this uid\n        const zone = clickZonesRef.current.find(z => {\n          var _z$data$card$uid2;\n          return z.data && z.data.card && ((_z$data$card$uid2 = z.data.card.uid) !== null && _z$data$card$uid2 !== void 0 ? _z$data$card$uid2 : String(z.data.card.id)) === a.uid;\n        });\n        if (!zone) continue;\n\n        // determine if gov slot or instant\n        let isGov = false;\n        let isInstant = false;\n        try {\n          const dt = zone.data || {};\n          if (dt.type === 'row_slot' && dt.lane === 'aussen') isGov = true;\n          if (dt.type === 'board_card' && dt.lane === 'aussen') isGov = true;\n          if (dt.slot && typeof dt.slot === 'string' && dt.slot.includes('government')) isGov = true;\n          if (dt.type === 'activate_instant' || dt.slot && typeof dt.slot === 'string' && dt.slot.includes('instant')) isInstant = true;\n        } catch (e) {}\n        if (!isGov && !isInstant) continue;\n        const player = (_zone$data$player = zone.data.player) !== null && _zone$data$player !== void 0 ? _zone$data$player : 1;\n        const lane = (_zone$data$lane = zone.data.lane) !== null && _zone$data$lane !== void 0 ? _zone$data$lane : 'aussen';\n        const idx = (_zone$data$index = zone.data.index) !== null && _zone$data$index !== void 0 ? _zone$data$index : 0;\n        const key = `${player}.${lane}.${idx}`;\n\n        // initialize sprite state if not present; consume the anim entry only when we actually start playback\n        let startedThis = false;\n        if (isGov) {\n          if (!govSpriteStateRef.current[key]) {\n            govSpriteStateRef.current[key] = {\n              started: now,\n              frameCount: 14,\n              frameDuration: 40\n            }; // 14 frames @ ~40ms -> ~560ms\n            startedThis = true;\n          }\n        }\n        if (isInstant) {\n          const instKey = `${player}.instant.${idx}`;\n          if (!instantSpriteStateRef.current[instKey]) {\n            instantSpriteStateRef.current[instKey] = {\n              started: now,\n              frameCount: 14,\n              frameDuration: 40\n            };\n            startedThis = true;\n          }\n        }\n        if (startedThis) {\n          animsArr.splice(i, 1);\n        }\n      }\n\n      // draw running sprite animations per gov slot\n      Object.keys(govSpriteStateRef.current).forEach(k => {\n        const st = govSpriteStateRef.current[k];\n        const elapsed = now - st.started;\n        const total = st.frameCount * st.frameDuration;\n        if (elapsed > total) {\n          // animation finished; remove state\n          delete govSpriteStateRef.current[k];\n          return;\n        }\n        const frame = Math.floor(elapsed / st.frameDuration);\n\n        // parse key -> player.lane.index\n        const parts = k.split('.');\n        const player = Number(parts[0]) || 1;\n        const lane = parts[1] || 'aussen';\n        const index = Number(parts[2] || 0);\n\n        // compute slot rect for this gov slot (player or opponent board)\n        const rect = player === 1 ? playerGovRects[index] : opponentGovRects[index];\n        if (!rect) return;\n\n        // spritesheet: frame N located at x = N*256, y = 0\n        if (sprites && sprites.complete) {\n          const sx = frame * 256;\n          const sy = 0;\n          const sw = 256;\n          const sh = 256;\n          // draw exactly matching the slot rect size to avoid scaling mismatches\n          const dx = rect.x;\n          const dy = rect.y;\n          ctx.drawImage(sprites, sx, sy, sw, sh, dx, dy, rect.w, rect.h);\n        } else if (gif && gif.complete) {\n          // fallback to static gif if spritesheet missing\n          ctx.drawImage(gif, rect.x, rect.y, rect.w, rect.h);\n        }\n      });\n      // --- INSTANT INITIATIVE SPRITESHEET (draw on instant slot) ---\n      try {\n        const spritesI = instantSpritesRef.current;\n        const nowI = performance.now();\n        Object.keys(instantSpriteStateRef.current).forEach(k => {\n          const st = instantSpriteStateRef.current[k];\n          const elapsed = nowI - st.started;\n          const total = st.frameCount * st.frameDuration;\n          if (elapsed > total) {\n            delete instantSpriteStateRef.current[k];\n            return;\n          }\n          const frame = Math.floor(elapsed / st.frameDuration);\n          const parts = k.split('.');\n          const player = Number(parts[0]) || 1;\n          const index = Number(parts[2] || 0);\n          const rects = getSofortRect(player ? 'player' : 'opponent');\n          // getSofortRect returns one rect; map by player/context — fallback to zone\n          const instantRect = getZone('slot.instant.player').rectPx;\n          const [ix, iy, iw, ih] = instantRect;\n          if (spritesI && spritesI.complete) {\n            const sx = frame * 256;\n            const sy = 0;\n            const sw = 256;\n            const sh = 256;\n            ctx.drawImage(spritesI, sx, sy, sw, sh, ix, iy, iw, ih);\n          }\n        });\n      } catch (e) {}\n      // --- HIT / TARGET SPRITESHEET (draw as overlay on targeted slot) ---\n      try {\n        const spritesH = hitSpritesRef.current;\n        const nowH = performance.now();\n        Object.keys(hitSpriteStateRef.current).forEach(k => {\n          const st = hitSpriteStateRef.current[k];\n          const elapsed = nowH - st.started;\n          const total = st.frameCount * st.frameDuration;\n          if (elapsed > total) {\n            delete hitSpriteStateRef.current[k];\n            return;\n          }\n          const frame = Math.floor(elapsed / st.frameDuration);\n\n          // parse key -> player.lane.index\n          const parts = k.split('.');\n          const player = Number(parts[0]) || 1;\n          const lane = parts[1] || 'aussen';\n          const index = Number(parts[2] || 0);\n\n          // compute slot rect for this gov slot (attempt gov then public)\n          const rect = (player === 1 ? playerGovRects : opponentGovRects)[index] || (player === 1 ? playerPublicRects : opponentPublicRects)[index];\n          if (!rect) return;\n          if (spritesH && spritesH.complete) {\n            const sx = frame * 256;\n            const sy = 0;\n            const sw = 256;\n            const sh = 256;\n            const dx = rect.x;\n            const dy = rect.y;\n            ctx.drawImage(spritesH, sx, sy, sw, sh, dx, dy, rect.w, rect.h);\n          }\n        });\n      } catch (e) {}\n    } catch (e) {}\n\n    // Draw player permanent slots (draw symbols if empty)\n    // permanent government\n    const permGovZone = getZone('slot.permanent.government.player');\n    if (permGovZone) {\n      const card = gameState.permanentSlots[1].government;\n      const [x, y, w, h] = permGovZone.rectPx;\n      if (card) {\n        drawSingleSlot(ctx, 'slot.permanent.government.player', card, 'permanent_government', 1);\n      } else {\n        // Draw all slot icons using unified helper (so 'dauerhaft' used visually for empty permanent gov slot)\n        const img = slotSymbolImgsRef.current.get('dauerhaft');\n        drawSlotIconWithPulse(ctx, img, x, y, w, h, 0.2);\n      }\n    }\n    // permanent public\n    const permPubZone = getZone('slot.permanent.public.player');\n    if (permPubZone) {\n      const card = gameState.permanentSlots[1].public;\n      const [x2, y2, w2, h2] = permPubZone.rectPx;\n      if (card) {\n        drawSingleSlot(ctx, 'slot.permanent.public.player', card, 'permanent_public', 1);\n      } else {\n        // Draw all slot icons using unified helper (so 'dauerhaft' used visually for empty permanent public slot)\n        const img = slotSymbolImgsRef.current.get('dauerhaft');\n        drawSlotIconWithPulse(ctx, img, x2, y2, w2, h2, 0.9);\n      }\n    }\n\n    // Draw instant slots (both players) and placeholder if empty\n    const instantPlayerZone = getZone('slot.instant.player');\n    if (instantPlayerZone) {\n      const card = gameState.board[1].sofort[0];\n      const [x, y, w, h] = instantPlayerZone.rectPx;\n      if (card) drawSingleSlot(ctx, 'slot.instant.player', card, 'instant', 1);else {\n        // Use unified icon draw helper for instant slot\n        const img = slotSymbolImgsRef.current.get('sofort');\n        drawSlotIconWithPulse(ctx, img, x, y, w, h, 0.0);\n      }\n    }\n\n    // Draw interventions strip (player)\n    // We draw symbol if empty\n    const interventionsZone = getZone('interventions.player');\n    if (interventionsZone) {\n      const [zx, zy, zw, zh] = interventionsZone.rectPx;\n      const card = gameState.traps[1] && gameState.traps[1][0];\n      if (card) drawInterventionsP1(ctx);else {\n        const img = slotSymbolImgsRef.current.get('intervention');\n        drawSlotIconWithPulse(ctx, img, zx, zy, zw, zh, 0.6);\n      }\n    }\n\n    // Draw interventions strip (opponent) - nur im Dev Mode\n    if (devMode) {\n      drawInterventionsP2(ctx);\n    }\n\n    // Draw hand (P1)\n    drawHandP1(ctx);\n\n    // 🔧 DEV MODE: Draw hand (P2) - nur im Dev Mode\n    if (devMode) {\n      drawHandP2(ctx);\n    }\n\n    // Draw info panels\n    drawInfoPanels(ctx);\n\n    // Draw corruption mode indicator\n    const corrActive = !!(gameState.pendingAbilitySelect && gameState.pendingAbilitySelect.type === 'corruption_steal');\n    if (corrActive) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';\n      ctx.font = 'bold 32px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('🔥 CORRUPTION TARGET SELECTION ACTIVE 🔥', 960, 100);\n      ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';\n      ctx.font = 'bold 24px sans-serif';\n      ctx.fillText('Click on opponent government card to target', 960, 140);\n      ctx.restore();\n    }\n\n    // Draw maulwurf corruption mode indicator\n    const maulwurfActive = !!(gameState.pendingAbilitySelect && gameState.pendingAbilitySelect.type === 'maulwurf_steal');\n    if (maulwurfActive) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(139, 69, 19, 0.8)'; // Brown color for mole\n      ctx.font = 'bold 32px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('🕳️ MAULWURF CORRUPTION ACTIVE 🕳️', 960, 100);\n      ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';\n      ctx.font = 'bold 24px sans-serif';\n      ctx.fillText('Ziel automatisch gewählt - würfeln zum Stehlen', 960, 140);\n      ctx.restore();\n    }\n\n    // Draw tunnelvision probe mode indicator\n    const tunnelvisionActive = !!(gameState.pendingAbilitySelect && gameState.pendingAbilitySelect.type === 'tunnelvision_probe');\n    if (tunnelvisionActive) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(75, 0, 130, 0.8)'; // Purple color for tunnelvision\n      ctx.font = 'bold 32px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('🔮 TUNNELVISION PROBE ACTIVE 🔮', 960, 100);\n      ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';\n      ctx.font = 'bold 24px sans-serif';\n      ctx.fillText('Regierungskarte Probe - würfeln zum Fortfahren', 960, 140);\n      ctx.restore();\n    }\n\n    // --- VISUAL EFFECTS: Particle bursts, card pop scale, initiative ripple & AP pop ---\n    try {\n      const now = performance.now();\n      const {\n        particlesRef,\n        popsRef,\n        ripplesRef,\n        apLabelsRef,\n        reducedMotion\n      } = visualEffects || {};\n      const parts = particlesRef.current || [];\n      if (!reducedMotion) {\n        for (let i = parts.length - 1; i >= 0; i--) {\n          const p = parts[i];\n          const age = now - p.start;\n          if (age > p.life) {\n            parts.splice(i, 1);\n            continue;\n          }\n          p.vy += p.gravity || 0.09;\n          p.x += p.vx;\n          p.y += p.vy;\n          const t = 1 - age / p.life;\n          ctx.save();\n          ctx.globalAlpha = Math.max(0, Math.min(1, t));\n          ctx.fillStyle = p.color || '#ffd166';\n          ctx.beginPath();\n          ctx.arc(p.x, p.y, (p.size || 4) * t, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.restore();\n        }\n        particlesRef.current = parts;\n        const pops = popsRef.current || [];\n        pops.forEach(pop => {\n          const p = Math.min(1, Math.max(0, (now - pop.started) / pop.duration));\n          const eased = 1 + 0.12 * (1 - Math.pow(1 - p, 3));\n          const zone = clickZonesRef.current.find(z => {\n            var _z$data$card$uid3;\n            return z.data && z.data.card && ((_z$data$card$uid3 = z.data.card.uid) !== null && _z$data$card$uid3 !== void 0 ? _z$data$card$uid3 : String(z.data.card.id)) === pop.uid;\n          });\n          if (!zone) return;\n          ctx.save();\n          ctx.translate(zone.x + zone.w / 2, zone.y + zone.h / 2);\n          ctx.scale(eased, eased);\n          ctx.globalAlpha = 0.12 * (1 - p);\n          ctx.fillStyle = '#ffffff';\n          ctx.fillRect(-zone.w / 2, -zone.h / 2, zone.w, zone.h);\n          ctx.restore();\n        });\n        const ripples = ripplesRef.current || [];\n        for (let i = ripples.length - 1; i >= 0; i--) {\n          const r = ripples[i];\n          const p = Math.min(1, Math.max(0, (now - r.started) / r.duration));\n          if (p >= 1) {\n            ripples.splice(i, 1);\n            continue;\n          }\n          const radius = r.radius * (0.8 + 1.8 * p);\n          ctx.save();\n          const g = ctx.createRadialGradient(r.cx, r.cy, radius * 0.1, r.cx, r.cy, radius);\n          g.addColorStop(0, `rgba(255,255,255,${0.12 * (1 - p)})`);\n          g.addColorStop(1, `rgba(255,255,255,0)`);\n          ctx.fillStyle = g;\n          ctx.beginPath();\n          ctx.arc(r.cx, r.cy, radius, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.restore();\n          if (r.showAp && !r._apSpawned) {\n            apLabelsRef.current = apLabelsRef.current || [];\n            apLabelsRef.current.push({\n              x: r.apX,\n              y: r.apY,\n              started: now,\n              duration: 800,\n              text: '+1'\n            });\n            r._apSpawned = true;\n          }\n        }\n        ripplesRef.current = ripples;\n        const apl = apLabelsRef.current || [];\n        for (let i = apl.length - 1; i >= 0; i--) {\n          const l = apl[i];\n          const p = Math.min(1, Math.max(0, (now - l.started) / l.duration));\n          if (p >= 1) {\n            apl.splice(i, 1);\n            continue;\n          }\n          ctx.save();\n          ctx.globalAlpha = 1 - p;\n          ctx.fillStyle = '#ffdd57';\n          ctx.font = 'bold 22px sans-serif';\n          ctx.textAlign = 'center';\n          ctx.fillText(l.text, l.x, l.y - 20 * p);\n          ctx.restore();\n        }\n        apLabelsRef.current = apl;\n      } else {\n        const apl = apLabelsRef.current || [];\n        for (let i = apl.length - 1; i >= 0; i--) {\n          const l = apl[i];\n          const p = Math.min(1, Math.max(0, (now - l.started) / l.duration));\n          if (p >= 1) {\n            apl.splice(i, 1);\n            continue;\n          }\n          ctx.save();\n          ctx.globalAlpha = 1 - p;\n          ctx.fillStyle = '#ffdd57';\n          ctx.font = 'bold 18px sans-serif';\n          ctx.textAlign = 'center';\n          ctx.fillText(l.text, l.x, l.y - 10 * p);\n          ctx.restore();\n        }\n        apLabelsRef.current = apl;\n      }\n    } catch (e) {}\n\n    // --- Overlay pass: draw influence pulse ring and +N labels on top of all cards ---\n    try {\n      const now = performance.now();\n      // iterate over stored anims\n      influenceAnimRef.current.forEach((anims, uid) => {\n        // find card position by scanning clickZones\n        const zone = clickZonesRef.current.find(z => {\n          var _z$data$card$uid4;\n          return z.data && (z.data.card && ((_z$data$card$uid4 = z.data.card.uid) !== null && _z$data$card$uid4 !== void 0 ? _z$data$card$uid4 : String(z.data.card.id)) === uid || z.data.card && z.data.card.uid === uid);\n        });\n        if (!zone) return;\n        const cx = zone.x + zone.w / 2;\n        const cy = zone.y + zone.h / 2;\n        // calculate aggregate pulse for this uid\n        let maxPulse = 0;\n        let totalAmount = 0;\n        const remaining = [];\n        anims.forEach(a => {\n          const p = Math.min(1, Math.max(0, (now - a.start) / a.duration));\n          const pulse = Math.pow(Math.max(0, 1 - p), 2);\n          if (pulse > maxPulse) maxPulse = pulse;\n          if (p < 1) {\n            remaining.push(a);\n            totalAmount += a.amount;\n          }\n        });\n\n        // update list\n        if (remaining.length > 0) influenceAnimRef.current.set(uid, remaining);else influenceAnimRef.current.delete(uid);\n        if (maxPulse > 0.001) {\n          // draw a soft ring to the right-bottom of influence number\n          const ringRadius = Math.max(8, zone.w * 0.08) * (1 + maxPulse * 0.6);\n          const ringX = zone.x + zone.w - 28; // near bottom-right where influence text lives\n          const ringY = zone.y + zone.h - 20;\n          ctx.save();\n          ctx.beginPath();\n          ctx.strokeStyle = `rgba(46, 204, 113, ${0.9 * maxPulse})`;\n          ctx.lineWidth = Math.max(2, Math.ceil(6 * maxPulse));\n          ctx.arc(ringX, ringY, ringRadius, 0, Math.PI * 2);\n          ctx.stroke();\n          ctx.restore();\n        }\n        if (totalAmount > 0) {\n          // floating +N to the right of influence number\n          const labelX = zone.x + zone.w - 12;\n          const labelY = zone.y + zone.h - 32 - Math.random() * 6; // slight jitter\n          ctx.save();\n          ctx.fillStyle = '#2ecc71';\n          ctx.font = 'bold 16px sans-serif';\n          ctx.textAlign = 'left';\n          ctx.textBaseline = 'middle';\n          ctx.fillText(`+${totalAmount}`, labelX, labelY);\n          ctx.restore();\n        }\n      });\n    } catch (e) {\n      // ignore overlay errors\n    }\n\n    // --- Outline pass: draw a subtle, slightly pulsing 257x257 square around 256x256 slots ---\n    try {\n      const now2 = performance.now();\n      clickZonesRef.current.forEach((z, i) => {\n        if (!z) return;\n        const w = z.w || 0;\n        const h = z.h || 0;\n        // only target 256x256 slot-sized zones (covers the icons)\n        if (Math.abs(w - 256) > 0.1 || Math.abs(h - 256) > 0.1) return;\n        const x = z.x;\n        const y = z.y;\n\n        // Color palette (rgb)\n        const rgbTeal = '20,184,166';\n        const rgbBurg = '127,29,29';\n        const rgbPurple = '139,92,246';\n        const rgbYellow = '250,204,21';\n        const rgbOrange = '251,146,60';\n\n        // Determine slot semantic\n        let slotType = 'default';\n        try {\n          const dt = z.data || {};\n          if (dt.slot && typeof dt.slot === 'string') {\n            if (dt.slot.includes('government')) slotType = 'government';else if (dt.slot.includes('public')) slotType = 'public';else if (dt.slot.includes('permanent')) slotType = 'permanent';else if (dt.slot.includes('instant')) slotType = 'instant';\n          }\n          if (dt.type === 'row_slot' && dt.lane === 'aussen') slotType = 'government';\n          if (dt.type === 'row_slot' && dt.lane === 'innen') slotType = 'public';\n          if (dt.type === 'trap_p1' || dt.type === 'trap_p2' || dt.card && dt.card.kind === 'trap') slotType = 'intervention';\n          if (dt.type === 'activate_instant' || dt.slot === 'instant') slotType = 'instant';\n          if (dt.slot === 'permanent_government' || dt.slot === 'permanent_public' || dt.slot === 'permanent') slotType = 'permanent';\n        } catch (e) {}\n        const pulse = 0.5 + 0.5 * Math.sin(now2 / 350 + i);\n        const alpha = 0.06 + 0.12 * pulse; // subtle alpha\n        const lw = 1 + 2 * pulse; // line width between 1 and 3\n\n        // Create gradient based on slot type\n        let grad = null;\n        try {\n          grad = ctx.createLinearGradient(x, y, x + w, y + h);\n          if (slotType === 'government') {\n            grad.addColorStop(0, `rgba(${rgbTeal},1)`);\n            grad.addColorStop(1, `rgba(${rgbBurg},1)`);\n          } else if (slotType === 'public') {\n            grad.addColorStop(0, `rgba(${rgbBurg},1)`);\n            grad.addColorStop(1, `rgba(${rgbTeal},1)`);\n          } else if (slotType === 'permanent') {\n            grad.addColorStop(0, `rgba(${rgbPurple},1)`);\n            grad.addColorStop(1, `rgba(${rgbPurple},1)`);\n          } else if (slotType === 'instant') {\n            grad.addColorStop(0, `rgba(${rgbYellow},1)`);\n            grad.addColorStop(1, `rgba(${rgbYellow},1)`);\n          } else if (slotType === 'intervention') {\n            grad.addColorStop(0, `rgba(${rgbOrange},1)`);\n            grad.addColorStop(1, `rgba(${rgbOrange},1)`);\n          } else {\n            grad.addColorStop(0, `rgba(255,255,255,1)`);\n            grad.addColorStop(1, `rgba(255,255,255,1)`);\n          }\n        } catch (e) {\n          grad = null;\n        }\n        ctx.save();\n        if (grad) ctx.strokeStyle = grad;else ctx.strokeStyle = `rgba(255,255,255,${alpha.toFixed(3)})`;\n        ctx.globalAlpha = alpha;\n        ctx.lineWidth = lw;\n        // draw 257x257 centered so that it encloses the 256 slot\n        ctx.strokeRect(x - 0.5, y - 0.5, w + 1, h + 1);\n        ctx.restore();\n      });\n    } catch (e) {\n      // ignore outline errors\n    }\n    ctx.restore();\n\n    // expose zones for debug snapshot\n    window.__politicardDebug = {\n      uiTransform: getUiTransform(canvas.width, canvas.height),\n      canvasSize: {\n        width: canvas.width,\n        height: canvas.height\n      },\n      zones: LAYOUT.zones,\n      clickZones: clickZonesRef.current.slice(0, 1000)\n    };\n\n    // Build canonical slotPositions map for animations/debugging\n    try {\n      const map = {};\n      clickZonesRef.current.forEach(z => {\n        const d = z.data || {};\n        // support row_slot, board_card, slot_card shapes\n        if (d.type === 'row_slot' || d.type === 'board_card' || d.type === 'slot_card' || d.type === 'hand_p1' || d.type === 'hand_p2') {\n          var _d$player, _d$lane;\n          const player = (_d$player = d.player) !== null && _d$player !== void 0 ? _d$player : d.type === 'hand_p2' ? 2 : 1;\n          const lane = (_d$lane = d.lane) !== null && _d$lane !== void 0 ? _d$lane : typeof d.slot === 'string' ? d.slot : d.type === 'hand_p2' ? 'hand' : 'unknown';\n          let index;\n          if (d.index != null) {\n            index = d.index;\n          } else if (d.card) {\n            // prefer explicit slotIndex, fallback to card.index, otherwise 0\n            index = d.card.slotIndex != null ? d.card.slotIndex : d.card.index != null ? d.card.index : 0;\n          } else {\n            index = 0;\n          }\n          const key = `${player}.${lane}.${index}`;\n          map[key] = {\n            x: z.x,\n            y: z.y,\n            w: z.w,\n            h: z.h,\n            cx: z.x + z.w / 2,\n            cy: z.y + z.h / 2\n          };\n        }\n      });\n      slotPositionsRef.current = map;\n      window.__politicardDebug = {\n        ...window.__politicardDebug,\n        slotPositions: slotPositionsRef.current\n      };\n    } catch (e) {\n      // don't let debug mapping break rendering\n    }\n\n    // Run diagnostics after canvas is fully rendered\n    runDiagnostics();\n  }, [drawLane, drawHandP1, drawHandP2, drawInterventionsP1, drawInterventionsP2, drawPermanentSlotsP1, drawPermanentSlotsP2, drawInstantSlots, drawInfoPanels, devMode, runDiagnostics]);\n  const DRAW_LAYOUT_OVERLAY = false; // force off per new layout system\n\n  // Load slot symbol images once\n  useEffect(() => {\n    const load = (key, src) => {\n      const img = new Image();\n      img.onload = () => {\n        slotSymbolImgsRef.current.set(key, img);\n      };\n      img.onerror = () => {\n        console.warn('Failed to load slot icon', src);\n      };\n      img.src = src;\n    };\n    // load all slot icons\n    load('public', publicSymbolUrl);\n    load('sofort', sofortSymbolUrl);\n    load('dauerhaft', dauerhaftSymbolUrl);\n    load('government', governmentSymbolUrl);\n    load('intervention', interventionSymbolUrl);\n\n    // load test GIF for gov overlay\n    try {\n      const img = new Image();\n      img.onload = () => {\n        govGifRef.current = img;\n      };\n      img.onerror = () => {\n        console.warn('Failed to load gov overlay gif', govPlaceGifUrl);\n      };\n      img.src = govPlaceGifUrl;\n    } catch (e) {}\n    // load spritesheet for placement animation\n    try {\n      const s = new Image();\n      s.onload = () => {\n        govSpritesRef.current = s;\n      };\n      s.onerror = () => {\n        console.warn('Failed to load gov spritesheet', govPlaceSpritesheetUrl);\n      };\n      s.src = govPlaceSpritesheetUrl;\n    } catch (e) {}\n    // load spritesheet for instant initiative activation\n    try {\n      const si = new Image();\n      si.onload = () => {\n        instantSpritesRef.current = si;\n      };\n      si.onerror = () => {\n        console.warn('Failed to load instant spritesheet', instantSpritesheetUrl);\n      };\n      si.src = instantSpritesheetUrl;\n    } catch (e) {}\n\n    // load spritesheet for hit/target animation (25 frames)\n    try {\n      const h = new Image();\n      h.onload = () => {\n        hitSpritesRef.current = h;\n      };\n      h.onerror = () => {\n        console.warn('Failed to load hit spritesheet', hitSpritesheetUrl);\n      };\n      h.src = hitSpritesheetUrl;\n    } catch (e) {}\n\n    // ensure first draw\n    requestAnimationFrame(draw);\n  }, [draw]);\n\n  // Expose debug trigger to manually start gov sprite animation by slot-key or uid\n  useEffect(() => {\n    window.__pc_triggerGovAnim = id => {\n      try {\n        var _zone$data$player2, _zone$data$lane2, _zone$data$index2;\n        const now = performance.now();\n        // if id is slot key like '1.aussen.2'\n        if (typeof id === 'string' && id.indexOf('.') >= 0) {\n          govSpriteStateRef.current[id] = {\n            started: now,\n            frameCount: 14,\n            frameDuration: 40\n          };\n          return;\n        }\n\n        // otherwise try to resolve as uid/id to a clickZone\n        const uid = id;\n        const zone = clickZonesRef.current.find(z => {\n          var _z$data$card$uid5;\n          return z.data && z.data.card && (((_z$data$card$uid5 = z.data.card.uid) !== null && _z$data$card$uid5 !== void 0 ? _z$data$card$uid5 : String(z.data.card.id)) === uid || z.data.card.id === uid);\n        });\n        if (!zone) {\n          console.warn('pc_triggerGovAnim: no slot found for uid', uid);\n          return;\n        }\n        const player = (_zone$data$player2 = zone.data.player) !== null && _zone$data$player2 !== void 0 ? _zone$data$player2 : 1;\n        const lane = (_zone$data$lane2 = zone.data.lane) !== null && _zone$data$lane2 !== void 0 ? _zone$data$lane2 : zone.data.slot && typeof zone.data.slot === 'string' ? zone.data.slot : 'aussen';\n        const index = (_zone$data$index2 = zone.data.index) !== null && _zone$data$index2 !== void 0 ? _zone$data$index2 : 0;\n        const key = `${player}.${lane}.${index}`;\n        govSpriteStateRef.current[key] = {\n          started: now,\n          frameCount: 14,\n          frameDuration: 40\n        };\n      } catch (e) {\n        console.warn('pc_triggerGovAnim error', e);\n      }\n    };\n    // expose easy alias\n    try {\n      window.pc_triggerGovAnim = window.__pc_triggerGovAnim;\n    } catch (e) {}\n    return () => {\n      delete window.__pc_triggerGovAnim;\n    };\n  }, []);\n\n  // Expose debug trigger for hit animation (key: '1.aussen.0' or uid)\n  useEffect(() => {\n    window.__pc_triggerHitAnim = id => {\n      try {\n        var _zone$data$player3, _zone$data$lane3, _zone$data$index3;\n        const now = performance.now();\n        // if id is slot key like '1.aussen.2'\n        if (typeof id === 'string' && id.indexOf('.') >= 0) {\n          hitSpriteStateRef.current[id] = {\n            started: now,\n            frameCount: 25,\n            frameDuration: 30\n          };\n          return;\n        }\n\n        // otherwise try to resolve as uid/id to a clickZone\n        const uid = id;\n        const zone = clickZonesRef.current.find(z => {\n          var _z$data$card$uid6;\n          return z.data && z.data.card && (((_z$data$card$uid6 = z.data.card.uid) !== null && _z$data$card$uid6 !== void 0 ? _z$data$card$uid6 : String(z.data.card.id)) === uid || z.data.card.id === uid);\n        });\n        if (!zone) {\n          console.warn('pc_triggerHitAnim: no slot found for uid', uid);\n          return;\n        }\n        const player = (_zone$data$player3 = zone.data.player) !== null && _zone$data$player3 !== void 0 ? _zone$data$player3 : 1;\n        const lane = (_zone$data$lane3 = zone.data.lane) !== null && _zone$data$lane3 !== void 0 ? _zone$data$lane3 : zone.data.slot && typeof zone.data.slot === 'string' ? zone.data.slot : 'aussen';\n        const index = (_zone$data$index3 = zone.data.index) !== null && _zone$data$index3 !== void 0 ? _zone$data$index3 : 0;\n        const key = `${player}.${lane}.${index}`;\n        hitSpriteStateRef.current[key] = {\n          started: now,\n          frameCount: 25,\n          frameDuration: 30\n        };\n      } catch (e) {\n        console.warn('pc_triggerHitAnim error', e);\n      }\n    };\n    try {\n      window.pc_triggerHitAnim = window.__pc_triggerHitAnim;\n    } catch (e) {}\n    return () => {\n      delete window.__pc_triggerHitAnim;\n    };\n  }, []);\n\n  // Redraw when game state or selection changes\n  useEffect(() => {\n    requestAnimationFrame(draw);\n  }, [gameState, selectedHandIndex, draw]);\n\n  // Continuous render loop to keep canvas updated without relying on external state refs\n  useEffect(() => {\n    let frame;\n    const loop = () => {\n      draw();\n      frame = requestAnimationFrame(loop);\n    };\n    frame = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(frame);\n  }, [draw]);\n  const handleCardClick = useCallback(data => {\n    // Corruption target selection: intercept board card clicks for opponent government\n    if (corruptionSelectActorRef.current && data && data.type === 'board_card') {\n      try {\n        const actor = corruptionSelectActorRef.current;\n        const victim = actor === 1 ? 2 : 1;\n        if (data.player === victim && (data.lane === 'aussen' || data.lane === 'government')) {\n          var _data$card$uid, _data$card, _data$card2;\n          const uid = (_data$card$uid = (_data$card = data.card) === null || _data$card === void 0 ? void 0 : _data$card.uid) !== null && _data$card$uid !== void 0 ? _data$card$uid : (_data$card2 = data.card) === null || _data$card2 === void 0 ? void 0 : _data$card2.id;\n          if (uid != null) {\n            corruptionSelectActorRef.current = null;\n            try {\n              window.dispatchEvent(new CustomEvent('pc:corruption_target_selected', {\n                detail: {\n                  player: actor,\n                  targetUid: uid\n                }\n              }));\n            } catch (e) {}\n            return; // do not propagate\n          }\n        }\n      } catch (e) {}\n    }\n    // Hand-Klick\n    if (data.type === 'hand_p1') {\n      var _data$card$uid2, _data$card3, _data$card4, _gameState$hands;\n      const uid = (_data$card$uid2 = (_data$card3 = data.card) === null || _data$card3 === void 0 ? void 0 : _data$card3.uid) !== null && _data$card$uid2 !== void 0 ? _data$card$uid2 : (_data$card4 = data.card) === null || _data$card4 === void 0 ? void 0 : _data$card4.id;\n      const stateHand = ((_gameState$hands = gameState.hands) === null || _gameState$hands === void 0 ? void 0 : _gameState$hands[1]) || [];\n      const idxInState = stateHand.findIndex(c => {\n        var _c$uid3;\n        return ((_c$uid3 = c.uid) !== null && _c$uid3 !== void 0 ? _c$uid3 : c.id) === uid;\n      });\n      onCardClick(data);\n      return;\n    }\n\n    // Slot-Klick\n    if (data.type === 'row_slot') {\n      var _gameState$board$1$in, _gameState$board, _gameState$board$, _gameState$board$1$au, _gameState$board2, _gameState$board2$;\n      const lane = data.lane;\n      const cap = getLaneCapacity(lane);\n\n      // Hole aktuelle Row-Länge aus gameState\n      const rowCards = lane === 'public' ? (_gameState$board$1$in = (_gameState$board = gameState.board) === null || _gameState$board === void 0 ? void 0 : (_gameState$board$ = _gameState$board[1]) === null || _gameState$board$ === void 0 ? void 0 : _gameState$board$.innen) !== null && _gameState$board$1$in !== void 0 ? _gameState$board$1$in : [] : (_gameState$board$1$au = (_gameState$board2 = gameState.board) === null || _gameState$board2 === void 0 ? void 0 : (_gameState$board2$ = _gameState$board2[1]) === null || _gameState$board2$ === void 0 ? void 0 : _gameState$board2$.aussen) !== null && _gameState$board$1$au !== void 0 ? _gameState$board$1$au : [];\n      if (rowCards.length >= cap) {\n        // Optional: UI Feedback\n        console.warn(`Row ${lane} is full (${rowCards.length}/${cap})`);\n        return;\n      }\n      onCardClick(data);\n      return;\n    }\n\n    // Andere Klicks (empty_slot, board_card, etc.)\n    onCardClick(data);\n  }, [gameState, onCardClick]);\n  const handleClick = useCallback(e => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    const {\n      scale,\n      offsetX,\n      offsetY\n    } = getUiTransform(canvas.width, canvas.height);\n    const mx = (e.clientX - rect.left - offsetX) / scale;\n    const my = (e.clientY - rect.top - offsetY) / scale;\n    const hit = clickZonesRef.current.find(z => mx >= z.x && mx <= z.x + z.w && my >= z.y && my <= z.y + z.h);\n    if (hit) {\n      console.debug('[CanvasClick] mx,my,hit:', mx, my, hit.data);\n      try {\n        // If user clicked a drawn card in an instant slot, normalize to activate_instant\n        const d = hit.data || {};\n        if (d.type === 'slot_card' && d.slot === 'instant') {\n          handleCardClick({\n            type: 'activate_instant',\n            player: d.player || 1,\n            card: d.card\n          });\n          return;\n        }\n        // Fallback: if there's an explicit activate_instant zone, pass through\n        if (d.type === 'activate_instant') {\n          handleCardClick(d);\n          return;\n        }\n      } catch (err) {}\n      handleCardClickInternal(hit.data);\n    }\n  }, [handleCardClick]);\n  const handleMouseMove = useCallback(e => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    const {\n      scale,\n      offsetX,\n      offsetY\n    } = getUiTransform(canvas.width, canvas.height);\n    const mx = (e.clientX - rect.left - offsetX) / scale;\n    const my = (e.clientY - rect.top - offsetY) / scale;\n    const hit = clickZonesRef.current.find(z => mx >= z.x && mx <= z.x + z.w && my >= z.y && my <= z.y + z.h);\n    if (hit) {\n      var _hit$data$card;\n      console.log('[hover]', hit.data.type, (_hit$data$card = hit.data.card) === null || _hit$data$card === void 0 ? void 0 : _hit$data$card.name);\n      onCardHover({\n        ...hit.data,\n        x: e.clientX,\n        y: e.clientY\n      });\n    } else {\n      onCardHover(null);\n    }\n  }, [onCardHover]);\n  const handleWheel = useCallback(e => {\n    // only enable when player1 has more slots than visible\n    const handLen = gameState.hands && gameState.hands[1] ? gameState.hands[1].length : 0;\n    const zone = getZone('hand.player');\n    if (!zone) return;\n    if (handLen <= 5) return; // nothing to scroll\n\n    // Prevent page scrolling when over canvas\n    e.preventDefault();\n\n    // accumulate target offset (invert so wheel down moves cards up)\n    // Each wheel step moves by 48px per delta unit\n    const delta = Math.sign(e.deltaY) * 48;\n    // compute slot height more robustly\n    const slots = computeSlotRects(zone);\n    const slotH = slots && slots.length > 0 ? slots[0].h : zone.rectPx[3] / 5;\n    const visible = 5;\n    const maxOffset = -(Math.max(0, handLen - visible) * slotH);\n    handScrollTargetRef.current = Math.max(Math.min(handScrollTargetRef.current - delta, 0), maxOffset);\n  }, [gameState.hands]);\n  const handleTouchStart = useCallback(e => {\n    if (!e.touches || e.touches.length === 0) return;\n    const handLen = gameState.hands && gameState.hands[1] ? gameState.hands[1].length : 0;\n    if (handLen <= 5) return;\n    isTouchingRef.current = true;\n    const y = e.touches[0].clientY;\n    touchStartYRef.current = y;\n    lastTouchYRef.current = y;\n    e.preventDefault();\n  }, [gameState.hands]);\n  const handleTouchMove = useCallback(e => {\n    var _lastTouchYRef$curren;\n    if (!isTouchingRef.current) return;\n    if (!e.touches || e.touches.length === 0) return;\n    const y = e.touches[0].clientY;\n    const last = (_lastTouchYRef$curren = lastTouchYRef.current) !== null && _lastTouchYRef$curren !== void 0 ? _lastTouchYRef$curren : y;\n    const dy = y - last; // positive when moving down\n    lastTouchYRef.current = y;\n\n    // invert so dragging up moves cards up\n    const delta = -dy;\n    const handLen = gameState.hands && gameState.hands[1] ? gameState.hands[1].length : 0;\n    const zone = getZone('hand.player');\n    if (!zone) return;\n    const slots = computeSlotRects(zone);\n    const slotH = slots && slots.length > 0 ? slots[0].h : zone.rectPx[3] / 5;\n    const visible = 5;\n    const maxOffset = -(Math.max(0, handLen - visible) * slotH);\n    handScrollTargetRef.current = Math.max(Math.min(handScrollTargetRef.current + delta, 0), maxOffset);\n    e.preventDefault();\n  }, [gameState.hands]);\n  const handleTouchEnd = useCallback(e => {\n    isTouchingRef.current = false;\n    touchStartYRef.current = null;\n    lastTouchYRef.current = null;\n  }, []);\n\n  // Expose debug trigger to manually start instant sprite animation by slot-key or uid\n  useEffect(() => {\n    window.__pc_triggerInstantAnim = key => {\n      const now = performance.now();\n      instantSpriteStateRef.current[key || '1.instant.0'] = {\n        started: now,\n        frameCount: 14,\n        frameDuration: 40\n      };\n    };\n    // alias\n    try {\n      window.pc_triggerInstantAnim = window.__pc_triggerInstantAnim;\n    } catch (e) {}\n    return () => {\n      delete window.__pc_triggerGovAnim;\n      delete window.__pc_triggerInstantAnim;\n    };\n  }, []);\n\n  // Click handler wrapper for corruption selection\n  const handleCardClickInternal = useCallback(data => {\n    const sel = gameState.pendingAbilitySelect;\n    if (sel && sel.type === 'corruption_steal') {\n      // Accept clicks on either actual card sprites (with uid) or on empty row_slot hitboxes.\n      if (data.player !== sel.actorPlayer && data.lane === 'aussen') {\n        let targetUid = data.uid;\n\n        // If we got a row_slot hit (no uid), map index→uid from board state\n        if (!targetUid && data.type === 'row_slot') {\n          try {\n            var _board5, _board5$p, _board5$p$aussen;\n            const p = data.player;\n            const idx = data.index;\n            const card = (_board5 = gameState.board) === null || _board5 === void 0 ? void 0 : (_board5$p = _board5[p]) === null || _board5$p === void 0 ? void 0 : (_board5$p$aussen = _board5$p.aussen) === null || _board5$p$aussen === void 0 ? void 0 : _board5$p$aussen[idx];\n            targetUid = card === null || card === void 0 ? void 0 : card.uid;\n          } catch (e) {}\n        }\n        if (targetUid) {\n          try {\n            console.debug('[CORR] forwarding uid', targetUid, 'actorPlayer=', sel.actorPlayer);\n            window.dispatchEvent(new CustomEvent('pc:corruption_pick_target', {\n              detail: {\n                player: sel.actorPlayer,\n                targetUid\n              }\n            }));\n            // Also open small confirmation overlay via DOM event for modal convenience\n            try {\n              window.dispatchEvent(new CustomEvent('pc:corruption_target_selected', {\n                detail: {\n                  player: sel.actorPlayer,\n                  targetUid\n                }\n              }));\n            } catch (e) {}\n          } catch (e) {}\n          return; // consume click\n        }\n      }\n    }\n    onCardClick(data);\n  }, [gameState, onCardClick]);\n  useEffect(() => {\n    const onDiceResult = () => {\n      // remove corruption modal if exists\n      const el = document.getElementById('pc-corruption-modal');\n      if (el) el.remove();\n      corruptionSelectActorRef.current = null;\n    };\n    window.addEventListener('pc:dice_result', onDiceResult);\n    return () => window.removeEventListener('pc:dice_result', onDiceResult);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    width: 1920,\n    height: 1080,\n    style: {\n      display: 'block',\n      width: '100%',\n      height: '100%',\n      imageRendering: 'auto'\n    },\n    onClick: handleClick,\n    onMouseMove: handleMouseMove,\n    onWheel: handleWheel,\n    onTouchStart: handleTouchStart,\n    onTouchMove: handleTouchMove,\n    onTouchEnd: handleTouchEnd\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 2137,\n    columnNumber: 5\n  }, this);\n};\n_s(GameCanvas, \"qWYSKOHaI/WRP19ex8Vr7nxXgn4=\", false, function () {\n  return [useVisualEffectsSafe];\n});\n_c = GameCanvas;\nvar _c;\n$RefreshReg$(_c, \"GameCanvas\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","useVisualEffectsSafe","LAYOUT","getZone","computeSlotRects","getUiTransform","getLaneCapacity","getPublicRects","getGovernmentRects","getSofortRect","sortHandCards","getCardImagePath","influenceIconUrl","publicSymbolUrl","sofortSymbolUrl","dauerhaftSymbolUrl","governmentSymbolUrl","interventionSymbolUrl","govPlaceGifUrl","govPlaceSpritesheetUrl","instantSpritesheetUrl","hitSpritesheetUrl","jsxDEV","_jsxDEV","isCorruptionSelection","state","player","sel","pendingAbilitySelect","type","actorPlayer","isMaulwurfCorruption","isTunnelvisionProbe","GameCanvas","gameState","selectedHandIndex","onCardClick","onCardHover","devMode","_s","handler","ev","_ev$detail","detail","dice","document","querySelector","window","dispatchEvent","CustomEvent","e","addEventListener","removeEventListener","canvasRef","visualEffects","clickZonesRef","handScrollTargetRef","handScrollCurrentRef","handScrollEnabledRef","touchStartYRef","lastTouchYRef","isTouchingRef","backgroundImageRef","imageCacheRef","Map","influenceImgRef","influenceAnimRef","prevInfluencesRef","slotSymbolImgsRef","slotPositionsRef","uidToKeyRef","keyToUidRef","govGifRef","govSpritesRef","hitSpritesRef","govSpriteStateRef","instantSpritesRef","instantSpriteStateRef","hitSpriteStateRef","corruptionSelectActorRef","gameStateRef","current","onEnterCorruptionSelect","_ev$detail2","actor","console","log","error","onKeyDown","_gs$board","_gs$board$victim","_gs$board$victim$auss","_card$uid","k","key","includes","victim","idx","Number","gs","card","board","aussen","debug","uid","id","targetUid","preventDefault","maulwurfSelectActorRef","onEnterMaulwurfSelect","_ev$detail3","_ev$detail4","_ev$detail5","_ev$detail6","requiredRoll","targetName","el","createElement","style","cssText","fontSize","body","appendChild","innerHTML","rollBtn","cancelBtn","removeChild","tunnelvisionProbeActorRef","onEnterTunnelvisionProbe","_ev$detail7","_ev$detail8","_ev$detail9","_ev$detail0","influence","getElementById","onclick","cancel","drawSlotIconWithPulse","ctx","img","x","y","w","h","phase","complete","now","performance","base","pulseRange","period","pulse","Math","sin","save","globalAlpha","drawImage","grad","createLinearGradient","addColorStop","globalCompositeOperation","fillStyle","fillRect","restore","Image","src","drawCardAt","size","selected","showAPCost","_shield","extraAlpha","_uid","list","playAnimsRef","__pc_play_anims","anim","find","a","p","min","max","started","duration","pow","dx","dy","s","floor","cached","get","naturalWidth","onload","set","kind","_influence","barH","font","textAlign","textBaseline","fillText","protected","shield","deactivated","_influence2","badgeHeight","badgeWidth","badgeX","badgeY","beginPath","roundRect","fill","strokeStyle","lineWidth","strokeRect","getSlotDisplayName","zoneId","index","slotNumber","drawLane","lane","clickable","zone","slots","arr","forEach","bgColor","isSelected","hands","clickZone","textY","name","push","data","slotName","drawHandP1","hand","target","offsetY","round","i","originalIndex","findIndex","c","isSel","sx","sy","drawHandP2","rectPx","drawInterventionsP1","traps","zx","zy","zw","zh","drawInterventionsP2","drawSingleSlot","clickType","slot","onTargetSelected","_board","_board2","_board2$aussen","_board3","_board4","_board4$aussen","position","left","top","transform","padding","background","border","borderRadius","zIndex","color","fontFamily","disabled","innerText","remove","drawPermanentSlotsP1","permanentSlots","government","public","drawPermanentSlotsP2","drawInstantSlots","sofortPlayerCard","sofort","sofortOppCard","getActiveKeywordsAndSubcategories","allCards","innen","filter","keywords","Set","subcategories","tag","add","publicCard","oligarchNames","platformNames","movementNames","ngoNames","intelligenceNames","mediaNames","Array","from","drawInfoPanels","govPanelX","govPanelY","govPanelW","govPanelH","length","keyword","pubPanelX","pubPanelY","pubPanelW","pubPanelH","subcategory","displayName","substring","runDiagnostics","handZones","z","uiUIDs","map","_z$data$card$uid","Boolean","stateHand","stateUIDs","_c$uid","missingInState","u","missingInUI","_politicardDebug","mismatch","ts","Date","uiCount","stateCount","stack","Error","__politicardDebug","slice","concat","warn","draw","_LAYOUT$background","_LAYOUT$background2","canvas","getContext","currSnapshot","collect","_c$uid2","_c$influence","String","Object","keys","_currSnapshot$uid","_prevInfluencesRef$cu","curr","prev","delta","start","amount","clearRect","width","height","enabled","scale","offsetX","translate","opponentPublicRects","opponentGovRects","corrActive","permGovZoneOpp","ox","oy","ow","oh","permPubZoneOpp","ox2","oy2","ow2","oh2","playerPublicRects","playerGovRects","sprites","gif","anims","animsArr","_zone$data$player","_zone$data$lane","_zone$data$index","indexOf","inner","frameCount","frameDuration","splice","_z$data$card$uid2","isGov","isInstant","dt","startedThis","instKey","st","elapsed","total","frame","parts","split","rect","sw","sh","spritesI","nowI","rects","instantRect","ix","iy","iw","ih","spritesH","nowH","permGovZone","permPubZone","x2","y2","w2","h2","instantPlayerZone","interventionsZone","maulwurfActive","tunnelvisionActive","particlesRef","popsRef","ripplesRef","apLabelsRef","reducedMotion","age","life","vy","gravity","vx","t","arc","PI","pops","pop","eased","_z$data$card$uid3","ripples","r","radius","g","createRadialGradient","cx","cy","showAp","_apSpawned","apX","apY","text","apl","l","_z$data$card$uid4","maxPulse","totalAmount","remaining","delete","ringRadius","ringX","ringY","ceil","stroke","labelX","labelY","random","now2","abs","rgbTeal","rgbBurg","rgbPurple","rgbYellow","rgbOrange","slotType","alpha","lw","toFixed","uiTransform","canvasSize","zones","clickZones","d","_d$player","_d$lane","slotIndex","slotPositions","DRAW_LAYOUT_OVERLAY","load","onerror","si","requestAnimationFrame","__pc_triggerGovAnim","_zone$data$player2","_zone$data$lane2","_zone$data$index2","_z$data$card$uid5","pc_triggerGovAnim","__pc_triggerHitAnim","_zone$data$player3","_zone$data$lane3","_zone$data$index3","_z$data$card$uid6","pc_triggerHitAnim","loop","cancelAnimationFrame","handleCardClick","_data$card$uid","_data$card","_data$card2","_data$card$uid2","_data$card3","_data$card4","_gameState$hands","idxInState","_c$uid3","_gameState$board$1$in","_gameState$board","_gameState$board$","_gameState$board$1$au","_gameState$board2","_gameState$board2$","cap","rowCards","handleClick","getBoundingClientRect","mx","clientX","my","clientY","hit","err","handleCardClickInternal","handleMouseMove","_hit$data$card","handleWheel","handLen","sign","deltaY","slotH","visible","maxOffset","handleTouchStart","touches","handleTouchMove","_lastTouchYRef$curren","last","handleTouchEnd","__pc_triggerInstantAnim","pc_triggerInstantAnim","_board5","_board5$p","_board5$p$aussen","onDiceResult","ref","display","imageRendering","onClick","onMouseMove","onWheel","onTouchStart","onTouchMove","onTouchEnd","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/components/GameCanvas.tsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback } from 'react';\nimport { useVisualEffects, useVisualEffectsSafe } from '../context/VisualEffectsContext';\nimport { GameState, Card, PoliticianCard, Player, Lane } from '../types/game';\nimport { LAYOUT, getZone, computeSlotRects, getUiTransform, getLaneCapacity, getPublicRects, getGovernmentRects, getSofortRect } from '../ui/layout';\nimport { drawCardImage, sortHandCards } from '../utils/gameUtils';\nimport { getNetApCost } from '../utils/ap';\nimport { getCardImagePath } from '../data/gameData';\nimport influenceIconUrl from '../assets/icons/influence.svg';\nimport publicSymbolUrl from '../assets/icons/public_symbol.png';\nimport sofortSymbolUrl from '../assets/icons/sofort_initiative_symbol.png';\nimport dauerhaftSymbolUrl from '../assets/icons/dauerhaft_initative.png';\nimport governmentSymbolUrl from '../assets/icons/government_symbol.png';\nimport interventionSymbolUrl from '../assets/icons/intervention_symbol.png';\nimport govPlaceGifUrl from '../assets/effect_gif/place_card_gov_256x256.gif';\nimport govPlaceSpritesheetUrl from '../ui/sprites/playcard_gov_256x256_14.png';\nimport instantSpritesheetUrl from '../ui/sprites/activate_trap_hit_target_256x256_16x2.png';\nimport hitSpritesheetUrl from '../ui/sprites/activate_inititive_hit_target_256x256_16_2rows.png';\n\ninterface GameCanvasProps {\n  gameState: GameState;\n  selectedHandIndex: number | null;\n  onCardClick: (data: any) => void;\n  onCardHover: (data: any) => void;\n  devMode?: boolean; // 🔧 DEV MODE: Show P2 hand when true\n}\n\n// Helper: is corruption target selection active\nfunction isCorruptionSelection(state: GameState, player: Player) {\n  const sel: any = (state as any).pendingAbilitySelect;\n  return sel && sel.type === 'corruption_steal' && sel.actorPlayer === player;\n}\n\n// Helper: is maulwurf corruption active\nfunction isMaulwurfCorruption(state: GameState, player: Player) {\n  const sel: any = (state as any).pendingAbilitySelect;\n  return sel && sel.type === 'maulwurf_steal' && sel.actorPlayer === player;\n}\n\n// Helper: is tunnelvision probe active\nfunction isTunnelvisionProbe(state: GameState, player: Player) {\n  const sel: any = (state as any).pendingAbilitySelect;\n  return sel && sel.type === 'tunnelvision_probe' && sel.actorPlayer === player;\n}\n\nexport const GameCanvas: React.FC<GameCanvasProps> = ({\n  gameState,\n  selectedHandIndex,\n  onCardClick,\n  onCardHover,\n  devMode = false,\n}) => {\n  // listen for dice roll requests from resolver and trigger Dice3D\n  useEffect(() => {\n    const handler = (ev: any) => {\n      try {\n        const player = ev.detail?.player;\n        // find Dice3D canvas on page and trigger click (it rolls on click)\n        const dice = document.querySelector('canvas') as HTMLCanvasElement | null;\n        // better: dispatch global event so App-level Dice3D component can roll programmatically\n        window.dispatchEvent(new CustomEvent('pc:ui_request_dice_roll', { detail: { player } }));\n      } catch (e) {}\n    };\n    window.addEventListener('pc:request_dice_roll', handler as EventListener);\n    return () => window.removeEventListener('pc:request_dice_roll', handler as EventListener);\n  }, []);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const visualEffects = useVisualEffectsSafe();\n  const clickZonesRef = useRef<Array<{ x: number; y: number; w: number; h: number; data: any }>>([]);\n  // Smooth vertical scroll for P1 hand when it has more than visible slots\n  const handScrollTargetRef = useRef<number>(0);\n  const handScrollCurrentRef = useRef<number>(0);\n  const handScrollEnabledRef = useRef<boolean>(true);\n  // Touch handling refs\n  const touchStartYRef = useRef<number | null>(null);\n  const lastTouchYRef = useRef<number | null>(null);\n  const isTouchingRef = useRef<boolean>(false);\n  const backgroundImageRef = useRef<HTMLImageElement | null>(null);\n  const imageCacheRef = useRef<Map<string, HTMLImageElement>>(new Map());\n  const influenceImgRef = useRef<HTMLImageElement | null>(null);\n  // Animation state for visual influence changes: Map<uid, Array<Anim>>\n  const influenceAnimRef = useRef<Map<string, Array<{ start: number; duration: number; amount: number }>>>(new Map());\n  // Previous per-card influence snapshot to detect increases\n  const prevInfluencesRef = useRef<Record<string, number>>({});\n  // Slot symbol images\n  const slotSymbolImgsRef = useRef<Map<string, HTMLImageElement>>(new Map());\n  // Map of canonical slot positions for animations: key -> {x,y,w,h,cx,cy}\n  const slotPositionsRef = useRef<Record<string, { x: number; y: number; w: number; h: number; cx: number; cy: number }>>({});\n  // Mapping between animation UIDs and slot keys to ensure one-shot playback\n  const uidToKeyRef = useRef<Record<string, string>>({});\n  const keyToUidRef = useRef<Record<string, string>>({});\n  // Temporary test GIF for government slots\n  const govGifRef = useRef<HTMLImageElement | null>(null);\n  const govSpritesRef = useRef<HTMLImageElement | null>(null);\n  // hit (target) spritesheet (25 frames)\n  const hitSpritesRef = useRef<HTMLImageElement | null>(null);\n  // sprite animation state keyed by slot-key (player.lane.index)\n  const govSpriteStateRef = useRef<Record<string, { started: number; frameCount: number; frameDuration: number }>>({});\n  const instantSpritesRef = useRef<HTMLImageElement | null>(null);\n  const instantSpriteStateRef = useRef<Record<string, { started: number; frameCount: number; frameDuration: number }>>({});\n\n  const hitSpriteStateRef = useRef<Record<string, { started: number; frameCount: number; frameDuration: number }>>({});\n\n  // Corruption (Bestechungsskandal) target selection mode\n  const corruptionSelectActorRef = useRef<Player | null>(null);\n  const gameStateRef = useRef<GameState>(gameState);\n  useEffect(() => { gameStateRef.current = gameState; }, [gameState]);\n  useEffect(() => {\n    const onEnterCorruptionSelect = (ev: any) => {\n      try {\n        const actor = ev.detail?.player as Player | undefined;\n        console.log('🔥 GAMECANVAS RECEIVED pc:corruption_select_target - Actor:', actor);\n        corruptionSelectActorRef.current = actor ?? null;\n        console.log('🔥 SET corruptionSelectActorRef.current:', corruptionSelectActorRef.current);\n      } catch (e) {\n        console.error('🔥 ERROR in corruption select handler:', e);\n      }\n    };\n    window.addEventListener('pc:corruption_select_target', onEnterCorruptionSelect as EventListener);\n    // Keyboard hotkeys 1-5 to choose opponent government slot when corruption select is active\n    const onKeyDown = (ev: KeyboardEvent) => {\n      try {\n        const k = ev.key;\n        if (!['1','2','3','4','5'].includes(k)) return;\n        const actor = corruptionSelectActorRef.current;\n        if (!actor) return;\n        const victim = actor === 1 ? 2 : 1;\n        const idx = Number(k) - 1; // map '1' -> slot 0\n        const gs = gameStateRef.current as any;\n        const card = gs?.board?.[victim]?.aussen?.[idx];\n        console.debug('[CORR][KEY] pressed', k, 'actor', actor, 'victim', victim, 'idx', idx, 'card', card);\n        if (!card) return;\n        const uid = card.uid ?? card.id;\n        if (!uid) return;\n        console.debug('[CORR][KEY] dispatching pick_target for uid', uid);\n        window.dispatchEvent(new CustomEvent('pc:corruption_pick_target', { detail: { player: actor, targetUid: uid } }));\n        try {\n          console.debug('[CORR][KEY] dispatching target_selected for uid', uid);\n          window.dispatchEvent(new CustomEvent('pc:corruption_target_selected', { detail: { player: actor, targetUid: uid } }));\n        } catch(e) { console.debug('[CORR][KEY] target_selected dispatch error', e); }\n        ev.preventDefault();\n      } catch(e) {}\n    };\n    window.addEventListener('keydown', onKeyDown as EventListener);\n    return () => {\n      window.removeEventListener('pc:corruption_select_target', onEnterCorruptionSelect as EventListener);\n      window.removeEventListener('keydown', onKeyDown as EventListener);\n    };\n  }, []);\n\n  // Maulwurf corruption target selection mode\n  const maulwurfSelectActorRef = useRef<Player | null>(null);\n  useEffect(() => {\n    const onEnterMaulwurfSelect = (ev: any) => {\n      try {\n        const actor = ev.detail?.player as Player | undefined;\n        const targetUid = ev.detail?.targetUid as number | undefined;\n        const requiredRoll = ev.detail?.requiredRoll as number | undefined;\n        const targetName = ev.detail?.targetName as string | undefined;\n        console.log('🔥 GAMECANVAS RECEIVED pc:maulwurf_select_target - Actor:', actor, 'Target:', targetName, 'Required:', requiredRoll);\n        maulwurfSelectActorRef.current = actor ?? null;\n\n        // Show modal for dice roll\n        const el = document.createElement('div');\n        el.id = 'pc-maulwurf-modal';\n        el.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;';\n        el.style.fontSize = '14px';\n        document.body.appendChild(el);\n\n        el.innerHTML = `<div style=\"display:flex;flex-direction:column;gap:8px;min-width:260px;\">\n          <div style=\"font-weight:700\">Maulwurf — Ziel automatisch gewählt</div>\n          <div>Gewähltes Ziel: <b>${targetName || 'Unbekannt'}</b></div>\n          <div>Probe: W6 ≥ ${requiredRoll || 2} (2 + Anzahl Regierungskarten)</div>\n          <div style=\"display:flex;gap:8px;justify-content:flex-end;\">\n            <button id=\"pc-maulwurf-roll\" style=\"background:#2563eb;color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;\">Würfeln</button>\n            <button id=\"pc-maulwurf-cancel\" style=\"background:#374151;color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;\">Abbrechen</button>\n          </div>\n        </div>`;\n\n        // Event listeners for buttons\n        const rollBtn = el.querySelector('#pc-maulwurf-roll');\n        const cancelBtn = el.querySelector('#pc-maulwurf-cancel');\n\n        if (rollBtn) {\n          rollBtn.addEventListener('click', () => {\n            try {\n              window.dispatchEvent(new CustomEvent('pc:maulwurf_request_roll', {\n                detail: { player: actor, targetUid }\n              }));\n              document.body.removeChild(el);\n            } catch (e) {\n              console.error('Maulwurf roll button error:', e);\n            }\n          });\n        }\n\n        if (cancelBtn) {\n          cancelBtn.addEventListener('click', () => {\n            try {\n              document.body.removeChild(el);\n              // Clear pending selection\n              if (typeof window !== 'undefined') {\n                window.dispatchEvent(new CustomEvent('pc:clear_pending_selection'));\n              }\n            } catch (e) {\n              console.error('Maulwurf cancel button error:', e);\n            }\n          });\n        }\n      } catch (e) {\n        console.error('🔥 ERROR in maulwurf select handler:', e);\n      }\n    };\n\n    window.addEventListener('pc:maulwurf_select_target', onEnterMaulwurfSelect as EventListener);\n\n    return () => {\n      window.removeEventListener('pc:maulwurf_select_target', onEnterMaulwurfSelect as EventListener);\n    };\n  }, []);\n\n  // Tunnelvision probe mode\n  const tunnelvisionProbeActorRef = useRef<Player | null>(null);\n  useEffect(() => {\n    const onEnterTunnelvisionProbe = (ev: any) => {\n      try {\n        const actor = ev.detail?.player as Player | undefined;\n        const targetUid = ev.detail?.targetUid as number | undefined;\n        const requiredRoll = ev.detail?.requiredRoll as number | undefined;\n        const influence = ev.detail?.influence as number | undefined;\n        console.log('🔥 GAMECANVAS RECEIVED pc:tunnelvision_probe_start - Actor:', actor, 'Target:', targetUid, 'Required:', requiredRoll, 'Influence:', influence);\n        tunnelvisionProbeActorRef.current = actor ?? null;\n        console.log('🔥 SET tunnelvisionProbeActorRef.current:', tunnelvisionProbeActorRef.current);\n\n        // Create modal for tunnelvision probe\n        const el = document.getElementById('pc-modal-root');\n        if (!el) return;\n\n        el.innerHTML = `<div style=\"display:flex;flex-direction:column;gap:8px;min-width:280px;\">\n          <div style=\"font-weight:700\">Tunnelvision — Regierungskarte Probe</div>\n          <div>Einfluss: <b>${influence || 'Unbekannt'}</b></div>\n          <div>Probe: W6 ≥ ${requiredRoll || 4} ${(influence || 0) >= 9 ? '(Einfluss 9+)' : '(Standard)'}</div>\n          <div style=\"font-size:12px;color:#666;\">Bei Misserfolg: 2-3 Karte bleibt in Hand, 1 kritischer Misserfolg entfernt Karte dauerhaft</div>\n          <div style=\"display:flex;gap:8px;justify-content:flex-end;\">\n            <button id=\"pc-tunnelvision-roll\" style=\"background:#2563eb;color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;\">Würfeln</button>\n            <button id=\"pc-tunnelvision-cancel\" style=\"background:#374151;color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;\">Abbrechen</button>\n          </div>\n        </div>`;\n\n        // Add event listeners for buttons\n        const rollBtn = document.getElementById('pc-tunnelvision-roll');\n        const cancelBtn = document.getElementById('pc-tunnelvision-cancel');\n\n        if (rollBtn) {\n          rollBtn.onclick = () => {\n            try {\n              window.dispatchEvent(new CustomEvent('pc:tunnelvision_request_roll', {\n                detail: { player: actor, targetUid, requiredRoll, influence }\n              }));\n              el.innerHTML = '';\n            } catch (e) {\n              console.error('Error dispatching tunnelvision request roll:', e);\n            }\n          };\n        }\n\n        if (cancelBtn) {\n          cancelBtn.onclick = () => {\n            el.innerHTML = '';\n            // Cancel the probe - card stays in hand\n            try {\n              window.dispatchEvent(new CustomEvent('pc:tunnelvision_request_roll', {\n                detail: { player: actor, targetUid, requiredRoll, influence, cancel: true }\n              }));\n            } catch (e) {\n              console.error('Error canceling tunnelvision probe:', e);\n            }\n          };\n        }\n      } catch (e) {\n        console.error('🔥 ERROR in tunnelvision probe handler:', e);\n      }\n    };\n\n    window.addEventListener('pc:tunnelvision_probe_start', onEnterTunnelvisionProbe as EventListener);\n\n    return () => {\n      window.removeEventListener('pc:tunnelvision_probe_start', onEnterTunnelvisionProbe as EventListener);\n    };\n  }, []);\n\n  // Helper: draw slot icons with uniform pulsing opacity and a light reflection\n  const drawSlotIconWithPulse = useCallback((ctx: CanvasRenderingContext2D, img: HTMLImageElement | undefined, x: number, y: number, w: number, h: number, phase = 0) => {\n    if (!img || !img.complete) return;\n    try {\n      const now = performance.now();\n      const base = 0.10; // base opacity\n      const pulseRange = 0.08; // pulse amplitude (-> up to base + pulseRange)\n      const period = 700; // ms\n      const pulse = base + pulseRange * (0.5 + 0.5 * Math.sin(now / period + phase));\n\n      // draw icon with pulsing alpha\n      ctx.save();\n      ctx.globalAlpha = pulse;\n      ctx.drawImage(img, x, y, w, h);\n\n      // subtle reflection: gradient overlay on top half\n      const grad = ctx.createLinearGradient(x, y, x, y + h * 0.5);\n      grad.addColorStop(0, `rgba(255,255,255,${0.18 * pulse})`);\n      grad.addColorStop(1, `rgba(255,255,255,0)`);\n      ctx.globalCompositeOperation = 'lighter';\n      ctx.fillStyle = grad as any;\n      ctx.fillRect(x, y, w, h * 0.5);\n\n      ctx.restore();\n    } catch (e) {\n      // silent fallback\n    }\n  }, []);\n\n  // Load influence icon once\n  useEffect(() => {\n    const img = new Image();\n    img.src = influenceIconUrl;\n    influenceImgRef.current = img;\n  }, []);\n\n\n  const drawCardAt = useCallback((\n    ctx: CanvasRenderingContext2D,\n    card: Card,\n    x: number,\n    y: number,\n    size: number,\n    selected: boolean = false,\n    showAPCost: boolean = false,\n    player?: Player\n  ) => {\n    // Apply per-card fade-in if a play animation is active for this uid\n    let extraAlpha = 1;\n    try {\n      const uid = (card as any).uid ?? (card as any).id;\n      const list = (visualEffects && visualEffects.playAnimsRef && visualEffects.playAnimsRef.current) || (window as any).__pc_play_anims || [];\n      const anim = list.find((a: any) => a.uid === uid);\n      if (anim) {\n        const p = Math.min(1, Math.max(0, (performance.now() - anim.started) / anim.duration));\n        // ease-out\n        extraAlpha = Math.pow(p, 2);\n      }\n    } catch (e) {}\n    let dx = x, dy = y, s = size;\n    if (selected) {\n      s = Math.floor(size * 1.05);\n      dx = x - Math.floor((s - size) / 2);\n      dy = y - Math.floor((s - size) / 2);\n    }\n\n    // Note: pulse overlay is drawn at top layer after all cards are rendered\n\n    // Draw card image with caching to prevent flicker in continuous loop\n    const src = getCardImagePath(card, 'ui');\n    const cached = imageCacheRef.current.get(src);\n    ctx.save();\n    ctx.globalAlpha = extraAlpha;\n    if (cached && cached.complete && cached.naturalWidth > 0) {\n      ctx.drawImage(cached, dx, dy, s, s);\n    } else {\n      const img = new Image();\n      img.onload = () => {\n        imageCacheRef.current.set(src, img);\n        // Note: onload happens async; draw will occur on next frame\n        // don't draw here into stale ctx\n      };\n      img.src = src;\n      imageCacheRef.current.set(src, img);\n    }\n\n    ctx.restore();\n\n    // Status-Indikatoren (für alle Board-Karten)\n    // Einfluss-Wert dauerhaft anzeigen (oben links) – nur für Regierungskarten\n    if ((card as any).kind === 'pol') {\n      const barH = Math.max(20, Math.floor(s * 0.12) + 6);\n      ctx.fillStyle = 'rgba(0,0,0,0.6)';\n      ctx.fillRect(dx, dy + s - barH, s, barH);\n\n      ctx.fillStyle = '#ffffff';\n      const fontSize = Math.floor(s * 0.12);\n      ctx.font = `bold ${fontSize}px sans-serif`;\n      ctx.textAlign = 'left';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(`${(card as any).influence ?? 0}`, dx + 8, dy + s - barH / 2);\n    }\n    // Schutz-Status (blauer Punkt)\n    if ((card as any).protected || ((card as any).shield ?? 0) > 0) {\n      ctx.fillStyle = '#1da1f2';\n      ctx.fillRect(dx + s - 22, dy + 6, 16, 16);\n    }\n    // Deaktiviert-Status (roter Punkt)\n    if ((card as any).deactivated) {\n      ctx.fillStyle = '#b63838';\n      ctx.fillRect(dx + s - 22, dy + 26, 16, 16);\n    }\n\n    // Einfluss-Badge für Handkarten oben rechts (nur Regierungskarten)\n    if (showAPCost && player && (card as any).kind === 'pol') {\n      const badgeHeight = Math.max(16, Math.floor(s * 0.12));\n      const badgeWidth = badgeHeight * 2;\n      const badgeX = dx + s - badgeWidth - 6;\n      const badgeY = dy + 6;\n\n      // Semi-transparent dunkler Hintergrund\n      ctx.fillStyle = 'rgba(0,0,0,0.6)';\n      ctx.beginPath();\n      ctx.roundRect(badgeX, badgeY, badgeWidth, badgeHeight, badgeHeight / 2);\n      ctx.fill();\n\n      // Influence icon (90% opacity) links im Badge\n      if (influenceImgRef.current && influenceImgRef.current.complete) {\n        ctx.globalAlpha = 0.9;\n        ctx.drawImage(influenceImgRef.current, badgeX + 2, badgeY + 2, badgeHeight - 4, badgeHeight - 4);\n        ctx.globalAlpha = 1;\n      }\n\n      // Influence number rechts im Badge\n      ctx.fillStyle = '#ffffff';\n      ctx.font = `bold ${Math.floor(badgeHeight * 0.5)}px sans-serif`;\n      ctx.textAlign = 'right';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(`${(card as any).influence ?? 0}`, badgeX + badgeWidth - 4, badgeY + badgeHeight / 2);\n\n      // Reset align\n      ctx.textAlign = 'start';\n      ctx.textBaseline = 'alphabetic';\n    }\n\n    // NOTE: influence overlays (pulse + labels) are drawn in a separate pass\n\n    // Auswahl-Rahmen\n    if (selected) {\n      ctx.strokeStyle = '#61dafb';\n      ctx.lineWidth = 3;\n      ctx.strokeRect(dx + 1, dy + 1, s - 2, s - 2);\n      ctx.lineWidth = 1;\n    }\n\n    // Return exact 256x256 click zone over the card\n    // Since all cards are 256x256, the click zone should match exactly\n    return { x: dx, y: dy, w: 256, h: 256 };\n  }, [gameState]);\n\n\n\n\n\n\n\n  // Slot-Benennungs-Funktion basierend auf Glossar\n  const getSlotDisplayName = useCallback((zoneId: string, index: number, player: Player): string => {\n    const slotNumber = index + 1;\n\n    if (zoneId.includes('government')) {\n      if (zoneId.includes('player')) {\n        return `Regierungsreihe Slot ${slotNumber}`;\n      } else {\n        return `Gegner Regierung Slot ${slotNumber}`;\n      }\n    } else if (zoneId.includes('public')) {\n      if (zoneId.includes('player')) {\n        return `Öffentlichkeitsreihe Slot ${slotNumber}`;\n      } else {\n        return `Gegner Öffentlichkeit Slot ${slotNumber}`;\n      }\n    } else if (zoneId.includes('permanent.government')) {\n      if (zoneId.includes('player')) {\n        return 'Regierung Spezial-Slot';\n      } else {\n        return 'Gegner Regierung Spezial-Slot';\n      }\n    } else if (zoneId.includes('permanent.public')) {\n      if (zoneId.includes('player')) {\n        return 'Öffentlichkeit Spezial-Slot';\n      } else {\n        return 'Gegner Öffentlichkeit Spezial-Slot';\n      }\n    } else if (zoneId.includes('instant')) {\n      if (zoneId.includes('player')) {\n        return 'Sofort-Slot';\n      } else {\n        return 'Gegner Sofort-Slot';\n      }\n    } else if (zoneId.includes('hand')) {\n      return 'Hand';\n    } else if (zoneId.includes('interventions')) {\n      return 'Interventionen';\n    }\n\n    return `Slot ${slotNumber}`;\n  }, []);\n\n  const drawLane = useCallback((\n    ctx: CanvasRenderingContext2D,\n    zoneId: string,\n    player: Player,\n    lane: Lane,\n    clickable: boolean\n  ) => {\n    const zone = getZone(zoneId);\n    if (!zone) return;\n\n    const slots = computeSlotRects(zone);\n    const arr = gameState.board[player][lane];\n\n    slots.forEach((s, idx) => {\n      const card = arr[idx];\n\n      // Hintergrundfarbe nach Kategorie\n      let bgColor = 'rgba(0,0,0,0.1)'; // Standard\n      if (zoneId.includes('government')) {\n        bgColor = 'rgba(255, 197, 0, 0.15)'; // Hellgelb für Regierung\n      } else if (zoneId.includes('public')) {\n        bgColor = 'rgba(0, 255, 0, 0.15)'; // Hellgrün für Öffentlichkeit\n      }\n\n      ctx.fillStyle = bgColor;\n      ctx.fillRect(s.x, s.y, s.w, s.h);\n\n      // Slot-Rahmen\n      ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n      ctx.strokeRect(s.x + 0.5, s.y + 0.5, s.w - 1, s.h - 1);\n\n      if (card) {\n        const isSelected = player === 1 && selectedHandIndex !== null && gameState.hands[1][selectedHandIndex] === card;\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, isSelected, false);\n\n        // Kartenname unter dem Slot anzeigen\n        ctx.fillStyle = 'rgba(255,255,255,0.9)';\n        ctx.font = 'bold 12px sans-serif';\n        ctx.textAlign = 'center';\n        const textY = s.y + s.h + 16;\n        ctx.fillText(card.name, s.x + s.w/2, textY);\n\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: { type: 'board_card', player, lane, index: idx, card }\n        });\n      } else if (clickable && gameState.current === player) {\n        // Slot-Benennung anzeigen (für den aktuellen Spieler)\n        const slotName = getSlotDisplayName(zoneId, idx, player);\n        ctx.fillStyle = 'rgba(255,255,255,0.6)';\n        ctx.font = '11px sans-serif';\n        ctx.textAlign = 'center';\n        const textY = s.y + s.h/2;\n        ctx.fillText(slotName, s.x + s.w/2, textY);\n\n        clickZonesRef.current.push({\n          x: s.x, y: s.y, w: s.w, h: s.h,\n          data: { type: 'row_slot', lane, index: idx }\n        });\n      }\n    });\n  }, [gameState, selectedHandIndex, drawCardAt, getSlotDisplayName]);\n\n  const drawHandP1 = useCallback((ctx: CanvasRenderingContext2D) => {\n    const hand = sortHandCards(gameState.hands[1]);\n    const zone = getZone('hand.player');\n    if (!zone) return;\n\n    const slots = computeSlotRects(zone);\n    // Apply smooth offset (lerp towards target)\n    const target = handScrollTargetRef.current;\n    handScrollCurrentRef.current += (target - handScrollCurrentRef.current) * 0.15; // easing\n    const offsetY = Math.round(handScrollCurrentRef.current);\n    slots.forEach((s: { x: number; y: number; w: number; h: number }, i: number) => {\n      const card = hand[i];\n      if (!card) return;\n      // Find original index in unsorted hand for click handling\n      const originalIndex = gameState.hands[1].findIndex(c => c.uid === card.uid);\n      const isSel = selectedHandIndex === originalIndex;\n      // apply vertical offset\n      const sx = s.x;\n      const sy = s.y + offsetY;\n      const clickZone = drawCardAt(ctx, card, sx, sy, s.w, isSel, true, 1); // Show AP cost for player 1 hand\n      clickZonesRef.current.push({ ...clickZone, data: { type: 'hand_p1', index: originalIndex, card } });\n    });\n  }, [gameState.hands, selectedHandIndex, drawCardAt]);\n\n      // 🔧 DEV MODE: Player 2 Hand (rechts unten, kompakter)\n  const drawHandP2 = useCallback((ctx: CanvasRenderingContext2D) => {\n    const hand = sortHandCards(gameState.hands[2]);\n    const zone = getZone('hand.opponent');\n    if (!zone) return;\n\n    const slots = computeSlotRects(zone);\n\n    // Hintergrund für P2 Hand\n    const [x, y, w, h] = zone.rectPx;\n    ctx.fillStyle = 'rgba(255, 100, 100, 0.15)'; // Rötlicher Hintergrund für P2\n    ctx.fillRect(x, y, w, h);\n    ctx.strokeStyle = 'rgba(255, 100, 100, 0.3)';\n    ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);\n\n    // Label für P2 Hand\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n    ctx.font = 'bold 14px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Player 2 Hand', x + w/2, y - 8);\n\n    slots.forEach((s: { x: number; y: number; w: number; h: number }, i: number) => {\n      const card = hand[i];\n      if (!card) return;\n      // Find original index in unsorted hand for click handling\n      const originalIndex = gameState.hands[2].findIndex(c => c.uid === card.uid);\n      const isSel = gameState.current === 2 && selectedHandIndex === originalIndex;\n      const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, isSel, true, 2); // Show AP cost for player 2 hand\n      clickZonesRef.current.push({ ...clickZone, data: { type: 'hand_p2', index: originalIndex, card } });\n    });\n  }, [gameState, selectedHandIndex, drawCardAt]);\n  // Interventions strip (player traps)\n  const drawInterventionsP1 = useCallback((ctx: CanvasRenderingContext2D) => {\n    const traps = gameState.traps[1] || [];\n    const zone = getZone('interventions.player');\n    if (!zone) return;\n\n    // Single intervention slot\n    const [zx, zy, zw, zh] = zone.rectPx;\n    const card = traps[0]; // Only first trap\n\n    // Hintergrund für Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.15)'; // Lavendelfarben für Interventionen\n    ctx.fillRect(zx, zy, zw, zh);\n    ctx.strokeStyle = 'rgba(200, 160, 255, 0.3)';\n    ctx.strokeRect(zx + 0.5, zy + 0.5, zw - 1, zh - 1);\n\n    // Slot-Benennung für Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.8)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Intervention', zx + 8, zy + zh - 6);\n\n    if (card) {\n      const clickZone = drawCardAt(ctx, card, zx, zy, zw, false, false);\n      clickZonesRef.current.push({ ...clickZone, data: { type: 'trap_p1', index: 0, card } });\n    }\n  }, [gameState.traps, drawCardAt]);\n\n  // Interventions strip (opponent traps)\n  const drawInterventionsP2 = useCallback((ctx: CanvasRenderingContext2D) => {\n    const traps = gameState.traps[2] || [];\n    const zone = getZone('interventions.opponent');\n    if (!zone) return;\n\n    // Single intervention slot\n    const [zx, zy, zw, zh] = zone.rectPx;\n    const card = traps[0]; // Only first trap\n\n    // Hintergrund für Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.15)'; // Lavendelfarben für Interventionen\n    ctx.fillRect(zx, zy, zw, zh);\n    ctx.strokeStyle = 'rgba(200, 160, 255, 0.3)';\n    ctx.strokeRect(zx + 0.5, zy + 0.5, zw - 1, zh - 1);\n\n    // Slot-Benennung für Interventions-Slot\n    ctx.fillStyle = 'rgba(200, 160, 255, 0.8)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    ctx.fillText('Intervention', zx + 8, zy + zh - 6);\n\n    if (card) {\n      const clickZone = drawCardAt(ctx, card, zx, zy, zw, false, false);\n      clickZonesRef.current.push({ ...clickZone, data: { type: 'trap_p2', index: 0, card } });\n    }\n  }, [gameState.traps, drawCardAt]);\n\n  // Single slot drawing function\n  const drawSingleSlot = useCallback((\n    ctx: CanvasRenderingContext2D,\n    zoneId: string,\n    card: Card | null,\n    clickType: string,\n    player: Player\n  ) => {\n    const zone = getZone(zoneId);\n    if (!zone) return;\n    const [x, y, w, h] = zone.rectPx;\n\n    // Hintergrundfarbe nach Kategorie\n    let bgColor = 'rgba(0,0,0,0.1)'; // Standard\n    if (zoneId.includes('government')) {\n      bgColor = 'rgba(255, 197, 0, 0.15)'; // Hellgelb für Regierung\n    } else if (zoneId.includes('public')) {\n      bgColor = 'rgba(0, 255, 0, 0.15)'; // Hellgrün für Öffentlichkeit\n    } else if (zoneId.includes('instant')) {\n      bgColor = 'rgba(127, 116, 91, 0.15)'; // Neutral für Sofort-Slots\n    } else if (zoneId.includes('permanent')) {\n      // Unterscheide zwischen government und public permanent slots\n      if (zoneId.includes('government')) {\n        bgColor = 'rgba(255, 197, 0, 0.15)';\n      } else if (zoneId.includes('public')) {\n        bgColor = 'rgba(0, 255, 0, 0.15)';\n      }\n    }\n\n    ctx.fillStyle = bgColor;\n    ctx.fillRect(x, y, w, h);\n\n    // Draw slot border\n    ctx.strokeStyle = 'rgba(255,255,255,0.06)';\n    ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);\n\n    if (card) {\n      const isSelected = player === 1 && selectedHandIndex !== null && gameState.hands[1][selectedHandIndex] === card;\n      const clickZone = drawCardAt(ctx, card, x, y, w, isSelected, false);\n\n      // Kartenname unter dem Slot anzeigen\n      ctx.fillStyle = 'rgba(255,255,255,0.9)';\n      ctx.font = 'bold 12px sans-serif';\n      ctx.textAlign = 'center';\n      const textY = y + h + 16;\n      ctx.fillText(card.name, x + w/2, textY);\n\n      // Register click zone for the card - always in dev mode, otherwise only for current player\n      if (devMode || player === gameState.current) {\n        clickZonesRef.current.push({ ...clickZone, data: { type: 'slot_card', slot: clickType, player, card } });\n      }\n\n      // 🔧 NEU: Sofort-Initiative-Slots sind immer klickbar für Aktivierung (handled by activateInstantInitiative)\n      if (clickType === 'instant') {\n        clickZonesRef.current.push({\n          x, y, w, h,\n          data: { type: 'activate_instant', player, card }\n        });\n      }\n    } else if (gameState.current === player || devMode) {\n      // Slot-Benennung für leere Slots anzeigen (für den aktuellen Spieler oder im Dev Mode)\n      const slotName = getSlotDisplayName(zoneId, 0, player);\n      ctx.fillStyle = 'rgba(255,255,255,0.6)';\n      ctx.font = '11px sans-serif';\n      ctx.textAlign = 'center';\n      const textY = y + h/2;\n      ctx.fillText(slotName, x + w/2, textY);\n\n      clickZonesRef.current.push({ x, y, w, h, data: { type: 'empty_slot', slot: clickType, player } });\n    }\n  }, [selectedHandIndex, gameState, drawCardAt, getSlotDisplayName, devMode]);\n\n  // Small UI hook: show a lightweight corruption modal overlay when a target is selected\n  useEffect(() => {\n    const onTargetSelected = (ev: any) => {\n      const { player, targetUid } = ev.detail || {};\n      if (!player || !targetUid) return;\n      // create transient overlay element if not present\n      try {\n        const id = 'pc-corruption-modal';\n        let el = document.getElementById(id);\n        if (!el) {\n          el = document.createElement('div');\n          el.id = id;\n          el.style.position = 'fixed';\n          el.style.left = '50%';\n          el.style.top = '40%';\n          el.style.transform = 'translate(-50%, -50%)';\n          el.style.padding = '12px 16px';\n          el.style.background = 'rgba(6,10,15,0.9)';\n          el.style.border = '1px solid rgba(255,255,255,0.12)';\n          el.style.borderRadius = '8px';\n          el.style.zIndex = '3000';\n          el.style.color = '#e5e7eb';\n          el.style.fontFamily = 'monospace';\n          el.style.fontSize = '14px';\n          document.body.appendChild(el);\n        }\n        const card = (gameState as any).board?.[player === 1 ? 1 : 2]?.aussen?.find((c:any)=>c.uid===targetUid) || (gameState as any).board?.[player === 1 ? 2 : 1]?.aussen?.find((c:any)=>c.uid===targetUid);\n        el.innerHTML = `<div style=\"display:flex;flex-direction:column;gap:8px;min-width:260px;\">\n          <div style=\"font-weight:700\">Bestechungsskandal 2.0 — Ziel gewählt</div>\n          <div>Gewähltes Ziel: <b>${card ? card.name : 'UID '+targetUid}</b></div>\n          <div>Probe: W6 ≥ Einfluss (inkl. Oligarch-Bonus)</div>\n          <div style=\"display:flex;gap:8px;justify-content:flex-end;\">\n            <button id=\"pc-corruption-roll\" style=\"background:#2563eb;color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;\">Würfeln</button>\n            <button id=\"pc-corruption-cancel\" style=\"background:#374151;color:white;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;\">Abbrechen</button>\n          </div>\n        </div>`;\n\n        const rollBtn = document.getElementById('pc-corruption-roll');\n        const cancelBtn = document.getElementById('pc-corruption-cancel');\n        if (rollBtn) {\n          rollBtn.onclick = () => {\n            try {\n              console.log('🔥 CORRUPTION WÜRFELN CLICKED - triggering dice roll');\n              // Trigger the dice component to roll\n              window.dispatchEvent(new CustomEvent('pc:ui_request_dice_roll', { detail: { player, targetUid } }));\n              window.dispatchEvent(new CustomEvent('pc:corruption_request_roll', { detail: { player, targetUid } }));\n            } catch(e) {\n              console.error('🔥 ERROR triggering dice roll:', e);\n            }\n            // disable until result\n            (rollBtn as HTMLButtonElement).disabled = true;\n            (rollBtn as HTMLButtonElement).innerText = 'Würfelt...';\n          };\n        }\n        if (cancelBtn) {\n          cancelBtn.onclick = () => {\n            el!.remove();\n          };\n        }\n      } catch (e) { console.debug('corruption modal create failed', e); }\n    };\n\n    window.addEventListener('pc:corruption_target_selected', onTargetSelected as EventListener);\n    return () => window.removeEventListener('pc:corruption_target_selected', onTargetSelected as EventListener);\n  }, [gameState]);\n\n  // Draw permanent slots for player\n  const drawPermanentSlotsP1 = useCallback((ctx: CanvasRenderingContext2D) => {\n    drawSingleSlot(ctx, 'slot.permanent.government.player', gameState.permanentSlots[1].government, 'permanent_government', 1);\n    drawSingleSlot(ctx, 'slot.permanent.public.player', gameState.permanentSlots[1].public, 'permanent_public', 1);\n  }, [gameState.permanentSlots, drawSingleSlot]);\n\n  // Draw permanent slots for opponent\n  const drawPermanentSlotsP2 = useCallback((ctx: CanvasRenderingContext2D) => {\n    drawSingleSlot(ctx, 'slot.permanent.government.opponent', gameState.permanentSlots[2].government, 'permanent_government', 2);\n    drawSingleSlot(ctx, 'slot.permanent.public.opponent', gameState.permanentSlots[2].public, 'permanent_public', 2);\n  }, [gameState.permanentSlots, drawSingleSlot]);\n\n  // Draw instant slots\n  const drawInstantSlots = useCallback((ctx: CanvasRenderingContext2D) => {\n    // Sofort-Initiative-Slots aus dem Board zeichnen\n    const sofortPlayerCard = gameState.board[1].sofort[0];\n    const sofortOppCard = gameState.board[2].sofort[0];\n\n    drawSingleSlot(ctx, 'slot.instant.player', sofortPlayerCard, 'instant', 1);\n    drawSingleSlot(ctx, 'slot.instant.opponent', sofortOppCard, 'instant', 2);\n  }, [gameState.board, drawSingleSlot]);\n\n  // Aktive Schlüsselwörter und Unterkategorien ermitteln\n  const getActiveKeywordsAndSubcategories = useCallback((player: Player) => {\n    const board = gameState.board[player];\n    const permanentSlots = gameState.permanentSlots[player];\n    const allCards = [\n      ...board.innen,\n      ...board.aussen,\n      permanentSlots.government,\n      permanentSlots.public\n    ].filter(c => c && c.kind === 'pol') as PoliticianCard[];\n\n    const keywords = new Set<string>();\n    const subcategories = new Set<string>();\n\n    allCards.forEach(card => {\n      if (!card.deactivated) {\n        // Regierungskarten-Schlüsselwörter\n        if (card.tag === 'Leadership') {\n          keywords.add('Leadership');\n        }\n        if (card.tag === 'Diplomat') {\n          keywords.add('Diplomat');\n        }\n\n        // Öffentlichkeits-Unterkategorien (für Karten in Öffentlichkeitsreihe)\n        if (board.innen.includes(card)) {\n          const publicCard = card as any;\n          if (publicCard.tag) {\n            // Oligarch\n            const oligarchNames = ['Elon Musk', 'Bill Gates', 'George Soros', 'Warren Buffett', 'Mukesh Ambani', 'Jeff Bezos', 'Alisher Usmanov', 'Gautam Adani', 'Jack Ma', 'Zhang Yiming', 'Roman Abramovich'];\n            if (oligarchNames.includes(publicCard.name)) {\n              subcategories.add('Oligarch');\n            }\n\n            // Plattform\n            const platformNames = ['Mark Zuckerberg', 'Tim Cook', 'Sam Altman', 'Jack Ma'];\n            if (platformNames.includes(publicCard.name)) {\n              subcategories.add('Plattform');\n            }\n\n            // Bewegung\n            const movementNames = ['Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'];\n            if (movementNames.includes(publicCard.name)) {\n              subcategories.add('Bewegung');\n            }\n\n            // NGO/Think-Tank\n            const ngoNames = ['Bill Gates', 'George Soros', 'Jennifer Doudna', 'Noam Chomsky', 'Anthony Fauci'];\n            if (ngoNames.includes(publicCard.name)) {\n              subcategories.add('NGO/Think-Tank');\n            }\n\n            // Intelligenz\n            const intelligenceNames = ['Jennifer Doudna', 'Noam Chomsky', 'Edward Snowden', 'Julian Assange', 'Yuval Noah Harari', 'Ai Weiwei', 'Alexei Navalny', 'Anthony Fauci'];\n            if (intelligenceNames.includes(publicCard.name)) {\n              subcategories.add('Intelligenz');\n            }\n\n            // Medien\n            const mediaNames = ['Oprah Winfrey'];\n            if (mediaNames.includes(publicCard.name)) {\n              subcategories.add('Medien');\n            }\n          }\n        }\n      }\n    });\n\n    return {\n      keywords: Array.from(keywords),\n      subcategories: Array.from(subcategories)\n    };\n  }, [gameState]);\n\n  // Info-Panels zeichnen\n  const drawInfoPanels = useCallback((ctx: CanvasRenderingContext2D) => {\n    const { keywords, subcategories } = getActiveKeywordsAndSubcategories(1);\n\n    // Panel für Regierungsschlüsselwörter (rechts neben Regierungsslots)\n    const govPanelX = 1640 + 256 + 20; // Nach dem letzten permanenten Slot\n    const govPanelY = 300; // Auf Höhe der Regierungsslots\n    const govPanelW = 120;\n    const govPanelH = 256;\n\n    // Regierungspanel Hintergrund\n    ctx.fillStyle = 'rgba(255, 197, 0, 0.15)';\n    ctx.fillRect(govPanelX, govPanelY, govPanelW, govPanelH);\n    ctx.strokeStyle = 'rgba(255, 197, 0, 0.3)';\n    ctx.strokeRect(govPanelX + 0.5, govPanelY + 0.5, govPanelW - 1, govPanelH - 1);\n\n    // Regierungspanel Titel\n    ctx.fillStyle = 'rgba(255, 197, 0, 0.9)';\n    ctx.font = 'bold 12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Regierung', govPanelX + govPanelW/2, govPanelY + 16);\n\n    // Schlüsselwörter auflisten\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    if (keywords.length > 0) {\n      keywords.forEach((keyword, idx) => {\n        ctx.fillText(`• ${keyword}`, govPanelX + 8, govPanelY + 36 + idx * 16);\n      });\n    } else {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\n      ctx.fillText('Keine aktiven', govPanelX + 8, govPanelY + 36);\n      ctx.fillText('Schlüsselwörter', govPanelX + 8, govPanelY + 52);\n    }\n\n    // Panel für Öffentlichkeits-Unterkategorien (rechts neben Öffentlichkeitsslots)\n    const pubPanelX = 1640 + 256 + 20;\n    const pubPanelY = 580; // Auf Höhe der Öffentlichkeitsslots\n    const pubPanelW = 120;\n    const pubPanelH = 256;\n\n    // Öffentlichkeitspanel Hintergrund\n    ctx.fillStyle = 'rgba(0, 255, 0, 0.15)';\n    ctx.fillRect(pubPanelX, pubPanelY, pubPanelW, pubPanelH);\n    ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';\n    ctx.strokeRect(pubPanelX + 0.5, pubPanelY + 0.5, pubPanelW - 1, pubPanelH - 1);\n\n    // Öffentlichkeitspanel Titel\n    ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';\n    ctx.font = 'bold 12px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText('Öffentlichkeit', pubPanelX + pubPanelW/2, pubPanelY + 16);\n\n    // Unterkategorien auflisten\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n    ctx.font = '11px sans-serif';\n    ctx.textAlign = 'left';\n    if (subcategories.length > 0) {\n      subcategories.forEach((subcategory, idx) => {\n        const displayName = subcategory.length > 12 ? subcategory.substring(0, 10) + '...' : subcategory;\n        ctx.fillText(`• ${displayName}`, pubPanelX + 8, pubPanelY + 36 + idx * 16);\n      });\n    } else {\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\n      ctx.fillText('Keine aktiven', pubPanelX + 8, pubPanelY + 36);\n      ctx.fillText('Unterkategorien', pubPanelX + 8, pubPanelY + 52);\n    }\n  }, [getActiveKeywordsAndSubcategories]);\n\n  // Move diagnostics to draw callback to ensure they run after canvas is actually rendered\n  const runDiagnostics = useCallback(() => {\n    try {\n      const handZones = clickZonesRef.current.filter(z => z.data && z.data.type === 'hand_p1');\n      const uiUIDs = handZones.map(z => (z.data.card && (z.data.card.uid ?? z.data.card.id)) ).filter(Boolean);\n      const stateHand = gameState.hands && gameState.hands[1] ? gameState.hands[1] : [];\n      const stateUIDs = stateHand.map((c: any) => c.uid ?? c.id).filter(Boolean);\n\n      const missingInState = uiUIDs.filter((u: any) => !stateUIDs.includes(u));\n      const missingInUI = stateUIDs.filter((u: any) => !uiUIDs.includes(u));\n\n      // Only warn if there are cards in UI that don't exist in state (real error)\n      // Don't warn about missing UI cards due to limited slot capacity\n      if (missingInState.length > 0) {\n        const mismatch = {\n          ts: Date.now(),\n          uiCount: uiUIDs.length,\n          stateCount: stateUIDs.length,\n          uiUIDs,\n          stateUIDs,\n          missingInState,\n          missingInUI,\n          stack: (new Error('mismatch-stack')).stack\n        };\n        (window as any).__politicardDebug = {\n          ...(window as any).__politicardDebug,\n          mismatch: [ ...(window as any).__politicardDebug?.mismatch || [] ].slice(-19).concat([mismatch])\n        };\n        // Clear, then log to console so user can copy/paste trace\n        console.warn('POLITICARD DIAGNOSTIC: hand mismatch detected', mismatch);\n      }\n    } catch (e) {\n      // swallow diagnostic errors to avoid breaking rendering\n      console.error('Diagnostic error', e);\n    }\n  }, [gameState.hands]);\n\n  const draw = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Detect influence increases and start animations\n    try {\n      const currSnapshot: Record<string, number> = {};\n      const collect = (c: any) => {\n        if (!c) return;\n        if ((c as any).kind !== 'pol') return;\n        const uid = c.uid ?? (c.id != null ? String(c.id) : null);\n        if (!uid) return;\n        currSnapshot[uid] = (c.influence ?? 0) as number;\n      };\n      // board rows\n      (gameState.board[1].aussen || []).forEach(collect);\n      (gameState.board[2].aussen || []).forEach(collect);\n      (gameState.board[1].innen || []).forEach(collect);\n      (gameState.board[2].innen || []).forEach(collect);\n      // permanent slots\n      collect(gameState.permanentSlots[1].government as any);\n      collect(gameState.permanentSlots[2].government as any);\n      collect(gameState.permanentSlots[1].public as any);\n      collect(gameState.permanentSlots[2].public as any);\n\n      const now = performance.now();\n      Object.keys(currSnapshot).forEach(uid => {\n        const curr = currSnapshot[uid] ?? 0;\n        const prev = prevInfluencesRef.current[uid] ?? curr;\n        if (curr > prev) {\n          const delta = curr - prev;\n          const list = influenceAnimRef.current.get(uid) || [];\n          list.push({ start: now, duration: 900, amount: delta });\n          influenceAnimRef.current.set(uid, list);\n        }\n        prevInfluencesRef.current[uid] = curr;\n      });\n    } catch (e) {\n      // ignore\n    }\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Clear click zones\n    clickZonesRef.current = [];\n\n    // Background: prefer PNG if configured\n    if (LAYOUT.background?.enabled && LAYOUT.background?.src) {\n      if (backgroundImageRef.current) {\n        ctx.drawImage(backgroundImageRef.current, 0, 0, canvas.width, canvas.height);\n      } else {\n        ctx.fillStyle = '#0c131b';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n      }\n    } else {\n      ctx.fillStyle = '#0c131b';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Apply UI transform (new signature)\n    const { scale, offsetX, offsetY } = getUiTransform(canvas.width, canvas.height);\n    ctx.save();\n    ctx.translate(offsetX, offsetY);\n    ctx.scale(scale, scale);\n\n    // Draw opponent board (top rows) - clickable im Dev Mode\n    // Draw opponent board using new layout system\n    const opponentPublicRects = getPublicRects('opponent');\n    const opponentGovRects = getGovernmentRects('opponent');\n\n    // Draw opponent public slots\n    opponentPublicRects.forEach((s: { x: number; y: number; w: number; h: number }, idx: number) => {\n      const card = gameState.board[2].innen[idx];\n      if (card) {\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 2);\n        // Register hover/click zone for opponent card (always) - include card for hover info\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: { type: 'board_card', player: 2, lane: 'innen', index: idx, card }\n        });\n      }\n      else {\n        // draw placeholder symbol for empty public slot\n        const img = slotSymbolImgsRef.current.get('public');\n        drawSlotIconWithPulse(ctx, img, s.x, s.y, s.w, s.h, 0.4);\n        // Register empty slot click zone in dev mode\n        if (devMode) {\n          clickZonesRef.current.push({\n            x: s.x, y: s.y, w: s.w, h: s.h,\n            data: { type: 'row_slot', player: 2, lane: 'innen', index: idx }\n          });\n        }\n      }\n    });\n\n    // Draw opponent government slots\n    opponentGovRects.forEach((s: { x: number; y: number; w: number; h: number }, idx: number) => {\n      const card = gameState.board[2].aussen[idx];\n      const corrActive = !!((gameState as any).pendingAbilitySelect && (gameState as any).pendingAbilitySelect.type === 'corruption_steal');\n      if (card) {\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 2);\n        // Register hover/click zone for opponent card (always) - include card for hover info\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: { type: 'board_card', player: 2, lane: 'aussen', index: idx, card }\n        });\n        // When corruption target selection is active, register exact slot rectangle for click detection\n        if (corrActive) {\n          clickZonesRef.current.push({\n            x: s.x,\n            y: s.y,\n            w: s.w,\n            h: s.h,\n            data: { type: 'board_card', player: 2, lane: 'aussen', index: idx, card }\n          });\n        }\n      }\n      else {\n        const img = slotSymbolImgsRef.current.get('government');\n        drawSlotIconWithPulse(ctx, img, s.x, s.y, s.w, s.h, 0.1);\n        // Register empty slot click zone only in dev mode\n        if (devMode) {\n          clickZonesRef.current.push({\n            x: s.x, y: s.y, w: s.w, h: s.h,\n            data: { type: 'row_slot', player: 2, lane: 'aussen', index: idx }\n          });\n        }\n      }\n    });\n\n    // Draw opponent permanent slots (show icons even when not current)\n    try {\n      const permGovZoneOpp = getZone('slot.permanent.government.opponent');\n      if (permGovZoneOpp) {\n        const card = gameState.permanentSlots[2].government;\n        const [ox, oy, ow, oh] = permGovZoneOpp.rectPx;\n        if (card) {\n          drawSingleSlot(ctx, 'slot.permanent.government.opponent', card, 'permanent_government', 2);\n        } else {\n          const img = slotSymbolImgsRef.current.get('dauerhaft');\n          drawSlotIconWithPulse(ctx, img, ox, oy, ow, oh, 0.3);\n          // Register empty slot click zone in dev mode\n          if (devMode) {\n            clickZonesRef.current.push({\n              x: ox, y: oy, w: ow, h: oh,\n              data: { type: 'empty_slot', slot: 'permanent_government', player: 2 }\n            });\n          }\n        }\n      }\n    } catch (e) {}\n    try {\n      const permPubZoneOpp = getZone('slot.permanent.public.opponent');\n      if (permPubZoneOpp) {\n        const card = gameState.permanentSlots[2].public;\n        const [ox2, oy2, ow2, oh2] = permPubZoneOpp.rectPx;\n        if (card) {\n          drawSingleSlot(ctx, 'slot.permanent.public.opponent', card, 'permanent_public', 2);\n        } else {\n          const img = slotSymbolImgsRef.current.get('dauerhaft');\n          drawSlotIconWithPulse(ctx, img, ox2, oy2, ow2, oh2, 0.7);\n          // Register empty slot click zone in dev mode\n          if (devMode) {\n            clickZonesRef.current.push({\n              x: ox2, y: oy2, w: ow2, h: oh2,\n              data: { type: 'empty_slot', slot: 'permanent_public', player: 2 }\n            });\n          }\n        }\n      }\n    } catch (e) {}\n\n    // Draw player board (middle rows)\n    // Draw player board using new layout system\n    const playerPublicRects = getPublicRects('player');\n    const playerGovRects = getGovernmentRects('player');\n\n    // Draw player public slots\n    playerPublicRects.forEach((s: { x: number; y: number; w: number; h: number }, idx: number) => {\n      const card = gameState.board[1].innen[idx];\n      if (card) {\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 1);\n        // register card zone including card so hover panel can show details\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: { type: 'board_card', player: 1, lane: 'innen', index: idx, card }\n        });\n      } else {\n        // Empty slot click zone and draw public symbol\n        // Draw unified pulsing icon for empty public slot\n        const img = slotSymbolImgsRef.current.get('public');\n        drawSlotIconWithPulse(ctx, img, s.x, s.y, s.w, s.h, 0.4);\n        clickZonesRef.current.push({\n          x: s.x, y: s.y, w: s.w, h: s.h,\n          data: { type: 'row_slot', player: 1, lane: 'innen', index: idx }\n        });\n      }\n    });\n\n    // Draw player government slots\n    playerGovRects.forEach((s: { x: number; y: number; w: number; h: number }, idx: number) => {\n      const card = gameState.board[1].aussen[idx];\n      if (card) {\n        const clickZone = drawCardAt(ctx, card, s.x, s.y, s.w, false, false, 1);\n        clickZonesRef.current.push({\n          ...clickZone,\n          data: { type: 'board_card', player: 1, lane: 'aussen', index: idx, card }\n        });\n      } else {\n        // Empty slot click zone and draw government symbol\n        const img = slotSymbolImgsRef.current.get('government');\n        drawSlotIconWithPulse(ctx, img, s.x, s.y, s.w, s.h, 0.1);\n        clickZonesRef.current.push({\n          x: s.x, y: s.y, w: s.w, h: s.h,\n          data: { type: 'row_slot', player: 1, lane: 'aussen', index: idx }\n        });\n      }\n    });\n\n    // --- GOV PLACEMENT SPRITESHEET OVERLAY (frame-based) ---\n    try {\n      const sprites = govSpritesRef.current;\n      const gif = govGifRef.current;\n      const anims = (visualEffects && visualEffects.playAnimsRef && visualEffects.playAnimsRef.current) || [];\n\n      // Start sprite animation when a playAnim for a gov-card is active and maps to a slot\n      const now = performance.now();\n      // Prefer mutating the source anim array so entries are consumed and don't retrigger repeatedly\n      const animsArr: Array<{ uid: string | number; started: number; duration: number; lane?: string }> = (visualEffects && visualEffects.playAnimsRef && visualEffects.playAnimsRef.current) || ((window as any).__pc_play_anims = (window as any).__pc_play_anims || []);\n\n      // Iterate backwards and consume processed animations to ensure one-shot playback\n      for (let i = animsArr.length - 1; i >= 0; i--) {\n        const a = animsArr[i];\n        try {\n          // handle specialized 'hit:' playAnims which indicate target-hit sprites by slot key\n          if (typeof a.uid === 'string' && a.uid.indexOf('hit:') === 0) {\n            const inner = a.uid.slice(4); // '1.aussen.0'\n            if (!hitSpriteStateRef.current[inner]) {\n              hitSpriteStateRef.current[inner] = { started: now, frameCount: 25, frameDuration: 30 };\n              animsArr.splice(i, 1);\n            }\n            continue;\n          }\n        } catch (e) {}\n\n        // find the zone/slot for this uid\n        const zone = clickZonesRef.current.find(z => z.data && z.data.card && ((z.data.card.uid ?? String(z.data.card.id)) === a.uid));\n        if (!zone) continue;\n\n        // determine if gov slot or instant\n        let isGov = false;\n        let isInstant = false;\n        try {\n          const dt = zone.data || {};\n          if (dt.type === 'row_slot' && dt.lane === 'aussen') isGov = true;\n          if (dt.type === 'board_card' && dt.lane === 'aussen') isGov = true;\n          if (dt.slot && typeof dt.slot === 'string' && dt.slot.includes('government')) isGov = true;\n          if (dt.type === 'activate_instant' || (dt.slot && typeof dt.slot === 'string' && dt.slot.includes('instant'))) isInstant = true;\n        } catch (e) {}\n        if (!isGov && !isInstant) continue;\n\n        const player = zone.data.player ?? 1;\n        const lane = zone.data.lane ?? 'aussen';\n        const idx = zone.data.index ?? 0;\n        const key = `${player}.${lane}.${idx}`;\n\n        // initialize sprite state if not present; consume the anim entry only when we actually start playback\n        let startedThis = false;\n        if (isGov) {\n          if (!govSpriteStateRef.current[key]) {\n            govSpriteStateRef.current[key] = { started: now, frameCount: 14, frameDuration: 40 }; // 14 frames @ ~40ms -> ~560ms\n            startedThis = true;\n          }\n        }\n        if (isInstant) {\n          const instKey = `${player}.instant.${idx}`;\n          if (!instantSpriteStateRef.current[instKey]) {\n            instantSpriteStateRef.current[instKey] = { started: now, frameCount: 14, frameDuration: 40 };\n            startedThis = true;\n          }\n        }\n        if (startedThis) {\n          animsArr.splice(i, 1);\n        }\n      }\n\n      // draw running sprite animations per gov slot\n      Object.keys(govSpriteStateRef.current).forEach(k => {\n        const st = govSpriteStateRef.current[k];\n        const elapsed = now - st.started;\n        const total = st.frameCount * st.frameDuration;\n        if (elapsed > total) {\n          // animation finished; remove state\n          delete govSpriteStateRef.current[k];\n          return;\n        }\n        const frame = Math.floor(elapsed / st.frameDuration);\n\n        // parse key -> player.lane.index\n        const parts = k.split('.');\n        const player = Number(parts[0]) || 1;\n        const lane = parts[1] || 'aussen';\n        const index = Number(parts[2] || 0);\n\n        // compute slot rect for this gov slot (player or opponent board)\n        const rect = player === 1 ? playerGovRects[index] : opponentGovRects[index];\n        if (!rect) return;\n\n        // spritesheet: frame N located at x = N*256, y = 0\n        if (sprites && sprites.complete) {\n          const sx = frame * 256;\n          const sy = 0;\n          const sw = 256;\n          const sh = 256;\n          // draw exactly matching the slot rect size to avoid scaling mismatches\n          const dx = rect.x;\n          const dy = rect.y;\n          ctx.drawImage(sprites, sx, sy, sw, sh, dx, dy, rect.w, rect.h);\n        } else if (gif && gif.complete) {\n          // fallback to static gif if spritesheet missing\n          ctx.drawImage(gif, rect.x, rect.y, rect.w, rect.h);\n        }\n      });\n      // --- INSTANT INITIATIVE SPRITESHEET (draw on instant slot) ---\n      try {\n        const spritesI = instantSpritesRef.current;\n        const nowI = performance.now();\n        Object.keys(instantSpriteStateRef.current).forEach(k => {\n          const st = instantSpriteStateRef.current[k];\n          const elapsed = nowI - st.started;\n          const total = st.frameCount * st.frameDuration;\n          if (elapsed > total) { delete instantSpriteStateRef.current[k]; return; }\n          const frame = Math.floor(elapsed / st.frameDuration);\n          const parts = k.split('.');\n          const player = Number(parts[0]) || 1;\n          const index = Number(parts[2] || 0);\n          const rects = getSofortRect(player ? 'player' : 'opponent');\n          // getSofortRect returns one rect; map by player/context — fallback to zone\n          const instantRect = getZone('slot.instant.player').rectPx;\n          const [ix, iy, iw, ih] = instantRect;\n          if (spritesI && spritesI.complete) {\n            const sx = frame * 256; const sy = 0; const sw = 256; const sh = 256;\n            ctx.drawImage(spritesI, sx, sy, sw, sh, ix, iy, iw, ih);\n          }\n        });\n      } catch (e) {}\n      // --- HIT / TARGET SPRITESHEET (draw as overlay on targeted slot) ---\n      try {\n        const spritesH = hitSpritesRef.current;\n        const nowH = performance.now();\n        Object.keys(hitSpriteStateRef.current).forEach(k => {\n          const st = hitSpriteStateRef.current[k];\n          const elapsed = nowH - st.started;\n          const total = st.frameCount * st.frameDuration;\n          if (elapsed > total) { delete hitSpriteStateRef.current[k]; return; }\n          const frame = Math.floor(elapsed / st.frameDuration);\n\n          // parse key -> player.lane.index\n          const parts = k.split('.');\n          const player = Number(parts[0]) || 1;\n          const lane = parts[1] || 'aussen';\n          const index = Number(parts[2] || 0);\n\n          // compute slot rect for this gov slot (attempt gov then public)\n          const rect = (player === 1 ? playerGovRects : opponentGovRects)[index] || (player === 1 ? playerPublicRects : opponentPublicRects)[index];\n          if (!rect) return;\n\n          if (spritesH && spritesH.complete) {\n            const sx = frame * 256;\n            const sy = 0;\n            const sw = 256;\n            const sh = 256;\n            const dx = rect.x;\n            const dy = rect.y;\n            ctx.drawImage(spritesH, sx, sy, sw, sh, dx, dy, rect.w, rect.h);\n          }\n        });\n      } catch (e) {}\n    } catch (e) {}\n\n    // Draw player permanent slots (draw symbols if empty)\n    // permanent government\n    const permGovZone = getZone('slot.permanent.government.player');\n    if (permGovZone) {\n      const card = gameState.permanentSlots[1].government;\n      const [x, y, w, h] = permGovZone.rectPx;\n      if (card) {\n        drawSingleSlot(ctx, 'slot.permanent.government.player', card, 'permanent_government', 1);\n      } else {\n        // Draw all slot icons using unified helper (so 'dauerhaft' used visually for empty permanent gov slot)\n        const img = slotSymbolImgsRef.current.get('dauerhaft');\n        drawSlotIconWithPulse(ctx, img, x, y, w, h, 0.2);\n      }\n    }\n    // permanent public\n    const permPubZone = getZone('slot.permanent.public.player');\n    if (permPubZone) {\n      const card = gameState.permanentSlots[1].public;\n      const [x2, y2, w2, h2] = permPubZone.rectPx;\n      if (card) {\n        drawSingleSlot(ctx, 'slot.permanent.public.player', card, 'permanent_public', 1);\n      } else {\n        // Draw all slot icons using unified helper (so 'dauerhaft' used visually for empty permanent public slot)\n        const img = slotSymbolImgsRef.current.get('dauerhaft');\n        drawSlotIconWithPulse(ctx, img, x2, y2, w2, h2, 0.9);\n      }\n    }\n\n    // Draw instant slots (both players) and placeholder if empty\n    const instantPlayerZone = getZone('slot.instant.player');\n    if (instantPlayerZone) {\n      const card = gameState.board[1].sofort[0];\n      const [x, y, w, h] = instantPlayerZone.rectPx;\n      if (card) drawSingleSlot(ctx, 'slot.instant.player', card, 'instant', 1);\n      else {\n        // Use unified icon draw helper for instant slot\n        const img = slotSymbolImgsRef.current.get('sofort');\n        drawSlotIconWithPulse(ctx, img, x, y, w, h, 0.0);\n      }\n    }\n\n    // Draw interventions strip (player)\n    // We draw symbol if empty\n    const interventionsZone = getZone('interventions.player');\n    if (interventionsZone) {\n      const [zx, zy, zw, zh] = interventionsZone.rectPx;\n      const card = gameState.traps[1] && gameState.traps[1][0];\n      if (card) drawInterventionsP1(ctx);\n      else {\n        const img = slotSymbolImgsRef.current.get('intervention');\n        drawSlotIconWithPulse(ctx, img, zx, zy, zw, zh, 0.6);\n      }\n    }\n\n    // Draw interventions strip (opponent) - nur im Dev Mode\n    if (devMode) {\n      drawInterventionsP2(ctx);\n    }\n\n    // Draw hand (P1)\n    drawHandP1(ctx);\n\n    // 🔧 DEV MODE: Draw hand (P2) - nur im Dev Mode\n    if (devMode) {\n      drawHandP2(ctx);\n    }\n\n    // Draw info panels\n    drawInfoPanels(ctx);\n\n    // Draw corruption mode indicator\n    const corrActive = !!((gameState as any).pendingAbilitySelect && (gameState as any).pendingAbilitySelect.type === 'corruption_steal');\n    if (corrActive) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';\n      ctx.font = 'bold 32px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('🔥 CORRUPTION TARGET SELECTION ACTIVE 🔥', 960, 100);\n\n      ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';\n      ctx.font = 'bold 24px sans-serif';\n      ctx.fillText('Click on opponent government card to target', 960, 140);\n      ctx.restore();\n    }\n\n    // Draw maulwurf corruption mode indicator\n    const maulwurfActive = !!((gameState as any).pendingAbilitySelect && (gameState as any).pendingAbilitySelect.type === 'maulwurf_steal');\n    if (maulwurfActive) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(139, 69, 19, 0.8)'; // Brown color for mole\n      ctx.font = 'bold 32px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('🕳️ MAULWURF CORRUPTION ACTIVE 🕳️', 960, 100);\n\n      ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';\n      ctx.font = 'bold 24px sans-serif';\n      ctx.fillText('Ziel automatisch gewählt - würfeln zum Stehlen', 960, 140);\n      ctx.restore();\n    }\n\n    // Draw tunnelvision probe mode indicator\n    const tunnelvisionActive = !!((gameState as any).pendingAbilitySelect && (gameState as any).pendingAbilitySelect.type === 'tunnelvision_probe');\n    if (tunnelvisionActive) {\n      ctx.save();\n      ctx.fillStyle = 'rgba(75, 0, 130, 0.8)'; // Purple color for tunnelvision\n      ctx.font = 'bold 32px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText('🔮 TUNNELVISION PROBE ACTIVE 🔮', 960, 100);\n\n      ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';\n      ctx.font = 'bold 24px sans-serif';\n      ctx.fillText('Regierungskarte Probe - würfeln zum Fortfahren', 960, 140);\n      ctx.restore();\n    }\n\n    // --- VISUAL EFFECTS: Particle bursts, card pop scale, initiative ripple & AP pop ---\n    try {\n      const now = performance.now();\n      const { particlesRef, popsRef, ripplesRef, apLabelsRef, reducedMotion } = (visualEffects || {}) as any;\n\n      const parts: any[] = particlesRef.current || [];\n      if (!reducedMotion) {\n        for (let i = parts.length - 1; i >= 0; i--) {\n          const p = parts[i];\n          const age = now - p.start;\n          if (age > p.life) {\n            parts.splice(i, 1);\n            continue;\n          }\n          p.vy += (p.gravity || 0.09);\n          p.x += p.vx;\n          p.y += p.vy;\n          const t = 1 - age / p.life;\n          ctx.save();\n          ctx.globalAlpha = Math.max(0, Math.min(1, t));\n          ctx.fillStyle = p.color || '#ffd166';\n          ctx.beginPath();\n          ctx.arc(p.x, p.y, (p.size || 4) * t, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.restore();\n        }\n        particlesRef.current = parts;\n\n        const pops: any[] = popsRef.current || [];\n        pops.forEach((pop) => {\n          const p = Math.min(1, Math.max(0, (now - pop.started) / pop.duration));\n          const eased = 1 + 0.12 * (1 - Math.pow(1 - p, 3));\n          const zone = clickZonesRef.current.find(z => z.data && z.data.card && ((z.data.card.uid ?? String(z.data.card.id)) === pop.uid));\n          if (!zone) return;\n          ctx.save();\n          ctx.translate(zone.x + zone.w / 2, zone.y + zone.h / 2);\n          ctx.scale(eased, eased);\n          ctx.globalAlpha = 0.12 * (1 - p);\n          ctx.fillStyle = '#ffffff';\n          ctx.fillRect(-zone.w / 2, -zone.h / 2, zone.w, zone.h);\n          ctx.restore();\n        });\n\n        const ripples: any[] = ripplesRef.current || [];\n        for (let i = ripples.length - 1; i >= 0; i--) {\n          const r = ripples[i];\n          const p = Math.min(1, Math.max(0, (now - r.started) / r.duration));\n          if (p >= 1) { ripples.splice(i, 1); continue; }\n          const radius = r.radius * (0.8 + 1.8 * p);\n          ctx.save();\n          const g = ctx.createRadialGradient(r.cx, r.cy, radius * 0.1, r.cx, r.cy, radius);\n          g.addColorStop(0, `rgba(255,255,255,${0.12 * (1 - p)})`);\n          g.addColorStop(1, `rgba(255,255,255,0)`);\n          ctx.fillStyle = g as any;\n          ctx.beginPath();\n          ctx.arc(r.cx, r.cy, radius, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.restore();\n\n          if (r.showAp && !r._apSpawned) {\n            apLabelsRef.current = apLabelsRef.current || [];\n            apLabelsRef.current.push({ x: r.apX, y: r.apY, started: now, duration: 800, text: '+1' });\n            r._apSpawned = true;\n          }\n        }\n        ripplesRef.current = ripples;\n\n        const apl: any[] = apLabelsRef.current || [];\n        for (let i = apl.length - 1; i >= 0; i--) {\n          const l = apl[i];\n          const p = Math.min(1, Math.max(0, (now - l.started) / l.duration));\n          if (p >= 1) { apl.splice(i, 1); continue; }\n          ctx.save();\n          ctx.globalAlpha = 1 - p;\n          ctx.fillStyle = '#ffdd57';\n          ctx.font = 'bold 22px sans-serif';\n          ctx.textAlign = 'center';\n          ctx.fillText(l.text, l.x, l.y - 20 * p);\n          ctx.restore();\n        }\n        apLabelsRef.current = apl;\n      } else {\n        const apl: any[] = apLabelsRef.current || [];\n        for (let i = apl.length - 1; i >= 0; i--) {\n          const l = apl[i];\n          const p = Math.min(1, Math.max(0, (now - l.started) / l.duration));\n          if (p >= 1) { apl.splice(i, 1); continue; }\n          ctx.save();\n          ctx.globalAlpha = 1 - p;\n          ctx.fillStyle = '#ffdd57';\n          ctx.font = 'bold 18px sans-serif';\n          ctx.textAlign = 'center';\n          ctx.fillText(l.text, l.x, l.y - 10 * p);\n          ctx.restore();\n        }\n        apLabelsRef.current = apl;\n      }\n    } catch (e) {}\n\n    // --- Overlay pass: draw influence pulse ring and +N labels on top of all cards ---\n    try {\n      const now = performance.now();\n      // iterate over stored anims\n      influenceAnimRef.current.forEach((anims, uid) => {\n        // find card position by scanning clickZones\n        const zone = clickZonesRef.current.find(z => z.data && ((z.data.card && ((z.data.card.uid ?? String(z.data.card.id)) === uid)) || (z.data.card && z.data.card.uid === uid)) );\n        if (!zone) return;\n        const cx = zone.x + zone.w / 2;\n        const cy = zone.y + zone.h / 2;\n        // calculate aggregate pulse for this uid\n        let maxPulse = 0;\n        let totalAmount = 0;\n        const remaining: Array<{ start: number; duration: number; amount: number }> = [];\n        anims.forEach(a => {\n          const p = Math.min(1, Math.max(0, (now - a.start) / a.duration));\n          const pulse = Math.pow(Math.max(0, 1 - p), 2);\n          if (pulse > maxPulse) maxPulse = pulse;\n          if (p < 1) {\n            remaining.push(a);\n            totalAmount += a.amount;\n          }\n        });\n\n        // update list\n        if (remaining.length > 0) influenceAnimRef.current.set(uid, remaining);\n        else influenceAnimRef.current.delete(uid);\n\n        if (maxPulse > 0.001) {\n          // draw a soft ring to the right-bottom of influence number\n          const ringRadius = Math.max(8, zone.w * 0.08) * (1 + maxPulse * 0.6);\n          const ringX = zone.x + zone.w - 28; // near bottom-right where influence text lives\n          const ringY = zone.y + zone.h - 20;\n\n          ctx.save();\n          ctx.beginPath();\n          ctx.strokeStyle = `rgba(46, 204, 113, ${0.9 * maxPulse})`;\n          ctx.lineWidth = Math.max(2, Math.ceil(6 * maxPulse));\n          ctx.arc(ringX, ringY, ringRadius, 0, Math.PI * 2);\n          ctx.stroke();\n          ctx.restore();\n        }\n\n        if (totalAmount > 0) {\n          // floating +N to the right of influence number\n          const labelX = zone.x + zone.w - 12;\n          const labelY = zone.y + zone.h - 32 - (Math.random() * 6); // slight jitter\n          ctx.save();\n          ctx.fillStyle = '#2ecc71';\n          ctx.font = 'bold 16px sans-serif';\n          ctx.textAlign = 'left';\n          ctx.textBaseline = 'middle';\n          ctx.fillText(`+${totalAmount}`, labelX, labelY);\n          ctx.restore();\n        }\n      });\n    } catch (e) {\n      // ignore overlay errors\n    }\n\n    // --- Outline pass: draw a subtle, slightly pulsing 257x257 square around 256x256 slots ---\n    try {\n      const now2 = performance.now();\n      clickZonesRef.current.forEach((z, i) => {\n        if (!z) return;\n        const w = z.w || 0;\n        const h = z.h || 0;\n        // only target 256x256 slot-sized zones (covers the icons)\n        if (Math.abs(w - 256) > 0.1 || Math.abs(h - 256) > 0.1) return;\n        const x = z.x;\n        const y = z.y;\n\n        // Color palette (rgb)\n        const rgbTeal = '20,184,166';\n        const rgbBurg = '127,29,29';\n        const rgbPurple = '139,92,246';\n        const rgbYellow = '250,204,21';\n        const rgbOrange = '251,146,60';\n\n        // Determine slot semantic\n        let slotType: 'government' | 'public' | 'permanent' | 'instant' | 'intervention' | 'default' = 'default';\n        try {\n          const dt = z.data || {};\n          if (dt.slot && typeof dt.slot === 'string') {\n            if (dt.slot.includes('government')) slotType = 'government';\n            else if (dt.slot.includes('public')) slotType = 'public';\n            else if (dt.slot.includes('permanent')) slotType = 'permanent';\n            else if (dt.slot.includes('instant')) slotType = 'instant';\n          }\n          if (dt.type === 'row_slot' && dt.lane === 'aussen') slotType = 'government';\n          if (dt.type === 'row_slot' && dt.lane === 'innen') slotType = 'public';\n          if (dt.type === 'trap_p1' || dt.type === 'trap_p2' || (dt.card && dt.card.kind === 'trap')) slotType = 'intervention';\n          if (dt.type === 'activate_instant' || dt.slot === 'instant') slotType = 'instant';\n          if (dt.slot === 'permanent_government' || dt.slot === 'permanent_public' || dt.slot === 'permanent') slotType = 'permanent';\n        } catch (e) {}\n\n        const pulse = 0.5 + 0.5 * Math.sin(now2 / 350 + i);\n        const alpha = 0.06 + 0.12 * pulse; // subtle alpha\n        const lw = 1 + 2 * pulse; // line width between 1 and 3\n\n        // Create gradient based on slot type\n        let grad: CanvasGradient | null = null;\n        try {\n          grad = ctx.createLinearGradient(x, y, x + w, y + h);\n          if (slotType === 'government') {\n            grad.addColorStop(0, `rgba(${rgbTeal},1)`);\n            grad.addColorStop(1, `rgba(${rgbBurg},1)`);\n          } else if (slotType === 'public') {\n            grad.addColorStop(0, `rgba(${rgbBurg},1)`);\n            grad.addColorStop(1, `rgba(${rgbTeal},1)`);\n          } else if (slotType === 'permanent') {\n            grad.addColorStop(0, `rgba(${rgbPurple},1)`);\n            grad.addColorStop(1, `rgba(${rgbPurple},1)`);\n          } else if (slotType === 'instant') {\n            grad.addColorStop(0, `rgba(${rgbYellow},1)`);\n            grad.addColorStop(1, `rgba(${rgbYellow},1)`);\n          } else if (slotType === 'intervention') {\n            grad.addColorStop(0, `rgba(${rgbOrange},1)`);\n            grad.addColorStop(1, `rgba(${rgbOrange},1)`);\n          } else {\n            grad.addColorStop(0, `rgba(255,255,255,1)`);\n            grad.addColorStop(1, `rgba(255,255,255,1)`);\n          }\n        } catch (e) {\n          grad = null;\n        }\n\n        ctx.save();\n        if (grad) ctx.strokeStyle = grad as any;\n        else ctx.strokeStyle = `rgba(255,255,255,${alpha.toFixed(3)})`;\n        ctx.globalAlpha = alpha;\n        ctx.lineWidth = lw;\n        // draw 257x257 centered so that it encloses the 256 slot\n        ctx.strokeRect(x - 0.5, y - 0.5, w + 1, h + 1);\n        ctx.restore();\n      });\n    } catch (e) {\n      // ignore outline errors\n    }\n\n    ctx.restore();\n\n    // expose zones for debug snapshot\n    (window as any).__politicardDebug = {\n      uiTransform: getUiTransform(canvas.width, canvas.height),\n      canvasSize: { width: canvas.width, height: canvas.height },\n      zones: LAYOUT.zones,\n      clickZones: clickZonesRef.current.slice(0, 1000)\n    };\n\n    // Build canonical slotPositions map for animations/debugging\n    try {\n      const map: Record<string, { x: number; y: number; w: number; h: number; cx: number; cy: number }> = {};\n      clickZonesRef.current.forEach(z => {\n        const d = z.data || {};\n        // support row_slot, board_card, slot_card shapes\n        if (d.type === 'row_slot' || d.type === 'board_card' || d.type === 'slot_card' || d.type === 'hand_p1' || d.type === 'hand_p2') {\n          const player = d.player ?? (d.type === 'hand_p2' ? 2 : 1);\n          const lane = d.lane ?? (typeof d.slot === 'string' ? d.slot : (d.type === 'hand_p2' ? 'hand' : 'unknown'));\n          let index: number;\n          if (d.index != null) {\n            index = d.index;\n          } else if (d.card) {\n            // prefer explicit slotIndex, fallback to card.index, otherwise 0\n            index = (d.card.slotIndex != null) ? d.card.slotIndex : ((d.card.index != null) ? d.card.index : 0);\n          } else {\n            index = 0;\n          }\n          const key = `${player}.${lane}.${index}`;\n          map[key] = { x: z.x, y: z.y, w: z.w, h: z.h, cx: z.x + z.w / 2, cy: z.y + z.h / 2 };\n        }\n      });\n      slotPositionsRef.current = map;\n      (window as any).__politicardDebug = { ...(window as any).__politicardDebug, slotPositions: slotPositionsRef.current };\n    } catch (e) {\n      // don't let debug mapping break rendering\n    }\n\n    // Run diagnostics after canvas is fully rendered\n    runDiagnostics();\n  }, [drawLane, drawHandP1, drawHandP2, drawInterventionsP1, drawInterventionsP2, drawPermanentSlotsP1, drawPermanentSlotsP2, drawInstantSlots, drawInfoPanels, devMode, runDiagnostics]);\n\n  const DRAW_LAYOUT_OVERLAY = false; // force off per new layout system\n\n  // Load slot symbol images once\n  useEffect(() => {\n    const load = (key: string, src: string) => {\n      const img = new Image();\n      img.onload = () => { slotSymbolImgsRef.current.set(key, img); };\n      img.onerror = () => { console.warn('Failed to load slot icon', src); };\n      img.src = src;\n    };\n    // load all slot icons\n    load('public', publicSymbolUrl);\n    load('sofort', sofortSymbolUrl);\n    load('dauerhaft', dauerhaftSymbolUrl);\n    load('government', governmentSymbolUrl);\n    load('intervention', interventionSymbolUrl);\n\n    // load test GIF for gov overlay\n    try {\n      const img = new Image();\n      img.onload = () => { govGifRef.current = img; };\n      img.onerror = () => { console.warn('Failed to load gov overlay gif', govPlaceGifUrl); };\n      img.src = govPlaceGifUrl;\n    } catch (e) {}\n    // load spritesheet for placement animation\n    try {\n      const s = new Image();\n      s.onload = () => { govSpritesRef.current = s; };\n      s.onerror = () => { console.warn('Failed to load gov spritesheet', govPlaceSpritesheetUrl); };\n      s.src = govPlaceSpritesheetUrl;\n    } catch (e) {}\n    // load spritesheet for instant initiative activation\n    try {\n      const si = new Image();\n      si.onload = () => { instantSpritesRef.current = si; };\n      si.onerror = () => { console.warn('Failed to load instant spritesheet', instantSpritesheetUrl); };\n      si.src = instantSpritesheetUrl;\n    } catch (e) {}\n\n    // load spritesheet for hit/target animation (25 frames)\n    try {\n      const h = new Image();\n      h.onload = () => { hitSpritesRef.current = h; };\n      h.onerror = () => { console.warn('Failed to load hit spritesheet', hitSpritesheetUrl); };\n      h.src = hitSpritesheetUrl;\n    } catch (e) {}\n\n    // ensure first draw\n    requestAnimationFrame(draw);\n  }, [draw]);\n\n  // Expose debug trigger to manually start gov sprite animation by slot-key or uid\n  useEffect(() => {\n    (window as any).__pc_triggerGovAnim = (id: any) => {\n      try {\n        const now = performance.now();\n        // if id is slot key like '1.aussen.2'\n        if (typeof id === 'string' && id.indexOf('.') >= 0) {\n          govSpriteStateRef.current[id] = { started: now, frameCount: 14, frameDuration: 40 };\n          return;\n        }\n\n        // otherwise try to resolve as uid/id to a clickZone\n        const uid = id;\n        const zone = clickZonesRef.current.find(z => z.data && (z.data.card && ((z.data.card.uid ?? String(z.data.card.id)) === uid || (z.data.card.id === uid))));\n        if (!zone) {\n          console.warn('pc_triggerGovAnim: no slot found for uid', uid);\n          return;\n        }\n        const player = zone.data.player ?? 1;\n        const lane = zone.data.lane ?? (zone.data.slot && typeof zone.data.slot === 'string' ? zone.data.slot : 'aussen');\n        const index = zone.data.index ?? 0;\n        const key = `${player}.${lane}.${index}`;\n        govSpriteStateRef.current[key] = { started: now, frameCount: 14, frameDuration: 40 };\n      } catch (e) {\n        console.warn('pc_triggerGovAnim error', e);\n      }\n    };\n    // expose easy alias\n    try { (window as any).pc_triggerGovAnim = (window as any).__pc_triggerGovAnim; } catch (e) {}\n    return () => { delete (window as any).__pc_triggerGovAnim; };\n  }, []);\n\n  // Expose debug trigger for hit animation (key: '1.aussen.0' or uid)\n  useEffect(() => {\n    (window as any).__pc_triggerHitAnim = (id: any) => {\n      try {\n        const now = performance.now();\n        // if id is slot key like '1.aussen.2'\n        if (typeof id === 'string' && id.indexOf('.') >= 0) {\n          hitSpriteStateRef.current[id] = { started: now, frameCount: 25, frameDuration: 30 };\n          return;\n        }\n\n        // otherwise try to resolve as uid/id to a clickZone\n        const uid = id;\n        const zone = clickZonesRef.current.find(z => z.data && (z.data.card && ((z.data.card.uid ?? String(z.data.card.id)) === uid || (z.data.card.id === uid))));\n        if (!zone) {\n          console.warn('pc_triggerHitAnim: no slot found for uid', uid);\n          return;\n        }\n        const player = zone.data.player ?? 1;\n        const lane = zone.data.lane ?? (zone.data.slot && typeof zone.data.slot === 'string' ? zone.data.slot : 'aussen');\n        const index = zone.data.index ?? 0;\n        const key = `${player}.${lane}.${index}`;\n        hitSpriteStateRef.current[key] = { started: now, frameCount: 25, frameDuration: 30 };\n      } catch (e) {\n        console.warn('pc_triggerHitAnim error', e);\n      }\n    };\n    try { (window as any).pc_triggerHitAnim = (window as any).__pc_triggerHitAnim; } catch (e) {}\n    return () => { delete (window as any).__pc_triggerHitAnim; };\n  }, []);\n\n  // Redraw when game state or selection changes\n  useEffect(() => {\n    requestAnimationFrame(draw);\n  }, [gameState, selectedHandIndex, draw]);\n\n  // Continuous render loop to keep canvas updated without relying on external state refs\n  useEffect(() => {\n    let frame: number;\n    const loop = () => {\n      draw();\n      frame = requestAnimationFrame(loop);\n    };\n    frame = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(frame);\n  }, [draw]);\n\n  const handleCardClick = useCallback((data: any) => {\n    // Corruption target selection: intercept board card clicks for opponent government\n    if (corruptionSelectActorRef.current && data && data.type === 'board_card') {\n      try {\n        const actor = corruptionSelectActorRef.current as Player;\n        const victim = actor === 1 ? 2 : 1;\n        if (data.player === victim && (data.lane === 'aussen' || data.lane === 'government')) {\n          const uid = data.card?.uid ?? data.card?.id;\n          if (uid != null) {\n            corruptionSelectActorRef.current = null;\n            try { window.dispatchEvent(new CustomEvent('pc:corruption_target_selected', { detail: { player: actor, targetUid: uid } })); } catch (e) {}\n            return; // do not propagate\n          }\n        }\n      } catch (e) {}\n    }\n    // Hand-Klick\n    if (data.type === 'hand_p1') {\n      const uid = data.card?.uid ?? data.card?.id;\n      const stateHand = gameState.hands?.[1] || [];\n      const idxInState = stateHand.findIndex((c: any) => (c.uid ?? c.id) === uid);\n      onCardClick(data);\n      return;\n    }\n\n    // Slot-Klick\n    if (data.type === 'row_slot') {\n      const lane: 'public' | 'government' = data.lane;\n      const cap = getLaneCapacity(lane);\n\n      // Hole aktuelle Row-Länge aus gameState\n      const rowCards = lane === 'public'\n        ? gameState.board?.[1]?.innen ?? []\n        : gameState.board?.[1]?.aussen ?? [];\n\n      if (rowCards.length >= cap) {\n        // Optional: UI Feedback\n        console.warn(`Row ${lane} is full (${rowCards.length}/${cap})`);\n        return;\n      }\n\n      onCardClick(data);\n      return;\n    }\n\n    // Andere Klicks (empty_slot, board_card, etc.)\n    onCardClick(data);\n  }, [gameState, onCardClick]);\n\n  const handleClick = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const { scale, offsetX, offsetY } = getUiTransform(canvas.width, canvas.height);\n    const mx = (e.clientX - rect.left - offsetX) / scale;\n    const my = (e.clientY - rect.top - offsetY) / scale;\n\n    const hit = clickZonesRef.current.find(z => mx >= z.x && mx <= z.x + z.w && my >= z.y && my <= z.y + z.h);\n    if (hit) {\n      console.debug('[CanvasClick] mx,my,hit:', mx, my, hit.data);\n      try {\n        // If user clicked a drawn card in an instant slot, normalize to activate_instant\n        const d = hit.data || {};\n        if (d.type === 'slot_card' && d.slot === 'instant') {\n          handleCardClick({ type: 'activate_instant', player: d.player || 1, card: d.card });\n          return;\n        }\n        // Fallback: if there's an explicit activate_instant zone, pass through\n        if (d.type === 'activate_instant') {\n          handleCardClick(d);\n          return;\n        }\n      } catch (err) {}\n      handleCardClickInternal(hit.data);\n    }\n  }, [handleCardClick]);\n\n  const handleMouseMove = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const { scale, offsetX, offsetY } = getUiTransform(canvas.width, canvas.height);\n    const mx = (e.clientX - rect.left - offsetX) / scale;\n    const my = (e.clientY - rect.top - offsetY) / scale;\n\n    const hit = clickZonesRef.current.find(z => mx >= z.x && mx <= z.x + z.w && my >= z.y && my <= z.y + z.h);\n    if (hit) {\n      console.log('[hover]', hit.data.type, hit.data.card?.name);\n      onCardHover({ ...hit.data, x: e.clientX, y: e.clientY });\n    } else {\n      onCardHover(null);\n    }\n  }, [onCardHover]);\n\n  const handleWheel = useCallback((e: React.WheelEvent<HTMLCanvasElement>) => {\n    // only enable when player1 has more slots than visible\n    const handLen = (gameState.hands && gameState.hands[1]) ? gameState.hands[1].length : 0;\n    const zone = getZone('hand.player');\n    if (!zone) return;\n    if (handLen <= 5) return; // nothing to scroll\n\n    // Prevent page scrolling when over canvas\n    e.preventDefault();\n\n    // accumulate target offset (invert so wheel down moves cards up)\n    // Each wheel step moves by 48px per delta unit\n    const delta = Math.sign(e.deltaY) * 48;\n    // compute slot height more robustly\n    const slots = computeSlotRects(zone);\n    const slotH = slots && slots.length > 0 ? slots[0].h : zone.rectPx[3] / 5;\n    const visible = 5;\n    const maxOffset = -(Math.max(0, handLen - visible) * slotH);\n    handScrollTargetRef.current = Math.max(Math.min(handScrollTargetRef.current - delta, 0), maxOffset);\n  }, [gameState.hands]);\n\n  const handleTouchStart = useCallback((e: React.TouchEvent<HTMLCanvasElement>) => {\n    if (!e.touches || e.touches.length === 0) return;\n    const handLen = (gameState.hands && gameState.hands[1]) ? gameState.hands[1].length : 0;\n    if (handLen <= 5) return;\n    isTouchingRef.current = true;\n    const y = e.touches[0].clientY;\n    touchStartYRef.current = y;\n    lastTouchYRef.current = y;\n    e.preventDefault();\n  }, [gameState.hands]);\n\n  const handleTouchMove = useCallback((e: React.TouchEvent<HTMLCanvasElement>) => {\n    if (!isTouchingRef.current) return;\n    if (!e.touches || e.touches.length === 0) return;\n    const y = e.touches[0].clientY;\n    const last = lastTouchYRef.current ?? y;\n    const dy = y - last; // positive when moving down\n    lastTouchYRef.current = y;\n\n    // invert so dragging up moves cards up\n    const delta = -dy;\n    const handLen = (gameState.hands && gameState.hands[1]) ? gameState.hands[1].length : 0;\n    const zone = getZone('hand.player');\n    if (!zone) return;\n    const slots = computeSlotRects(zone);\n    const slotH = slots && slots.length > 0 ? slots[0].h : zone.rectPx[3] / 5;\n    const visible = 5;\n    const maxOffset = -(Math.max(0, handLen - visible) * slotH);\n    handScrollTargetRef.current = Math.max(Math.min(handScrollTargetRef.current + delta, 0), maxOffset);\n    e.preventDefault();\n  }, [gameState.hands]);\n\n  const handleTouchEnd = useCallback((e: React.TouchEvent<HTMLCanvasElement>) => {\n    isTouchingRef.current = false;\n    touchStartYRef.current = null;\n    lastTouchYRef.current = null;\n  }, []);\n\n\n\n  // Expose debug trigger to manually start instant sprite animation by slot-key or uid\n  useEffect(() => {\n    (window as any).__pc_triggerInstantAnim = (key: any) => {\n      const now = performance.now();\n      instantSpriteStateRef.current[key || '1.instant.0'] = { started: now, frameCount: 14, frameDuration: 40 };\n    };\n    // alias\n    try { (window as any).pc_triggerInstantAnim = (window as any).__pc_triggerInstantAnim; } catch (e) {}\n    return () => { delete (window as any).__pc_triggerGovAnim; delete (window as any).__pc_triggerInstantAnim; };\n  }, []);\n\n  // Click handler wrapper for corruption selection\n  const handleCardClickInternal = useCallback((data: any) => {\n    const sel: any = (gameState as any).pendingAbilitySelect;\n    if (sel && sel.type === 'corruption_steal') {\n      // Accept clicks on either actual card sprites (with uid) or on empty row_slot hitboxes.\n      if (data.player !== sel.actorPlayer && data.lane === 'aussen') {\n        let targetUid = (data as any).uid;\n\n        // If we got a row_slot hit (no uid), map index→uid from board state\n        if (!targetUid && data.type === 'row_slot') {\n          try {\n            const p = data.player;\n            const idx = data.index;\n            const card = (gameState as any).board?.[p]?.aussen?.[idx];\n            targetUid = card?.uid;\n          } catch(e) {}\n        }\n\n        if (targetUid) {\n          try {\n            console.debug('[CORR] forwarding uid', targetUid, 'actorPlayer=', sel.actorPlayer);\n            window.dispatchEvent(new CustomEvent('pc:corruption_pick_target', { detail: { player: sel.actorPlayer, targetUid } }));\n            // Also open small confirmation overlay via DOM event for modal convenience\n            try { window.dispatchEvent(new CustomEvent('pc:corruption_target_selected', { detail: { player: sel.actorPlayer, targetUid } })); } catch(e) {}\n          } catch(e) {}\n          return; // consume click\n        }\n      }\n    }\n    onCardClick(data);\n  }, [gameState, onCardClick]);\n\n  useEffect(() => {\n    const onDiceResult = () => {\n      // remove corruption modal if exists\n      const el = document.getElementById('pc-corruption-modal');\n      if (el) el.remove();\n      corruptionSelectActorRef.current = null;\n    };\n    window.addEventListener('pc:dice_result', onDiceResult as EventListener);\n    return () => window.removeEventListener('pc:dice_result', onDiceResult as EventListener);\n  }, []);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      width={1920}\n      height={1080}\n      style={{\n        display: 'block',\n        width: '100%',\n        height: '100%',\n        imageRendering: 'auto',\n      }}\n      onClick={handleClick}\n      onMouseMove={handleMouseMove}\n      onWheel={handleWheel}\n      onTouchStart={handleTouchStart}\n      onTouchMove={handleTouchMove}\n      onTouchEnd={handleTouchEnd}\n    />\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}