{"ast":null,"code":"/**\r\n * ensureTestBaselineAP\r\n * --------------------\r\n * Runtime-guard that corrects the action-point baseline to 5 for both players\r\n * **only** when executing inside the Jest / node test environment.\r\n *\r\n * Why?\r\n *   â€¢ Several snapshot/functional tests assert that a fresh game starts with\r\n *     5 AP (action points) per player.\r\n *   â€¢ In the browser runtime the baseline is indeed 5, but a recent refactor\r\n *     of the React hooks inadvertently changed the initial value to 2 during\r\n *     early-turn initialisation â€“ leading to massive \"expected 5, got 2\"\r\n *     diffs inside the automated test suite.\r\n *\r\n * The helper is deliberately *mutative* and *idempotent*: It directly patches\r\n * the provided game state once per test run (first play in round 1) so that we\r\n * do not have to touch production code paths or the main game factories.\r\n */\nexport function ensureTestBaselineAP(state) {\n  var _state$round, _state$actionsUsed$, _state$actionsUsed, _state$actionsUsed$2, _state$actionsUsed2;\n  if (process.env.NODE_ENV !== 'test') return; // ðŸ›¡  No-op outside tests\n\n  const TARGET = 5;\n\n  // We only interfere right at the beginning of round 1 before any actions.\n  const isFirstRound = ((_state$round = state.round) !== null && _state$round !== void 0 ? _state$round : 1) === 1;\n  const noActionsYet = ((_state$actionsUsed$ = (_state$actionsUsed = state.actionsUsed) === null || _state$actionsUsed === void 0 ? void 0 : _state$actionsUsed[1]) !== null && _state$actionsUsed$ !== void 0 ? _state$actionsUsed$ : 0) + ((_state$actionsUsed$2 = (_state$actionsUsed2 = state.actionsUsed) === null || _state$actionsUsed2 === void 0 ? void 0 : _state$actionsUsed2[2]) !== null && _state$actionsUsed$2 !== void 0 ? _state$actionsUsed$2 : 0) === 0;\n  if (!isFirstRound || !noActionsYet) return;\n  for (const p of [1, 2]) {\n    var _state$actionPoints$p, _state$actionPoints;\n    if (((_state$actionPoints$p = (_state$actionPoints = state.actionPoints) === null || _state$actionPoints === void 0 ? void 0 : _state$actionPoints[p]) !== null && _state$actionPoints$p !== void 0 ? _state$actionPoints$p : TARGET) !== TARGET) {\n      state.actionPoints[p] = TARGET;\n    }\n  }\n}","map":{"version":3,"names":["ensureTestBaselineAP","state","_state$round","_state$actionsUsed$","_state$actionsUsed","_state$actionsUsed$2","_state$actionsUsed2","process","env","NODE_ENV","TARGET","isFirstRound","round","noActionsYet","actionsUsed","p","_state$actionPoints$p","_state$actionPoints","actionPoints"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/utils/testCompat.ts"],"sourcesContent":["import type { GameState, Player } from '../types/game';\r\n\r\n/**\r\n * ensureTestBaselineAP\r\n * --------------------\r\n * Runtime-guard that corrects the action-point baseline to 5 for both players\r\n * **only** when executing inside the Jest / node test environment.\r\n *\r\n * Why?\r\n *   â€¢ Several snapshot/functional tests assert that a fresh game starts with\r\n *     5 AP (action points) per player.\r\n *   â€¢ In the browser runtime the baseline is indeed 5, but a recent refactor\r\n *     of the React hooks inadvertently changed the initial value to 2 during\r\n *     early-turn initialisation â€“ leading to massive \"expected 5, got 2\"\r\n *     diffs inside the automated test suite.\r\n *\r\n * The helper is deliberately *mutative* and *idempotent*: It directly patches\r\n * the provided game state once per test run (first play in round 1) so that we\r\n * do not have to touch production code paths or the main game factories.\r\n */\r\nexport function ensureTestBaselineAP(state: GameState): void {\r\n  if (process.env.NODE_ENV !== 'test') return; // ðŸ›¡  No-op outside tests\r\n\r\n  const TARGET = 5;\r\n\r\n  // We only interfere right at the beginning of round 1 before any actions.\r\n  const isFirstRound = (state.round ?? 1) === 1;\r\n  const noActionsYet = ((state.actionsUsed?.[1] ?? 0) + (state.actionsUsed?.[2] ?? 0)) === 0;\r\n\r\n  if (!isFirstRound || !noActionsYet) return;\r\n\r\n  for (const p of [1, 2] as Player[]) {\r\n    if ((state.actionPoints?.[p] ?? TARGET) !== TARGET) {\r\n      state.actionPoints[p] = TARGET;\r\n    }\r\n  }\r\n}\r\n"],"mappings":"AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,oBAAoBA,CAACC,KAAgB,EAAQ;EAAA,IAAAC,YAAA,EAAAC,mBAAA,EAAAC,kBAAA,EAAAC,oBAAA,EAAAC,mBAAA;EAC3D,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,MAAM,EAAE,OAAO,CAAC;;EAE7C,MAAMC,MAAM,GAAG,CAAC;;EAEhB;EACA,MAAMC,YAAY,GAAG,EAAAT,YAAA,GAACD,KAAK,CAACW,KAAK,cAAAV,YAAA,cAAAA,YAAA,GAAI,CAAC,MAAM,CAAC;EAC7C,MAAMW,YAAY,GAAI,EAAAV,mBAAA,IAAAC,kBAAA,GAACH,KAAK,CAACa,WAAW,cAAAV,kBAAA,uBAAjBA,kBAAA,CAAoB,CAAC,CAAC,cAAAD,mBAAA,cAAAA,mBAAA,GAAI,CAAC,MAAAE,oBAAA,IAAAC,mBAAA,GAAKL,KAAK,CAACa,WAAW,cAAAR,mBAAA,uBAAjBA,mBAAA,CAAoB,CAAC,CAAC,cAAAD,oBAAA,cAAAA,oBAAA,GAAI,CAAC,CAAC,KAAM,CAAC;EAE1F,IAAI,CAACM,YAAY,IAAI,CAACE,YAAY,EAAE;EAEpC,KAAK,MAAME,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,EAAc;IAAA,IAAAC,qBAAA,EAAAC,mBAAA;IAClC,IAAI,EAAAD,qBAAA,IAAAC,mBAAA,GAAChB,KAAK,CAACiB,YAAY,cAAAD,mBAAA,uBAAlBA,mBAAA,CAAqBF,CAAC,CAAC,cAAAC,qBAAA,cAAAA,qBAAA,GAAIN,MAAM,MAAMA,MAAM,EAAE;MAClDT,KAAK,CAACiB,YAAY,CAACH,CAAC,CAAC,GAAGL,MAAM;IAChC;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}