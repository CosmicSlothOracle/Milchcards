{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\skank\\\\Videos\\\\Cards\\\\Milchcards\\\\src\\\\components\\\\Dice3D.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useImperativeHandle, forwardRef } from 'react';\nimport * as THREE from 'three';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n/**\r\n * Dice3D – simple WebGL dice rendered with three.js\r\n * Usage:\r\n *   const diceRef = useRef<Dice3DHandle>(null);\r\n *   <Dice3D ref={diceRef} onRoll={(f)=>console.log(f)}/>\r\n *   diceRef.current?.roll();\r\n */\nconst Dice3D = /*#__PURE__*/_s(/*#__PURE__*/forwardRef(_c = _s(({\n  size = 180,\n  duration = 1200,\n  onRoll,\n  className\n}, ref) => {\n  _s();\n  const canvasRef = useRef(null);\n  const sceneRef = useRef();\n  const cubeRef = useRef();\n  const rendererRef = useRef();\n  const cameraRef = useRef();\n  const animIdRef = useRef(0);\n\n  /** helper to create a texture with pips */\n  const createFaceTexture = face => {\n    const size = 128;\n    const cvs = document.createElement('canvas');\n    cvs.width = cvs.height = size;\n    const ctx = cvs.getContext('2d');\n    ctx.fillStyle = '#fff';\n    ctx.fillRect(0, 0, size, size);\n    ctx.fillStyle = '#111';\n    const dot = (x, y) => {\n      ctx.beginPath();\n      ctx.arc(x, y, size * 0.1, 0, Math.PI * 2);\n      ctx.fill();\n    };\n    const g = size * 0.25;\n    const centers = {\n      1: [[size / 2, size / 2]],\n      2: [[g, g], [size - g, size - g]],\n      3: [[g, g], [size / 2, size / 2], [size - g, size - g]],\n      4: [[g, g], [size - g, g], [g, size - g], [size - g, size - g]],\n      5: [[g, g], [size - g, g], [size / 2, size / 2], [g, size - g], [size - g, size - g]],\n      6: [[g, g], [size - g, g], [g, size / 2], [size - g, size / 2], [g, size - g], [size - g, size - g]]\n    };\n    centers[face].forEach(([x, y]) => dot(x, y));\n    const tex = new THREE.CanvasTexture(cvs);\n    tex.needsUpdate = true;\n    return tex;\n  };\n\n  // initialize three scene\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x000000);\n    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);\n    camera.position.z = 4;\n    const renderer = new THREE.WebGLRenderer({\n      canvas,\n      antialias: true,\n      alpha: true\n    });\n    renderer.setSize(size, size);\n\n    // lights\n    const ambient = new THREE.AmbientLight(0xffffff, 0.8);\n    scene.add(ambient);\n    const dir = new THREE.DirectionalLight(0xffffff, 0.5);\n    dir.position.set(3, 5, 2);\n    scene.add(dir);\n\n    // cube\n    const materials = [1, 2, 3, 4, 5, 6].map(f => new THREE.MeshLambertMaterial({\n      map: createFaceTexture(f)\n    }));\n    const geometry = new THREE.BoxGeometry(2, 2, 2);\n    const cube = new THREE.Mesh(geometry, materials);\n    scene.add(cube);\n    sceneRef.current = scene;\n    cubeRef.current = cube;\n    rendererRef.current = renderer;\n    cameraRef.current = camera;\n\n    // animation loop\n    const animate = () => {\n      animIdRef.current = requestAnimationFrame(animate);\n      renderer.render(scene, camera);\n    };\n    animate();\n    return () => {\n      cancelAnimationFrame(animIdRef.current);\n      renderer.dispose();\n    };\n  }, [size]);\n\n  // roll logic\n  const rollInternal = targetFace => {\n    if (!cubeRef.current) return;\n    const cube = cubeRef.current;\n    // pick target if not provided\n    const face = targetFace !== null && targetFace !== void 0 ? targetFace : 1 + Math.floor(Math.random() * 6);\n\n    // orientation map: face -> Euler rotation (approx)\n    const orientations = {\n      1: [0, 0, 0],\n      2: [0, Math.PI / 2, 0],\n      3: [-Math.PI / 2, 0, 0],\n      4: [Math.PI / 2, 0, 0],\n      5: [0, -Math.PI / 2, 0],\n      6: [Math.PI, 0, 0]\n    };\n    const [tx, ty, tz] = orientations[face];\n    const start = {\n      x: cube.rotation.x,\n      y: cube.rotation.y,\n      z: cube.rotation.z\n    };\n    const end = {\n      x: tx + 2 * Math.PI,\n      y: ty + 2 * Math.PI,\n      z: tz + 2 * Math.PI\n    };\n    const startTime = performance.now();\n    const animate = () => {\n      const t = (performance.now() - startTime) / duration;\n      if (t >= 1) {\n        cube.rotation.set(tx, ty, tz);\n        if (onRoll) onRoll(face);\n        return;\n      }\n      // easeOutCubic\n      const k = 1 - Math.pow(1 - t, 3);\n      cube.rotation.set(start.x + (end.x - start.x) * k, start.y + (end.y - start.y) * k, start.z + (end.z - start.z) * k);\n      requestAnimationFrame(animate);\n    };\n    requestAnimationFrame(animate);\n  };\n  useImperativeHandle(ref, () => ({\n    roll: () => rollInternal(),\n    rollTo: face => rollInternal(Math.max(1, Math.min(6, face)))\n  }), [duration, onRoll]);\n\n  // click to roll\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const handler = () => rollInternal();\n    canvas.addEventListener('click', handler);\n    return () => canvas.removeEventListener('click', handler);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    width: size,\n    height: size,\n    className: className,\n    style: {\n      cursor: 'pointer'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 163,\n    columnNumber: 12\n  }, this);\n}, \"ly5rQgKhkC6yoCpgKv0PQVA/swM=\")), \"ly5rQgKhkC6yoCpgKv0PQVA/swM=\");\n_c2 = Dice3D;\nexport default Dice3D;\nvar _c, _c2;\n$RefreshReg$(_c, \"Dice3D$forwardRef\");\n$RefreshReg$(_c2, \"Dice3D\");","map":{"version":3,"names":["React","useEffect","useRef","useImperativeHandle","forwardRef","THREE","jsxDEV","_jsxDEV","Dice3D","_s","_c","size","duration","onRoll","className","ref","canvasRef","sceneRef","cubeRef","rendererRef","cameraRef","animIdRef","createFaceTexture","face","cvs","document","createElement","width","height","ctx","getContext","fillStyle","fillRect","dot","x","y","beginPath","arc","Math","PI","fill","g","centers","forEach","tex","CanvasTexture","needsUpdate","canvas","current","scene","Scene","background","Color","camera","PerspectiveCamera","position","z","renderer","WebGLRenderer","antialias","alpha","setSize","ambient","AmbientLight","add","dir","DirectionalLight","set","materials","map","f","MeshLambertMaterial","geometry","BoxGeometry","cube","Mesh","animate","requestAnimationFrame","render","cancelAnimationFrame","dispose","rollInternal","targetFace","floor","random","orientations","tx","ty","tz","start","rotation","end","startTime","performance","now","t","k","pow","roll","rollTo","max","min","handler","addEventListener","removeEventListener","style","cursor","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/components/Dice3D.tsx"],"sourcesContent":["import React, { useEffect, useRef, useImperativeHandle, forwardRef } from 'react';\r\nimport * as THREE from 'three';\r\n\r\nexport interface Dice3DProps {\r\n  /** pixel size of canvas */\r\n  size?: number;\r\n  /** roll animation duration in ms */\r\n  duration?: number;\r\n  /** callback when roll ends */\r\n  onRoll?: (face: number) => void;\r\n  className?: string;\r\n}\r\n\r\nexport interface Dice3DHandle {\r\n  roll: () => void;\r\n  rollTo: (face: number) => void;\r\n}\r\n\r\n/**\r\n * Dice3D – simple WebGL dice rendered with three.js\r\n * Usage:\r\n *   const diceRef = useRef<Dice3DHandle>(null);\r\n *   <Dice3D ref={diceRef} onRoll={(f)=>console.log(f)}/>\r\n *   diceRef.current?.roll();\r\n */\r\nconst Dice3D = forwardRef<Dice3DHandle, Dice3DProps>(\r\n  ({ size = 180, duration = 1200, onRoll, className }: Dice3DProps, ref) => {\r\n    const canvasRef = useRef<HTMLCanvasElement | null>(null);\r\n    const sceneRef = useRef<THREE.Scene>();\r\n    const cubeRef = useRef<THREE.Mesh>();\r\n    const rendererRef = useRef<THREE.WebGLRenderer>();\r\n    const cameraRef = useRef<THREE.PerspectiveCamera>();\r\n    const animIdRef = useRef(0);\r\n\r\n    /** helper to create a texture with pips */\r\n    const createFaceTexture = (face: number): THREE.Texture => {\r\n      const size = 128;\r\n      const cvs = document.createElement('canvas');\r\n      cvs.width = cvs.height = size;\r\n      const ctx = cvs.getContext('2d')!;\r\n      ctx.fillStyle = '#fff';\r\n      ctx.fillRect(0, 0, size, size);\r\n      ctx.fillStyle = '#111';\r\n\r\n      const dot = (x: number, y: number) => {\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, size * 0.1, 0, Math.PI * 2);\r\n        ctx.fill();\r\n      };\r\n      const g = size * 0.25;\r\n      const centers: Record<number, Array<[number, number]>> = {\r\n        1: [[size / 2, size / 2]],\r\n        2: [[g, g], [size - g, size - g]],\r\n        3: [[g, g], [size / 2, size / 2], [size - g, size - g]],\r\n        4: [[g, g], [size - g, g], [g, size - g], [size - g, size - g]],\r\n        5: [[g, g], [size - g, g], [size / 2, size / 2], [g, size - g], [size - g, size - g]],\r\n        6: [[g, g], [size - g, g], [g, size / 2], [size - g, size / 2], [g, size - g], [size - g, size - g]],\r\n      };\r\n      centers[face].forEach(([x, y]) => dot(x, y));\r\n      const tex = new THREE.CanvasTexture(cvs);\r\n      tex.needsUpdate = true;\r\n      return tex;\r\n    };\r\n\r\n    // initialize three scene\r\n    useEffect(() => {\r\n      const canvas = canvasRef.current;\r\n      if (!canvas) return;\r\n      const scene = new THREE.Scene();\r\n      scene.background = new THREE.Color(0x000000);\r\n      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);\r\n      camera.position.z = 4;\r\n      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });\r\n      renderer.setSize(size, size);\r\n\r\n      // lights\r\n      const ambient = new THREE.AmbientLight(0xffffff, 0.8);\r\n      scene.add(ambient);\r\n      const dir = new THREE.DirectionalLight(0xffffff, 0.5);\r\n      dir.position.set(3, 5, 2);\r\n      scene.add(dir);\r\n\r\n      // cube\r\n      const materials = [1, 2, 3, 4, 5, 6].map(f => new THREE.MeshLambertMaterial({ map: createFaceTexture(f) }));\r\n      const geometry = new THREE.BoxGeometry(2, 2, 2);\r\n      const cube = new THREE.Mesh(geometry, materials);\r\n      scene.add(cube);\r\n\r\n      sceneRef.current = scene;\r\n      cubeRef.current = cube;\r\n      rendererRef.current = renderer;\r\n      cameraRef.current = camera;\r\n\r\n      // animation loop\r\n      const animate = () => {\r\n        animIdRef.current = requestAnimationFrame(animate);\r\n        renderer.render(scene, camera);\r\n      };\r\n      animate();\r\n\r\n      return () => {\r\n        cancelAnimationFrame(animIdRef.current);\r\n        renderer.dispose();\r\n      };\r\n    }, [size]);\r\n\r\n    // roll logic\r\n    const rollInternal = (targetFace?: number) => {\r\n      if (!cubeRef.current) return;\r\n      const cube = cubeRef.current;\r\n      // pick target if not provided\r\n      const face = targetFace ?? (1 + Math.floor(Math.random() * 6));\r\n\r\n      // orientation map: face -> Euler rotation (approx)\r\n      const orientations: Record<number, [number, number, number]> = {\r\n        1: [0, 0, 0],\r\n        2: [0, Math.PI / 2, 0],\r\n        3: [-Math.PI / 2, 0, 0],\r\n        4: [Math.PI / 2, 0, 0],\r\n        5: [0, -Math.PI / 2, 0],\r\n        6: [Math.PI, 0, 0],\r\n      };\r\n      const [tx, ty, tz] = orientations[face];\r\n\r\n      const start = { x: cube.rotation.x, y: cube.rotation.y, z: cube.rotation.z };\r\n      const end = { x: tx + 2 * Math.PI, y: ty + 2 * Math.PI, z: tz + 2 * Math.PI };\r\n\r\n      const startTime = performance.now();\r\n\r\n      const animate = () => {\r\n        const t = (performance.now() - startTime) / duration;\r\n        if (t >= 1) {\r\n          cube.rotation.set(tx, ty, tz);\r\n          if (onRoll) onRoll(face);\r\n          return;\r\n        }\r\n        // easeOutCubic\r\n        const k = 1 - Math.pow(1 - t, 3);\r\n        cube.rotation.set(\r\n          start.x + (end.x - start.x) * k,\r\n          start.y + (end.y - start.y) * k,\r\n          start.z + (end.z - start.z) * k,\r\n        );\r\n        requestAnimationFrame(animate);\r\n      };\r\n      requestAnimationFrame(animate);\r\n    };\r\n\r\n    useImperativeHandle(ref, () => ({\r\n      roll: () => rollInternal(),\r\n      rollTo: (face: number) => rollInternal(Math.max(1, Math.min(6, face))),\r\n    }), [duration, onRoll]);\r\n\r\n    // click to roll\r\n    useEffect(() => {\r\n      const canvas = canvasRef.current;\r\n      if (!canvas) return;\r\n      const handler = () => rollInternal();\r\n      canvas.addEventListener('click', handler);\r\n      return () => canvas.removeEventListener('click', handler);\r\n    }, []);\r\n\r\n    return <canvas ref={canvasRef} width={size} height={size} className={className} style={{ cursor: 'pointer' }} />;\r\n  });\r\n\r\nexport default Dice3D;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}