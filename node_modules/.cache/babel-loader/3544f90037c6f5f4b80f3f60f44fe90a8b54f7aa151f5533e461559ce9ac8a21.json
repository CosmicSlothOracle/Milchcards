{"ast":null,"code":"// src/qte/atlasLoader.ts - simple runtime loader for TexturePacker JSON (ARRAY) format\n// The JSON layout we expect (TexturePacker \"JSON (Hash)\" or \"JSON (Array)\" works):\n// {\n//   \"frames\": {\n//      \"idle_0\": { \"frame\": {\"x\":0,\"y\":0,\"w\":256,\"h\":256}, ... },\n//      \"idle_1\": {...},\n//      \"walk_0\": {...}\n//   },\n//   \"meta\": { \"image\": \"atlas.png\" }\n// }\n// Each frame key is expected to be <state>_<index> (index starting at 0).\n// We group them into an array per state and keep the order of index.\nexport async function loadAtlas(basePath){// Expects `${basePath}/atlas.json` and `${basePath}/atlas.png`\nconst cacheBuster=Date.now();const jsonUrl=\"\".concat(basePath,\"/atlas.json?v=\").concat(cacheBuster);console.log(\"[atlas] Loading \".concat(jsonUrl));const res=await fetch(jsonUrl);if(!res.ok)throw new Error(\"Atlas JSON not found \".concat(jsonUrl,\" (status: \").concat(res.status,\")\"));const text=await res.text();console.log(\"[atlas] JSON response length: \".concat(text.length,\", starts with: \").concat(text.substring(0,100)));let data;try{data=JSON.parse(text);}catch(e){console.error(\"[atlas] JSON parse error:\",e);console.error(\"[atlas] Invalid JSON text:\",text.substring(0,200));throw e;}const framesData=data.frames;const meta=data.meta||{};const imgPath=\"\".concat(basePath,\"/\").concat(meta.image||'atlas.png',\"?v=\").concat(cacheBuster);console.log(\"[atlas] Loading image \".concat(imgPath));const image=await loadImage(imgPath);const stateMap={};for(const key in framesData){const state=key.replace(/_\\d+$/,\"\");const idxMatch=/_(\\d+)$/.exec(key);const idx=idxMatch?parseInt(idxMatch[1],10):0;if(!stateMap[state])stateMap[state]=[];const f=framesData[key].frame;stateMap[state][idx]={x:f.x,y:f.y,w:f.w,h:f.h};}// Determine frame size from first frame\nconst firstState=Object.keys(stateMap)[0];const firstFrame=firstState?stateMap[firstState][0]:{w:64,h:64};const animations={};for(const s of Object.keys(stateMap)){animations[s]={frames:stateMap[s],fps:12,loop:s!=='attack'&&s!=='parry'};}return{image,animations,frameW:firstFrame.w,frameH:firstFrame.h};}function loadImage(src){return new Promise((resolve,reject)=>{const img=new Image();img.onload=()=>resolve(img);img.onerror=reject;img.src=src;});}","map":{"version":3,"names":["loadAtlas","basePath","cacheBuster","Date","now","jsonUrl","concat","console","log","res","fetch","ok","Error","status","text","length","substring","data","JSON","parse","e","error","framesData","frames","meta","imgPath","image","loadImage","stateMap","key","state","replace","idxMatch","exec","idx","parseInt","f","frame","x","y","w","h","firstState","Object","keys","firstFrame","animations","s","fps","loop","frameW","frameH","src","Promise","resolve","reject","img","Image","onload","onerror"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/qte/atlasLoader.ts"],"sourcesContent":["// src/qte/atlasLoader.ts - simple runtime loader for TexturePacker JSON (ARRAY) format\n// The JSON layout we expect (TexturePacker \"JSON (Hash)\" or \"JSON (Array)\" works):\n// {\n//   \"frames\": {\n//      \"idle_0\": { \"frame\": {\"x\":0,\"y\":0,\"w\":256,\"h\":256}, ... },\n//      \"idle_1\": {...},\n//      \"walk_0\": {...}\n//   },\n//   \"meta\": { \"image\": \"atlas.png\" }\n// }\n// Each frame key is expected to be <state>_<index> (index starting at 0).\n// We group them into an array per state and keep the order of index.\n\nexport interface Rect { x: number; y: number; w: number; h: number }\nexport interface AtlasAnimation {\n  frames: Rect[];\n  fps: number;\n  loop: boolean;\n}\n\nexport interface LoadedAtlas {\n  image: HTMLImageElement;\n  animations: Record<string, AtlasAnimation>;\n  frameW: number;\n  frameH: number;\n}\n\nexport async function loadAtlas(basePath: string): Promise<LoadedAtlas> {\n  // Expects `${basePath}/atlas.json` and `${basePath}/atlas.png`\n  const cacheBuster = Date.now();\n  const jsonUrl = `${basePath}/atlas.json?v=${cacheBuster}`;\n  console.log(`[atlas] Loading ${jsonUrl}`);\n  const res = await fetch(jsonUrl);\n  if (!res.ok) throw new Error(`Atlas JSON not found ${jsonUrl} (status: ${res.status})`);\n\n  const text = await res.text();\n  console.log(`[atlas] JSON response length: ${text.length}, starts with: ${text.substring(0, 100)}`);\n\n  let data;\n  try {\n    data = JSON.parse(text);\n  } catch (e) {\n    console.error(`[atlas] JSON parse error:`, e);\n    console.error(`[atlas] Invalid JSON text:`, text.substring(0, 200));\n    throw e;\n  }\n  const framesData = data.frames;\n  const meta = data.meta || {};\n  const imgPath = `${basePath}/${meta.image || 'atlas.png'}?v=${cacheBuster}`;\n  console.log(`[atlas] Loading image ${imgPath}`);\n  const image = await loadImage(imgPath);\n\n  const stateMap: Record<string, Rect[]> = {};\n  for (const key in framesData) {\n    const state = key.replace(/_\\d+$/, \"\");\n    const idxMatch = /_(\\d+)$/.exec(key);\n    const idx = idxMatch ? parseInt(idxMatch[1], 10) : 0;\n    if (!stateMap[state]) stateMap[state] = [];\n    const f = framesData[key].frame as { x: number; y: number; w: number; h: number };\n    stateMap[state][idx] = { x: f.x, y: f.y, w: f.w, h: f.h };\n  }\n\n  // Determine frame size from first frame\n  const firstState = Object.keys(stateMap)[0];\n  const firstFrame = firstState ? stateMap[firstState][0] : { w: 64, h: 64 };\n\n  const animations: Record<string, AtlasAnimation> = {};\n  for (const s of Object.keys(stateMap)) {\n    animations[s] = { frames: stateMap[s], fps: 12, loop: s !== 'attack' && s !== 'parry' };\n  }\n\n  return { image, animations, frameW: firstFrame.w, frameH: firstFrame.h };\n}\n\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}