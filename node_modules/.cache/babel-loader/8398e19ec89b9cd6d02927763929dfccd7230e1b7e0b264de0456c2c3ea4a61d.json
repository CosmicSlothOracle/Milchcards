{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useCallback } from 'react';\nimport { createDefaultEffectFlags } from '../types/game';\nimport { buildDeckFromEntries, sumGovernmentInfluenceWithAuras } from '../utils/gameUtils';\nimport { PRESET_DECKS } from '../data/gameData';\nimport { getCardActionPointCost, getNetApCost, canPlayCard } from '../utils/ap';\nimport { triggerCardEffects } from '../effects/cards';\nimport { ensureTestBaselineAP } from '../utils/testCompat';\nimport { resolveQueue } from '../utils/queue';\nimport { applyStartOfTurnFlags } from '../utils/startOfTurnHooks';\nimport { registerTrap, applyTrapsOnCardPlayed } from '../utils/traps';\nimport { recomputeAuraFlags } from '../state/effects';\nimport { emptyBoard } from '../state/board';\n// Migration Helper f√ºr Queue-Vereinheitlichung\nconst migrateLegacyQueue = state => {\n  if (state._queue && state._queue.length > 0) {\n    if (!state._effectQueue) state._effectQueue = [];\n    state._effectQueue.push(...state._queue);\n    state._queue = [];\n  }\n};\n\n// Helper function for getting the other player\nconst other = p => p === 1 ? 2 : 1;\n\n// Hilfsfunktion: stellt sicher, dass effectFlags vorhanden sind\nconst ensureFlags = (s, p) => {\n  if (!s.effectFlags) {\n    s.effectFlags = {\n      1: createDefaultEffectFlags(),\n      2: createDefaultEffectFlags()\n    };\n  } else {\n    s.effectFlags[p] = {\n      ...createDefaultEffectFlags(),\n      ...s.effectFlags[p]\n    };\n  }\n};\n\n// Lane-Heuristik wie in playCard\nconst pickLane = c => {\n  const tag = c.tag;\n  if (c.kind === 'pol' && (tag === 'Staatsoberhaupt' || tag === 'Regierungschef' || tag === 'Diplomat')) return 'aussen';\n  return 'innen';\n};\nconst isCardPlayableNow = (state, player, card) => {\n  if (card.deactivated) return false;\n  if (card.kind === 'pol') {\n    const lane = pickLane(card);\n    return state.board[player][lane].length < 5;\n  }\n  if (card.kind === 'spec') {\n    const t = String(card.type || '').toLowerCase();\n    if (t === '√∂ffentlichkeitskarte' || t === 'oeffentlichkeitskarte' || t === 'public') {\n      return state.board[player].innen.length < 5;\n    }\n    if (t === 'dauerhaft-initiative') {\n      const slot = 'government'; // wie bei dir ‚Äûsimplified\"\n      return !state.permanentSlots[player][slot];\n    }\n    // sonst: Fallen/Interventionen ‚Äì aktuell immer erlaubt\n    return true;\n  }\n  return false;\n};\nexport const hasPlayableZeroCost = (state, player) => {\n  for (const c of state.hands[player]) {\n    const {\n      cost\n    } = getCardActionPointCost(state, player, c);\n    if (cost === 0 && isCardPlayableNow(state, player, c)) return true;\n  }\n  return false;\n};\n\n// Helper function to apply auras for a player (instant updates for Joschka Fischer + NGO synergy)\nfunction applyAurasForPlayer(state, player, log) {\n  const board = state.board[player];\n  const hasNgo = board.innen.some(c => c.kind === 'spec' && c.type === '√ñffentlichkeitskarte' && c.tag === 'NGO' && !c.deactivated);\n  const newAussen = board.aussen.map(card => {\n    if (card.kind !== 'pol') return card;\n    const pol = {\n      ...card\n    };\n    if (pol.baseInfluence == null) pol.baseInfluence = pol.influence;\n    const prev = pol.influence;\n    let bonus = 0;\n    if (!pol.deactivated && pol.name === 'Joschka Fischer' && pol.effect === 'ngo_boost' && hasNgo) {\n      bonus += 1;\n    }\n    pol.influence = pol.baseInfluence + bonus;\n    if (log && pol.influence > prev) log(`PASSIV: ${pol.name} +${pol.influence - prev} I (jetzt ${pol.influence}).`);\n    return pol;\n  });\n  state.board = {\n    ...state.board,\n    [player]: {\n      ...state.board[player],\n      aussen: newAussen\n    }\n  };\n}\n\n// Helper function to check if round should end\nfunction checkRoundEnd(gameState) {\n  // Round ends if both players have passed\n  const result = gameState.passed[1] && gameState.passed[2];\n  console.log(`üîß DEBUG: checkRoundEnd - P1 passed: ${gameState.passed[1]}, P2 passed: ${gameState.passed[2]}, result: ${result}`);\n  return result;\n}\n\n// Helper function to draw cards from deck\nfunction drawCardsFromDeck(gameState, player, count) {\n  const deck = [...gameState.decks[player]];\n  const drawnCards = deck.splice(0, Math.min(count, deck.length));\n  return drawnCards;\n}\n\n// Helper function to really end a turn (extracted from nextTurn logic)\nfunction reallyEndTurn(gameState, log) {\n  const current = gameState.current;\n\n  // Flag zur√ºcksetzen - Zug-Ende wird jetzt wirklich durchgef√ºhrt\n  gameState.isEndingTurn = false;\n\n  // ‚úÖ Karte nachziehen am Ende eines Zugs (nur wenn NICHT \"pass\")\n  if (!gameState.passed[current]) {\n    const drawnCard = gameState.decks[current].shift();\n    if (drawnCard) {\n      gameState.hands[current].push(drawnCard);\n      log(`üî• Zug-Ende: +1 Karte gezogen (${drawnCard.name})`);\n    }\n  } else {\n    log(`‚è≠Ô∏è P${current} hat gepasst ‚Äì kein Nachziehen.`);\n  }\n\n  // Check if round should end\n  const shouldEndRound = checkRoundEnd(gameState);\n  if (shouldEndRound) {\n    log(`üèÅ Runde ${gameState.round} wird beendet (Zug-Ende).`);\n    return resolveRound(gameState, log);\n  }\n\n  // Spielerwechsel + AP reset\n  const newCurrent = current === 1 ? 2 : 1;\n  gameState.current = newCurrent;\n  gameState.actionPoints = {\n    ...gameState.actionPoints,\n    [newCurrent]: 2\n  };\n  gameState.passed = {\n    ...gameState.passed,\n    [newCurrent]: false\n  };\n\n  // Apply new start-of-turn hooks\n  applyStartOfTurnFlags(gameState, newCurrent, log);\n\n  // üî• CLUSTER 3: Auren-Flags beim Zugstart neu berechnen\n  recomputeAuraFlags(gameState);\n\n  // Reset turn-bezogener Flag-Nutzungen (handled in applyStartOfTurnFlags)\n\n  log(`üîÑ Zug-Ende: Spieler ${newCurrent} ist am Zug (2 AP verf√ºgbar)`);\n  return gameState;\n}\n\n// Helper function to resolve round and start new one\nfunction resolveRound(gameState, log) {\n  // Calculate influence for both players\n  const p1Influence = sumGovernmentInfluenceWithAuras(gameState, 1);\n  const p2Influence = sumGovernmentInfluenceWithAuras(gameState, 2);\n  log(`üìä Rundenauswertung: P1 ${p1Influence} Einfluss vs P2 ${p2Influence} Einfluss`);\n\n  // Determine winner\n  let roundWinner;\n  if (p1Influence > p2Influence) {\n    roundWinner = 1;\n    log(`üèÜ Spieler 1 gewinnt die Runde! (${p1Influence} > ${p2Influence})`);\n  } else if (p2Influence > p1Influence) {\n    roundWinner = 2;\n    log(`üèÜ Spieler 2 gewinnt die Runde! (${p2Influence} > ${p1Influence})`);\n  } else {\n    // Tie - current player wins\n    roundWinner = gameState.current;\n    log(`ü§ù Unentschieden! Spieler ${roundWinner} gewinnt als aktiver Spieler.`);\n  }\n\n  // Collect all cards to move to discard\n  const cardsToDiscard = [...gameState.board[1].innen, ...gameState.board[1].aussen, ...gameState.board[2].innen, ...gameState.board[2].aussen, ...(gameState.permanentSlots[1].government ? [gameState.permanentSlots[1].government] : []), ...(gameState.permanentSlots[1].public ? [gameState.permanentSlots[1].public] : []), ...(gameState.permanentSlots[2].government ? [gameState.permanentSlots[2].government] : []), ...(gameState.permanentSlots[2].public ? [gameState.permanentSlots[2].public] : []), ...gameState.board[1].sofort, ...gameState.board[2].sofort];\n\n  // Draw 5 new cards for each player\n  const newP1Hand = drawCardsFromDeck(gameState, 1, 5);\n  const newP2Hand = drawCardsFromDeck(gameState, 2, 5);\n\n  // Calculate new rounds won\n  const newRoundsWon = {\n    ...gameState.roundsWon,\n    [roundWinner]: gameState.roundsWon[roundWinner] + 1\n  };\n\n  // Check if game should end (Best of 3: first to 2 wins)\n  const p1Wins = newRoundsWon[1];\n  const p2Wins = newRoundsWon[2];\n  if (p1Wins >= 2 || p2Wins >= 2) {\n    const gameWinner = p1Wins >= 2 ? 1 : 2;\n    log(`üèÜüéâ SPIEL BEENDET! Spieler ${gameWinner} gewinnt das Match! (${p1Wins}-${p2Wins})`);\n    log(`üî• Gesamtergebnis: Player ${gameWinner} ist der Sieger!`);\n\n    // Return final state with game winner\n    return {\n      ...gameState,\n      roundsWon: newRoundsWon,\n      gameWinner,\n      // Keep current board state for final display\n      passed: {\n        1: true,\n        2: true\n      } // Both passed to indicate game end\n    };\n  }\n\n  // Create new state for next round\n  const newState = {\n    ...gameState,\n    round: gameState.round + 1,\n    current: roundWinner,\n    // Winner starts next round\n    passed: {\n      1: false,\n      2: false\n    },\n    // Reset pass status\n    actionPoints: {\n      1: 2,\n      2: 2\n    },\n    // Reset AP\n    actionsUsed: {\n      1: 0,\n      2: 0\n    },\n    // Reset actions (kept for compatibility)\n    roundsWon: newRoundsWon,\n    effectFlags: {\n      1: createDefaultEffectFlags(),\n      2: createDefaultEffectFlags()\n    },\n    // Clear all board positions\n    board: emptyBoard(),\n    // Clear permanent slots\n    permanentSlots: {\n      1: {\n        government: null,\n        public: null,\n        initiativePermanent: null\n      },\n      2: {\n        government: null,\n        public: null,\n        initiativePermanent: null\n      }\n    },\n    // instantSlot wird nicht mehr verwendet - Sofort-Initiativen gehen in board[player].sofort\n    // New hands with 5 cards each\n    hands: {\n      1: newP1Hand,\n      2: newP2Hand\n    },\n    // Update decks (cards were removed during drawing)\n    decks: {\n      1: gameState.decks[1].slice(newP1Hand.length),\n      2: gameState.decks[2].slice(newP2Hand.length)\n    },\n    // Update discard pile\n    discard: [...gameState.discard, ...cardsToDiscard]\n  };\n  log(`üÜï Runde ${newState.round} startet! Spieler ${roundWinner} beginnt. (Rundenstand: P1 ${newState.roundsWon[1]} - P2 ${newState.roundsWon[2]})`);\n  log(`üÉè Beide Spieler erhalten 5 neue Handkarten.`);\n  return newState;\n}\nexport function useGameActions(gameState, setGameState, log, afterQueueResolved) {\n  _s();\n  const startMatchWithDecks = useCallback((p1DeckEntries, p2DeckEntries) => {\n    const p1Cards = buildDeckFromEntries(p1DeckEntries);\n    const p2Cards = buildDeckFromEntries(p2DeckEntries);\n\n    // Debug: Log deck composition with detailed tag analysis\n    const p1NgoCarten = p1Cards.filter(c => c.tag === 'NGO');\n    const p1PlatformCards = p1Cards.filter(c => c.tag === 'Plattform');\n    const p1JoschaCards = p1Cards.filter(c => c.effect === 'ngo_boost');\n    const p1PublicCards = p1Cards.filter(c => c.kind === 'spec' && c.type === '√ñffentlichkeitskarte');\n    log(`üîç DECK DEBUG P1: ${p1Cards.length} Karten total`);\n    log(`üß™ P1 Public Cards: ${p1PublicCards.map(c => `${c.name}${c.tag ? `[${c.tag}]` : ''}`).join(', ')}`);\n    log(`üå± P1 NGO-Karten: ${p1NgoCarten.length > 0 ? p1NgoCarten.map(c => c.name).join(', ') : 'Keine'}`);\n    log(`üíª P1 Plattform-Karten: ${p1PlatformCards.length > 0 ? p1PlatformCards.map(c => c.name).join(', ') : 'Keine'}`);\n    log(`üéØ JOSCHKA FISCHER: ${p1JoschaCards.length > 0 ? '‚úÖ IM DECK' : '‚ùå NICHT IM DECK'}`);\n    const d1 = [...p1Cards];\n    const d2 = [...p2Cards];\n    const h1 = d1.splice(0, Math.min(5, d1.length));\n    const h2 = d2.splice(0, Math.min(5, d2.length));\n    setGameState({\n      ...gameState,\n      round: 1,\n      current: 1,\n      passed: {\n        1: false,\n        2: false\n      },\n      decks: {\n        1: d1,\n        2: d2\n      },\n      hands: {\n        1: h1,\n        2: h2\n      },\n      board: {\n        1: {\n          innen: [],\n          aussen: [],\n          sofort: []\n        },\n        2: {\n          innen: [],\n          aussen: [],\n          sofort: []\n        }\n      },\n      traps: {\n        1: [],\n        2: []\n      },\n      permanentSlots: {\n        1: {\n          government: null,\n          public: null,\n          initiativePermanent: null\n        },\n        2: {\n          government: null,\n          public: null,\n          initiativePermanent: null\n        }\n      },\n      // instantSlot wird nicht mehr verwendet - Sofort-Initiativen gehen in board[player].sofort\n      discard: [],\n      shields: new Set(),\n      // Set<UID>\n      effectFlags: {\n        1: createDefaultEffectFlags(),\n        2: createDefaultEffectFlags()\n      },\n      actionsUsed: {\n        1: 0,\n        2: 0\n      },\n      log: [`Match gestartet. P1 und P2 erhalten je ${h1.length}/${h2.length} Startkarten.`, `üîç DECK DEBUG P1: ${p1Cards.length} Karten total`, `üß™ P1 Public Cards: ${p1PublicCards.map(c => `${c.name}${c.tag ? `[${c.tag}]` : ''}`).join(', ')}`, `üå± P1 NGO-Karten: ${p1NgoCarten.length > 0 ? p1NgoCarten.map(c => c.name).join(', ') : 'Keine'}`, `üíª P1 Plattform-Karten: ${p1PlatformCards.length > 0 ? p1PlatformCards.map(c => c.name).join(', ') : 'Keine'}`, `üéØ JOSCHKA FISCHER: ${p1JoschaCards.length > 0 ? '‚úÖ IM DECK' : '‚ùå NICHT IM DECK'}`, `üìã INITIAL BOARD P1: Regierung=[] | √ñffentlichkeit=[]`, `üìã INITIAL BOARD P2: Regierung=[] | √ñffentlichkeit=[]`, `üè† PERMANENT SLOTS: Alle leer`],\n      activeRefresh: {\n        1: 0,\n        2: 0\n      }\n    });\n  }, [gameState, setGameState, log]);\n  const startMatchVsAI = useCallback((p1DeckEntries, presetKey = 'AUTORITAERER_REALIST') => {\n    const p2DeckEntries = PRESET_DECKS[presetKey];\n    startMatchWithDecks(p1DeckEntries, p2DeckEntries);\n  }, [startMatchWithDecks]);\n  const playCard = useCallback((player, handIndex, lane) => {\n    setGameState(prev => {\n      // Test-only baseline fix ‚Äì ensures AP=5 at game start inside test runner\n      ensureTestBaselineAP(prev);\n\n      // Validate input parameters\n      if (prev.current !== player) {\n        log(`‚ùå ERROR: Not player turn - Current: ${prev.current}, Attempted: ${player}`);\n        return prev;\n      }\n      const hand = prev.hands[player];\n      if (handIndex < 0 || handIndex >= hand.length) {\n        log(`‚ùå ERROR: Invalid hand index - Index: ${handIndex}, Hand length: ${hand.length}`);\n        return prev;\n      }\n\n      // Debug: Log current hand contents with detailed tag info\n      log(`üîç HAND DEBUG P${player}: ${hand.map((c, i) => `${i}:${c.name}${c.tag ? `[${c.tag}]` : ''}`).join(', ')}`);\n      const ngoCards = hand.filter(c => c.tag === 'NGO');\n      const platformCards = hand.filter(c => c.tag === 'Plattform');\n      if (ngoCards.length > 0) {\n        log(`üå± NGO-Karten in Hand P${player}: ${ngoCards.map(c => c.name).join(', ')}`);\n      }\n      if (platformCards.length > 0) {\n        log(`üíª Plattform-Karten in Hand P${player}: ${platformCards.map(c => c.name).join(', ')}`);\n      }\n      const selectedCard = hand[handIndex];\n      if (!canPlayCard(prev, player, selectedCard)) {\n        log('üö´ Kann Karte nicht spielen (keine AP verf√ºgbar).');\n        return prev;\n      }\n      const {\n        cost\n      } = getNetApCost(prev, player, selectedCard);\n      const prevAp = prev.actionPoints[player];\n      const newState = {\n        ...prev\n      };\n\n      // Simplified AP system: All cards cost exactly 1 AP\n      newState.actionPoints[player] = Math.max(0, newState.actionPoints[player] - cost);\n      log(`üí≥ Kosten verbucht: AP ${prevAp}‚Üí${newState.actionPoints[player]}`);\n\n      // Flags KONSUMIEREN (einheitlich, NUR HIER!)\n      ensureFlags(newState, player);\n      const ef = newState.effectFlags[player];\n\n      // Simplified AP system: No refunds or discounts\n      // All cards cost exactly 1 AP\n\n      // Remove card from hand\n      const newHand = [...newState.hands[player]];\n      const [playedCard] = newHand.splice(handIndex, 1);\n      newState.hands = {\n        ...newState.hands,\n        [player]: newHand\n      };\n\n      // üîß CLUSTER 3 DEBUG: Zeige jede gespielte Karte\n      log(`üîß CLUSTER 3 GLOBAL DEBUG: P${player} spielt ${playedCard.name} (${playedCard.kind}) - Type: ${playedCard.type || 'KEIN TYPE'}`);\n\n      // üîß CLUSTER 3 DEBUG: Zeige aktuelles Board\n      const currentBoard = newState.board[player];\n      const publicCardsOnBoard = currentBoard.innen.filter(card => card.kind === 'spec');\n      log(`üîß CLUSTER 3 GLOBAL DEBUG: √ñffentlichkeitskarten auf dem Feld: ${publicCardsOnBoard.map(c => c.name).join(', ')}`);\n\n      // Jennifer Doudna check removed - not needed for current game logic\n\n      // Handle different card types\n      if (playedCard.kind === 'pol') {\n        const polCard = playedCard;\n        const targetLane = lane || (polCard.tag === 'Staatsoberhaupt' || polCard.tag === 'Regierungschef' || polCard.tag === 'Diplomat' ? 'aussen' : 'innen');\n        if (newState.board[player][targetLane].length >= 5) {\n          log(`‚ùå ERROR: Lane full - Lane: ${targetLane}, Current: ${newState.board[player][targetLane].length}/5`);\n          return prev;\n        }\n\n        // Add to board (immutable clone to avoid accidental double references)\n        const laneArray = [...newState.board[player][targetLane], playedCard];\n        const playerBoardCloned = {\n          ...newState.board[player],\n          [targetLane]: laneArray\n        };\n        newState.board = {\n          ...newState.board,\n          [player]: playerBoardCloned\n        };\n        log(`üÉè Player ${player}: ${playedCard.name} gespielt in ${targetLane === 'aussen' ? 'Regierung' : '√ñffentlichkeit'}`);\n\n        // 3) Nachdem die Karte gelegt wurde: gegnerische Traps pr√ºfen\n        applyTrapsOnCardPlayed(newState, player, playedCard, event => {\n          if (!newState._effectQueue) newState._effectQueue = [];\n          newState._effectQueue.push(event);\n        }, log);\n\n        // üëâ Erst JETZT Auren anwenden (damit +2 Basis erhalten bleibt)\n        applyAurasForPlayer(newState, player, log);\n\n        // 6) Karteneffekte enqueuen + Queue aufl√∂sen\n        triggerCardEffects(newState, player, playedCard);\n        // Migration Helper verwenden\n        migrateLegacyQueue(newState);\n        // Nur noch _effectQueue verwenden\n        if (newState._effectQueue && newState._effectQueue.length > 0) {\n          resolveQueue(newState, newState._effectQueue);\n          newState._effectQueue = [];\n          // Nach Queue-Aufl√∂sung: Hand-Arrays immutabel neu zuweisen\n          afterQueueResolved === null || afterQueueResolved === void 0 ? void 0 : afterQueueResolved();\n        }\n\n        // Check for trap triggers\n        applyTrapsOnCardPlayed(newState, player, playedCard, e => (newState._effectQueue ??= []).push(e), m => (newState._effectQueue ??= []).push({\n          type: 'LOG',\n          msg: m\n        }));\n\n        // üî• ROMAN ABRAMOVICH EFFEKT: Wenn Regierungskarte mit Einfluss ‚â§5 gespielt wird\n        if (playedCard.kind === 'pol' && playedCard.influence <= 5) {\n          const opponent = player === 1 ? 2 : 1;\n          const opponentBoard = newState.board[opponent];\n          const romanAbramovich = opponentBoard.innen.find(card => card.kind === 'spec' && card.name === 'Roman Abramovich');\n          if (romanAbramovich) {\n            // Ziehe eine Karte f√ºr den Gegner\n            if (newState.decks[opponent].length > 0) {\n              const drawnCard = newState.decks[opponent].shift();\n              if (drawnCard) {\n                newState.hands[opponent].push(drawnCard);\n                log(`üî• ROMAN ABRAMOVICH EFFEKT: P${opponent} zieht 1 Karte (${drawnCard.name}) - Regierungskarte mit Einfluss ‚â§5 gespielt`);\n              }\n            }\n          }\n        }\n\n        // üîç BOARD DEBUG: Zeige aktuelles Board nach dem Spielen\n        const currentBoard = newState.board[player];\n        const regierungKarten = currentBoard.aussen.map(c => `${c.name}[${c.kind === 'pol' ? c.influence + 'I' : 'S'}]`);\n        const √∂ffentlichkeitKarten = currentBoard.innen.map(c => `${c.name}[${c.kind === 'spec' ? c.tag || 'S' : 'P'}]`);\n        log(`üìã P${player} BOARD: Regierung=[${regierungKarten.join(', ')}] | √ñffentlichkeit=[${√∂ffentlichkeitKarten.join(', ')}]`);\n\n        // üî• JOSCHKA FISCHER NGO-EFFEKT: Jetzt als kontinuierlicher Aura-Effekt in sumRowWithAuras implementiert\n        log(`üîç DEBUG: Karte gespielt - Name: ${playedCard.name}, Tag: ${playedCard.tag || 'Kein Tag'}, Lane: ${targetLane}, Kind: ${playedCard.kind}`);\n        if (playedCard.tag === 'NGO') {\n          log(`üîç NGO-Karte gespielt: ${playedCard.name} [NGO] - Kontinuierliche Aura-Effekte werden bei Rundenauswertung berechnet`);\n\n          // üéØ SOFORTIGE SYNERGIE-PR√úFUNG: Joschka Fischer + NGO\n          const joschaFischer = currentBoard.aussen.find(card => card.kind === 'pol' && card.effect === 'ngo_boost');\n          if (joschaFischer) {\n            log(`üî•üî•üî• SYNERGIE AKTIVIERT! üî•üî•üî• Joschka Fischer + ${playedCard.name}[NGO] ‚Üí +1 Einfluss bei Rundenauswertung`);\n          }\n        }\n      } else if (playedCard.kind === 'spec') {\n        var _type, _type2;\n        const specCard = playedCard;\n        const typeStr = String(specCard.type || '').toLowerCase();\n        const isInitiative = /initiative/.test(typeStr); // matcht \"Initiative\", \"Sofort-Initiative\", etc.\n\n        // 1) Falls es eine \"Systemrelevant\" ist (sofortiger Buff auf letzte eigene Regierungskarte)\n        if (playedCard.kind === 'spec' && (_type = playedCard.type) !== null && _type !== void 0 && _type.toLowerCase().includes('systemrelevant')) {\n          const ownBoard = newState.board[player];\n          const candidates = [...ownBoard.aussen, ...ownBoard.innen].filter(c => c.kind === 'pol');\n          const target = candidates[candidates.length - 1]; // letzte eigene Regierungskarte\n          if (target) {\n            target.protected = true;\n            log(`üõ°Ô∏è ${target.name} erh√§lt einmaligen Schutz.`);\n          } else {\n            log('üõà Systemrelevant: Keine eigene Regierungskarte im Spiel ‚Äì Effekt verpufft.');\n          }\n          // danach die Spezialkarte normal entsorgen\n          newState.discard.push(playedCard);\n          return newState;\n        }\n\n        // 1) Dauerhaft-Initiative (Ongoing)\n        if (typeStr.includes('dauerhaft')) {\n          // Slot-Mapping: Dauerhaft-Initiativen ‚Üí initiativePermanent, nicht government\n          const slotType = 'initiativePermanent';\n          if (!newState.permanentSlots[player][slotType]) {\n            newState.permanentSlots[player][slotType] = playedCard;\n            log(`P${player} spielt ${playedCard.name} als Dauerhafte Initiative (Slot: ${slotType})`);\n          } else {\n            var _newState$permanentSl;\n            log(`‚ö†Ô∏è WARN: Slot occupied - Slot ${slotType} already has ${(_newState$permanentSl = newState.permanentSlots[player][slotType]) === null || _newState$permanentSl === void 0 ? void 0 : _newState$permanentSl.name}`);\n          }\n\n          // 6) Karteneffekte enqueuen + Queue aufl√∂sen\n          triggerCardEffects(newState, player, playedCard);\n          // Migration Helper verwenden\n          migrateLegacyQueue(newState);\n          // Nur noch _effectQueue verwenden\n          if (newState._effectQueue && newState._effectQueue.length > 0) {\n            resolveQueue(newState, newState._effectQueue);\n            newState._effectQueue = [];\n            // Nach Queue-Aufl√∂sung: Hand-Arrays immutabel neu zuweisen\n            afterQueueResolved === null || afterQueueResolved === void 0 ? void 0 : afterQueueResolved();\n          }\n\n          // Check for trap triggers\n          applyTrapsOnCardPlayed(newState, player, playedCard, e => (newState._effectQueue ??= []).push(e), m => (newState._effectQueue ??= []).push({\n            type: 'LOG',\n            msg: m\n          }));\n          return newState;\n        }\n\n        // 2) Sofort-/Sofort-Initiativen (Instant)\n        if (isInitiative) {\n          var _newState$effectFlags;\n          if (!specCard.effectKey) {\n            log(`‚ùå Initiative ohne effectKey: ${specCard.name}`);\n          } else {\n            log(`üß© INIT: ${specCard.name} [${String(specCard.effectKey)}] gespielt`);\n          }\n\n          // üîß NEU: Sofort-Initiativen werden in das sofort Array gelegt statt sofort aktiviert\n          if (typeStr.includes('sofort')) {\n            // Pr√ºfe ob bereits eine Sofort-Initiative im Slot liegt\n            if (newState.board[player].sofort.length > 0) {\n              var _newState$board$playe;\n              log(`‚ùå ERROR: Sofort-Initiative-Slot bereits besetzt - ${(_newState$board$playe = newState.board[player].sofort[0]) === null || _newState$board$playe === void 0 ? void 0 : _newState$board$playe.name} muss erst aktiviert werden`);\n              // Karte zur√ºck in die Hand\n              newState.hands[player] = [...newState.hands[player], playedCard];\n              // AP zur√ºckgeben\n              newState.actionPoints[player] += cost;\n              // AP zur√ºckgegeben, keine Aktion r√ºckg√§ngig zu machen\n              return newState;\n            }\n\n            // Sofort-Initiative in das sofort Array legen\n            newState.board[player].sofort = [playedCard];\n            log(`üéØ P${player} legt ${playedCard.name} in Sofort-Initiative-Slot (kann sp√§ter aktiviert werden)`);\n\n            // Sofort-Initiativen: auf Board.sofort legen (nicht direkt entsorgen)\n            if (!newState._effectQueue) newState._effectQueue = [];\n            newState._effectQueue.push({\n              type: 'LOG',\n              msg: `üîî Sofort-Initiative bereit: ${playedCard.name} (zum Aktivieren anklicken oder Taste 'A')`\n            });\n            return newState;\n          }\n\n          // Dauerhaft-Initiativen werden weiterhin sofort aktiviert\n          // Initiative in den Ablagestapel\n          newState.discard = [...newState.discard, playedCard];\n          log(`P${player} spielt Initiative: ${playedCard.name}`);\n\n          // 6) Karteneffekte enqueuen + Queue aufl√∂sen\n          triggerCardEffects(newState, player, playedCard);\n          // Migration Helper verwenden\n          migrateLegacyQueue(newState);\n          // Nur noch _effectQueue verwenden\n          if (newState._effectQueue && newState._effectQueue.length > 0) {\n            resolveQueue(newState, newState._effectQueue);\n            newState._effectQueue = [];\n            // Nach Queue-Aufl√∂sung: Hand-Arrays immutabel neu zuweisen\n            afterQueueResolved === null || afterQueueResolved === void 0 ? void 0 : afterQueueResolved();\n          }\n\n          // Check for trap triggers\n          applyTrapsOnCardPlayed(newState, player, playedCard, e => (newState._effectQueue ??= []).push(e), m => (newState._effectQueue ??= []).push({\n            type: 'LOG',\n            msg: m\n          }));\n\n          // üî• CLUSTER 3: Auren-Flags neu berechnen (nach Kartenspielen)\n          recomputeAuraFlags(newState);\n\n          // üî• CLUSTER 3: Ai Weiwei Bonus wird bei Aktivierung angewendet (nicht beim Spielen)\n\n          // üî• PASSIVE EFFEKTE NACH INITIATIVE: Mark Zuckerberg & Sam Altman\n\n          // Mark Zuckerberg: \"Nach einer Initiative: +1 Aktionspunkt zur√ºck (einmal pro Runde)\"\n          const markZuckerberg = newState.board[player].innen.find(card => card.kind === 'spec' && card.name === 'Mark Zuckerberg');\n          if (markZuckerberg && !((_newState$effectFlags = newState.effectFlags[player]) !== null && _newState$effectFlags !== void 0 && _newState$effectFlags.markZuckerbergUsed)) {\n            newState.actionPoints[player] += 1;\n            newState.effectFlags[player] = {\n              ...newState.effectFlags[player],\n              markZuckerbergUsed: true\n            };\n            log(`üî• MARK ZUCKERBERG EFFEKT: +1 AP zur√ºck nach Initiative (${newState.actionPoints[player] - 1} ‚Üí ${newState.actionPoints[player]})`);\n          }\n\n          // Sam Altman: \"Bei einer KI-bezogenen Initiative: ziehe 1 Karte + 1 Aktionspunkt zur√ºck\"\n          const samAltman = newState.board[player].innen.find(card => card.kind === 'spec' && card.name === 'Sam Altman');\n          if (samAltman && playedCard.tag === 'Intelligenz') {\n            // Ziehe 1 Karte\n            if (newState.decks[player].length > 0) {\n              const drawnCard = newState.decks[player].shift();\n              if (drawnCard) {\n                newState.hands[player].push(drawnCard);\n                log(`üî• SAM ALTMAN EFFEKT: +1 Karte gezogen (${drawnCard.name}) - KI-Initiative`);\n              }\n            }\n            // +1 AP zur√ºck\n            newState.actionPoints[player] += 1;\n            log(`üî• SAM ALTMAN EFFEKT: +1 AP zur√ºck (${newState.actionPoints[player] - 1} ‚Üí ${newState.actionPoints[player]}) - KI-Initiative`);\n          }\n          return newState;\n        }\n\n        // 3) √ñffentlichkeit (Public)\n        if (typeStr === '√∂ffentlichkeitskarte' || typeStr === 'oeffentlichkeitskarte' || typeStr === '√∂ffentlichkeit' || typeStr === 'public') {\n          if (newState.board[player].innen.length < 5) {\n            const innenArray = [...newState.board[player].innen, playedCard];\n            const playerBoardCloned = {\n              ...newState.board[player],\n              innen: innenArray\n            };\n            newState.board = {\n              ...newState.board,\n              [player]: playerBoardCloned\n            };\n            log(`P${player} spielt ${playedCard.name} in √ñffentlichkeit`);\n\n            // Sofort Auren pr√ºfen (z.B. JF +1, wenn JF schon liegt)\n            applyAurasForPlayer(newState, player, log);\n\n            // 6) Karteneffekte enqueuen + Queue aufl√∂sen\n            triggerCardEffects(newState, player, playedCard);\n            // Migration Helper verwenden\n            migrateLegacyQueue(newState);\n            if (newState._effectQueue && newState._effectQueue.length > 0) {\n              resolveQueue(newState, newState._effectQueue);\n              newState._effectQueue = [];\n              // Nach Queue-Aufl√∂sung: Hand-Arrays immutabel neu zuweisen\n              afterQueueResolved === null || afterQueueResolved === void 0 ? void 0 : afterQueueResolved();\n            }\n\n            // Check for trap triggers\n            applyTrapsOnCardPlayed(newState, player, playedCard, e => (newState._effectQueue ??= []).push(e), m => (newState._effectQueue ??= []).push({\n              type: 'LOG',\n              msg: m\n            }));\n\n            // üî• PUBLIC CARD EFFECTS - Passive effects when played\n\n            // Helper function to draw a card for the player\n            const drawCardForPlayer = cardName => {\n              if (newState.decks[player].length > 0) {\n                const drawnCard = newState.decks[player].shift();\n                if (drawnCard) {\n                  newState.hands[player].push(drawnCard);\n                  log(`üî• ${cardName.toUpperCase()} EFFEKT: +1 Karte gezogen (${drawnCard.name})`);\n                  return true;\n                }\n              }\n              return false;\n            };\n            if (specCard.name === 'Elon Musk') {\n              // Effect: \"Ziehe 1 Karte. Deine erste Initiative pro Runde kostet 1 Aktionspunkt weniger.\"\n              drawCardForPlayer('Elon Musk');\n              // üî• QUEUE-SYSTEM: Erste Initiative pro Runde ‚Üí Refund wird √ºber triggerCardEffects gehandhabt\n            } else if (specCard.name === 'Bill Gates') {\n              // Effect: \"Ziehe 1 Karte. Deine n√§chste Initiative kostet 1 Aktionspunkt weniger.\"\n              drawCardForPlayer('Bill Gates');\n              // üî• QUEUE-SYSTEM: N√§chste Initiative ‚Üí Refund wird √ºber triggerCardEffects gehandhabt\n            } else if (specCard.name === 'Jeff Bezos') {\n              // Effect: \"Ziehe 1 Karte beim Ausspielen. Wenn eine Plattform liegt: +1 Aktionspunkt.\"\n              drawCardForPlayer('Jeff Bezos');\n              const hasPlatform = newState.board[player].innen.some(c => c.kind === 'spec' && c.tag === 'Plattform');\n              if (hasPlatform) {\n                newState.actionPoints[player] += 1;\n                log(`üî• JEFF BEZOS: +1 AP durch Plattform-Synergie! (${newState.actionPoints[player] - 1} ‚Üí ${newState.actionPoints[player]})`);\n              }\n            } else if (specCard.name === 'Warren Buffett') {\n              // Effect: \"Ziehe 1 Karte. Bei einer Wirtschafts-Initiative: +1 Effekt.\"\n              drawCardForPlayer('Warren Buffett');\n              // TODO: Implement \"Wirtschafts-Initiative +1 Effect\" logic\n              log(`üìä WARREN BUFFETT: Bei Wirtschafts-Initiativen +1 Effekt! (TODO: Implementierung)`);\n            } else if (specCard.name === 'Gautam Adani') {\n              // Effect: \"Ziehe 1 Karte. Bei einer Infrastruktur-Initiative: +1 Effekt.\"\n              drawCardForPlayer('Gautam Adani');\n              // TODO: Implement \"Infrastruktur-Initiative +1 Effect\" logic\n              log(`üìä GAUTAM ADANI: Bei Infrastruktur-Initiativen +1 Effekt! (TODO: Implementierung)`);\n            } else if (specCard.name === 'Zhang Yiming') {\n              // Effect: \"Ziehe 1 Karte. Bei Medien auf dem Feld: -1 Aktionspunkt auf deine n√§chste Initiative.\"\n              drawCardForPlayer('Zhang Yiming');\n              const hasMedia = newState.board[player].innen.some(c => c.kind === 'spec' && c.tag === 'Medien');\n              if (hasMedia) {\n                // TODO: Implement \"n√§chste Initiative -1 AP\" logic\n                log(`üî• ZHANG YIMING: N√§chste Initiative kostet 1 AP weniger durch Medien-Synergie! (TODO: Implementierung)`);\n              }\n            } else if (specCard.name === 'George Soros') {\n              // Effect: \"+1 Aktionspunkt wenn der Gegner eine autorit√§re Regierungskarte hat.\"\n              const opponent = player === 1 ? 2 : 1;\n              const hasAuthoritarianCard = newState.board[opponent].aussen.some(card => {\n                const polCard = card;\n                return polCard.tag === 'Staatsoberhaupt' && polCard.influence >= 8; // High influence leaders\n              });\n              if (hasAuthoritarianCard) {\n                newState.actionPoints[player] += 1;\n                log(`üî• GEORGE SOROS EFFEKT: +1 AP durch autorit√§re Regierung des Gegners!`);\n                log(`üìä SOROS: Aktionspunkte ${newState.actionPoints[player] - 1} ‚Üí ${newState.actionPoints[player]}`);\n              } else {\n                log(`üí≠ George Soros: Keine autorit√§ren Karten beim Gegner - Effekt nicht ausgel√∂st`);\n              }\n            }\n\n            // üîó NGO-Synergie: Wenn eine NGO gelegt wird und Joschka Fischer liegt, erh√§lt P${player} +1 Einfluss (Rundenauswertung)\n            if (specCard.tag === 'NGO') {\n              const hasJoschka = newState.board[player].aussen.some(c => c.kind === 'pol' && c.name === 'Joschka Fischer' && !c.deactivated);\n              if (hasJoschka) {\n                log(`üî•üî•üî• SYNERGIE AKTIVIERT! üî•üî•üî• Joschka Fischer + ${playedCard.name}[NGO] ‚Üí +1 Einfluss bei Rundenauswertung`);\n              }\n            }\n          } else {\n            log(`‚ùå ERROR: Lane full - √ñffentlichkeit ist voll (5/5)`);\n          }\n\n          // Simplified AP system: No refunds\n          return newState;\n        }\n\n        // 4) Default: Traps/Interventions\n        // Falls Trap-Karte gelegt wird\n        if (playedCard.kind === 'spec' && (_type2 = playedCard.type) !== null && _type2 !== void 0 && _type2.toLowerCase().includes('trap')) {\n          registerTrap(newState, player, playedCard.key || playedCard.name.toLowerCase().replace(/[- ]/g, '_'));\n          // NICHT sofort checken ‚Äì sie wartet auf den Gegner\n          return newState;\n        }\n        newState.traps[player] = [...newState.traps[player], playedCard];\n        log(`P${player} spielt ${playedCard.name} als ${specCard.type}`);\n\n        // 6) Karteneffekte enqueuen + Queue aufl√∂sen\n        triggerCardEffects(newState, player, playedCard);\n        // Migration Helper verwenden\n        migrateLegacyQueue(newState);\n        // Nur noch _effectQueue verwenden\n        if (newState._effectQueue && newState._effectQueue.length > 0) {\n          resolveQueue(newState, newState._effectQueue);\n          newState._effectQueue = [];\n          // Nach Queue-Aufl√∂sung: Hand-Arrays immutabel neu zuweisen\n          afterQueueResolved === null || afterQueueResolved === void 0 ? void 0 : afterQueueResolved();\n        }\n\n        // Check for trap triggers\n        applyTrapsOnCardPlayed(newState, player, playedCard, e => (newState._effectQueue ??= []).push(e), m => (newState._effectQueue ??= []).push({\n          type: 'LOG',\n          msg: m\n        }));\n\n        // Simplified AP system: No refunds\n        return newState;\n      }\n\n      // 6) Karteneffekte enqueuen + Queue aufl√∂sen (fallback f√ºr unbekannte Kartentypen)\n      triggerCardEffects(newState, player, selectedCard);\n      // Migration Helper verwenden\n      migrateLegacyQueue(newState);\n      // Nur noch _effectQueue verwenden\n      if (newState._effectQueue && newState._effectQueue.length > 0) {\n        resolveQueue(newState, newState._effectQueue);\n        newState._effectQueue = [];\n        // Nach Queue-Aufl√∂sung: Hand-Arrays immutabel neu zuweisen\n        afterQueueResolved === null || afterQueueResolved === void 0 ? void 0 : afterQueueResolved();\n      }\n\n      // Check for trap triggers\n      applyTrapsOnCardPlayed(newState, player, selectedCard, e => (newState._effectQueue ??= []).push(e), m => (newState._effectQueue ??= []).push({\n        type: 'LOG',\n        msg: m\n      }));\n\n      // Simplified AP system: No refunds\n\n      // Kein Aktionenlimit mehr ‚Üí automatischer Turnwechsel entf√§llt\n\n      return newState;\n    });\n  }, [setGameState, log]);\n  const activateInstantInitiative = useCallback(player => {\n    setGameState(prev => {\n      if (prev.current !== player) {\n        log(`‚ùå ERROR: Not player turn - Current: ${prev.current}, Attempted: ${player}`);\n        return prev;\n      }\n      const instantCard = prev.board[player].sofort[0];\n      if (!instantCard) {\n        log(`‚ùå ERROR: No Sofort-Initiative in slot for player ${player}`);\n        return prev;\n      }\n      const newState = {\n        ...prev\n      };\n\n      // 1) Normale Karten-Effekte der Sofort-Karte feuern\n      triggerCardEffects(newState, player, instantCard);\n\n      // Check for trap triggers\n      applyTrapsOnCardPlayed(newState, player, instantCard, e => (newState._effectQueue ??= []).push(e), m => (newState._effectQueue ??= []).push({\n        type: 'LOG',\n        msg: m\n      }));\n\n      // 2) Queue aufl√∂sen (BEVOR die Karte entfernt wird)\n      if (newState._effectQueue && newState._effectQueue.length > 0) {\n        resolveQueue(newState, [...newState._effectQueue]);\n        newState._effectQueue = [];\n        // Nach Queue-Aufl√∂sung: Hand-Arrays immutabel neu zuweisen\n        afterQueueResolved === null || afterQueueResolved === void 0 ? void 0 : afterQueueResolved();\n      }\n\n      // 3) Karte NACH Queue-Aufl√∂sung in den Ablagestapel\n      const [played] = newState.board[player].sofort.splice(0, 1);\n      newState.discard.push(played);\n      return newState;\n    });\n  }, [setGameState, log]);\n  const endTurn = useCallback((reason = 'button_end_turn') => {\n    setGameState(prev => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const current = prev.current;\n\n      // 1) Schon im Abschluss? -> Nichts tun (Idempotenz)\n      if (prev.isEndingTurn) {\n        log('üîÅ Zugabschluss l√§uft bereits ‚Äì warte auf Queue.');\n        return prev;\n      }\n      const newState = {\n        ...prev,\n        isEndingTurn: true\n      };\n\n      // 2) H√§ngen noch Effekte in der Queue? -> Aufl√∂sen lassen\n      if (newState._effectQueue && newState._effectQueue.length > 0) {\n        log('‚è≥ Effekte werden noch aufgel√∂st ‚Äì Zugwechsel folgt automatisch.');\n        resolveQueue(newState, [...newState._effectQueue]);\n        newState._effectQueue = [];\n        // Nach Queue-Aufl√∂sung: Wenn Flag noch gesetzt, Zug beenden\n        if (newState.isEndingTurn) {\n          return reallyEndTurn(newState, log);\n        }\n        return newState;\n      }\n\n      // 3) Keine Effekte mehr -> sofort beenden\n      return reallyEndTurn(newState, log);\n    });\n  }, [setGameState, log]);\n\n  // Legacy: nextTurn als Alias f√ºr endTurn f√ºr Kompatibilit√§t\n  const nextTurn = useCallback(() => {\n    endTurn('auto');\n  }, [endTurn]);\n  const passTurn = useCallback(player => {\n    console.log(`üîß DEBUG: passTurn called for player ${player}`);\n    setGameState(prev => {\n      console.log(`üîß DEBUG: passTurn setState - current: ${prev.current}, player: ${player}`);\n      if (prev.current !== player) {\n        console.log(`üîß DEBUG: Wrong player turn - current: ${prev.current}, attempted: ${player}`);\n        return prev;\n      }\n      const newState = {\n        ...prev,\n        passed: {\n          ...prev.passed,\n          [player]: true\n        }\n      };\n      console.log(`üîß DEBUG: Pass status updated - P1: ${newState.passed[1]}, P2: ${newState.passed[2]}`);\n      log(`üö´ Spieler ${player} passt.`);\n\n      // ‚ùó Kein Nachziehen bei Pass:\n      // Der passierende Spieler kommt in dieser Runde nicht mehr dran.\n      // Die n√§chste Runde startet ohnehin mit 5 neuen Handkarten.\n\n      // Check if round should end (both players passed)\n      const shouldEndRound = checkRoundEnd(newState);\n      console.log(`üîß DEBUG: Should end round? ${shouldEndRound}`);\n      if (shouldEndRound) {\n        log(`üèÅ Runde ${newState.round} wird beendet und ausgewertet.`);\n        return resolveRound(newState, log);\n      } else {\n        // Switch turn to other player for their final chance\n        const otherPlayer = player === 1 ? 2 : 1;\n        console.log(`üîß DEBUG: Switching to other player ${otherPlayer}, has passed: ${newState.passed[otherPlayer]}`);\n\n        // Only switch if other player hasn't passed yet\n        if (!newState.passed[otherPlayer]) {\n          newState.current = otherPlayer;\n          newState.actionPoints = {\n            ...newState.actionPoints,\n            [otherPlayer]: 2\n          };\n\n          // Apply new start-of-turn hooks\n          applyStartOfTurnFlags(newState, otherPlayer, log);\n\n          // üî• CLUSTER 3: Auren-Flags beim Zugstart neu berechnen\n          recomputeAuraFlags(newState);\n          log(`‚è≠Ô∏è Spieler ${otherPlayer} hat noch einen letzten Zug.`);\n          console.log(`üîß DEBUG: Turn switched to player ${otherPlayer}`);\n        } else {\n          // Both players have passed now, end round\n          log(`üèÅ Runde ${newState.round} wird beendet (beide Spieler haben gepasst).`);\n          return resolveRound(newState, log);\n        }\n      }\n      return newState;\n    });\n  }, [setGameState, log]);\n  return {\n    startMatchWithDecks,\n    startMatchVsAI,\n    playCard,\n    activateInstantInitiative,\n    passTurn,\n    nextTurn,\n    endTurn\n  };\n}\n_s(useGameActions, \"k0iUrGA3o3AxUL5rOzEt77YoKGE=\");","map":{"version":3,"names":["useCallback","createDefaultEffectFlags","buildDeckFromEntries","sumGovernmentInfluenceWithAuras","PRESET_DECKS","getCardActionPointCost","getNetApCost","canPlayCard","triggerCardEffects","ensureTestBaselineAP","resolveQueue","applyStartOfTurnFlags","registerTrap","applyTrapsOnCardPlayed","recomputeAuraFlags","emptyBoard","migrateLegacyQueue","state","_queue","length","_effectQueue","push","other","p","ensureFlags","s","effectFlags","pickLane","c","tag","kind","isCardPlayableNow","player","card","deactivated","lane","board","t","String","type","toLowerCase","innen","slot","permanentSlots","hasPlayableZeroCost","hands","cost","applyAurasForPlayer","log","hasNgo","some","newAussen","aussen","map","pol","baseInfluence","influence","prev","bonus","name","effect","checkRoundEnd","gameState","result","passed","console","drawCardsFromDeck","count","deck","decks","drawnCards","splice","Math","min","reallyEndTurn","current","isEndingTurn","drawnCard","shift","shouldEndRound","round","resolveRound","newCurrent","actionPoints","p1Influence","p2Influence","roundWinner","cardsToDiscard","government","public","sofort","newP1Hand","newP2Hand","newRoundsWon","roundsWon","p1Wins","p2Wins","gameWinner","newState","actionsUsed","initiativePermanent","slice","discard","useGameActions","setGameState","afterQueueResolved","_s","startMatchWithDecks","p1DeckEntries","p2DeckEntries","p1Cards","p2Cards","p1NgoCarten","filter","p1PlatformCards","p1JoschaCards","p1PublicCards","join","d1","d2","h1","h2","traps","shields","Set","activeRefresh","startMatchVsAI","presetKey","playCard","handIndex","hand","i","ngoCards","platformCards","selectedCard","prevAp","max","ef","newHand","playedCard","currentBoard","publicCardsOnBoard","polCard","targetLane","laneArray","playerBoardCloned","event","e","m","msg","opponent","opponentBoard","romanAbramovich","find","regierungKarten","√∂ffentlichkeitKarten","joschaFischer","_type","_type2","specCard","typeStr","isInitiative","test","includes","ownBoard","candidates","target","protected","slotType","_newState$permanentSl","_newState$effectFlags","effectKey","_newState$board$playe","markZuckerberg","markZuckerbergUsed","samAltman","innenArray","drawCardForPlayer","cardName","toUpperCase","hasPlatform","hasMedia","hasAuthoritarianCard","hasJoschka","key","replace","activateInstantInitiative","instantCard","played","endTurn","reason","nextTurn","passTurn","otherPlayer"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/hooks/useGameActions.ts"],"sourcesContent":["import { useCallback } from 'react';\r\nimport { GameState, Card, Player, BuilderEntry, PoliticianCard } from '../types/game';\r\nimport { createDefaultEffectFlags } from '../types/game';\r\nimport { buildDeckFromEntries, sumGovernmentInfluenceWithAuras } from '../utils/gameUtils';\r\nimport { PRESET_DECKS } from '../data/gameData';\r\nimport { getCardActionPointCost, getNetApCost, canPlayCard, isInitiativeCard, isGovernmentCard } from '../utils/ap';\r\nimport { triggerCardEffects } from '../effects/cards';\r\nimport { ensureTestBaselineAP } from '../utils/testCompat';\r\nimport { resolveQueue } from '../utils/queue';\r\nimport { applyStartOfTurnFlags } from '../utils/startOfTurnHooks';\r\nimport { registerTrap, applyTrapsOnCardPlayed } from '../utils/traps';\r\nimport { recomputeAuraFlags } from '../state/effects';\r\nimport { activateInstantInitiative as activateInstantInitiativeRuntime } from '../state/instantRuntime';\r\nimport { isInstantInitiative } from '../utils/initiative';\r\nimport { emptyBoard } from '../state/board';\r\nimport type { EffectEvent } from '../types/effects';\r\n\r\n// Migration Helper f√ºr Queue-Vereinheitlichung\r\nconst migrateLegacyQueue = (state: any) => {\r\n  if (state._queue && state._queue.length > 0) {\r\n    if (!state._effectQueue) state._effectQueue = [];\r\n    state._effectQueue.push(...state._queue);\r\n    state._queue = [];\r\n  }\r\n};\r\n\r\n// Helper function for getting the other player\r\nconst other = (p: Player): Player => (p === 1 ? 2 : 1) as Player;\r\n\r\n// Hilfsfunktion: stellt sicher, dass effectFlags vorhanden sind\r\nconst ensureFlags = (s: GameState, p: Player) => {\r\n  if (!s.effectFlags) {\r\n    (s as any).effectFlags = { 1: createDefaultEffectFlags(), 2: createDefaultEffectFlags() };\r\n  } else {\r\n    s.effectFlags[p] = { ...createDefaultEffectFlags(), ...s.effectFlags[p] };\r\n  }\r\n};\r\n\r\n// Lane-Heuristik wie in playCard\r\nconst pickLane = (c: Card): 'innen'|'aussen' => {\r\n  const tag = (c as any).tag;\r\n  if (c.kind === 'pol' && (tag === 'Staatsoberhaupt' || tag === 'Regierungschef' || tag === 'Diplomat')) return 'aussen';\r\n  return 'innen';\r\n};\r\n\r\nconst isCardPlayableNow = (state: GameState, player: Player, card: Card): boolean => {\r\n  if ((card as any).deactivated) return false;\r\n\r\n  if (card.kind === 'pol') {\r\n    const lane = pickLane(card);\r\n    return state.board[player][lane].length < 5;\r\n  }\r\n\r\n  if (card.kind === 'spec') {\r\n    const t = String((card as any).type || '').toLowerCase();\r\n    if (t === '√∂ffentlichkeitskarte' || t === 'oeffentlichkeitskarte' || t === 'public') {\r\n      return state.board[player].innen.length < 5;\r\n    }\r\n    if (t === 'dauerhaft-initiative') {\r\n      const slot = 'government'; // wie bei dir ‚Äûsimplified\"\r\n      return !state.permanentSlots[player][slot];\r\n    }\r\n    // sonst: Fallen/Interventionen ‚Äì aktuell immer erlaubt\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nexport const hasPlayableZeroCost = (state: GameState, player: Player): boolean => {\r\n  for (const c of state.hands[player]) {\r\n    const { cost } = getCardActionPointCost(state, player, c);\r\n    if (cost === 0 && isCardPlayableNow(state, player, c)) return true;\r\n  }\r\n  return false;\r\n};\r\n\r\n// Helper function to apply auras for a player (instant updates for Joschka Fischer + NGO synergy)\r\nfunction applyAurasForPlayer(state: GameState, player: Player, log?: (msg: string) => void) {\r\n  const board = state.board[player];\r\n  const hasNgo = board.innen.some(c =>\r\n    c.kind === 'spec' &&\r\n    (c as any).type === '√ñffentlichkeitskarte' &&\r\n    (c as any).tag === 'NGO' &&\r\n    !(c as any).deactivated\r\n  );\r\n\r\n  const newAussen = board.aussen.map(card => {\r\n    if (card.kind !== 'pol') return card;\r\n    const pol: any = { ...card };\r\n    if (pol.baseInfluence == null) pol.baseInfluence = pol.influence;\r\n    const prev = pol.influence as number;\r\n\r\n    let bonus = 0;\r\n    if (!pol.deactivated && pol.name === 'Joschka Fischer' && pol.effect === 'ngo_boost' && hasNgo) {\r\n      bonus += 1;\r\n    }\r\n    pol.influence = (pol.baseInfluence as number) + bonus;\r\n    if (log && pol.influence > prev) log(`PASSIV: ${pol.name} +${pol.influence - prev} I (jetzt ${pol.influence}).`);\r\n    return pol;\r\n  });\r\n\r\n  state.board = {\r\n    ...state.board,\r\n    [player]: { ...state.board[player], aussen: newAussen },\r\n  } as any;\r\n}\r\n\r\n\r\n\r\n// Helper function to check if round should end\r\nfunction checkRoundEnd(gameState: GameState): boolean {\r\n  // Round ends if both players have passed\r\n  const result = gameState.passed[1] && gameState.passed[2];\r\n  console.log(`üîß DEBUG: checkRoundEnd - P1 passed: ${gameState.passed[1]}, P2 passed: ${gameState.passed[2]}, result: ${result}`);\r\n  return result;\r\n}\r\n\r\n// Helper function to draw cards from deck\r\nfunction drawCardsFromDeck(gameState: GameState, player: Player, count: number): Card[] {\r\n  const deck = [...gameState.decks[player]];\r\n  const drawnCards = deck.splice(0, Math.min(count, deck.length));\r\n  return drawnCards;\r\n}\r\n\r\n// Helper function to really end a turn (extracted from nextTurn logic)\r\nfunction reallyEndTurn(gameState: GameState, log: (msg: string) => void): GameState {\r\n  const current = gameState.current;\r\n\r\n  // Flag zur√ºcksetzen - Zug-Ende wird jetzt wirklich durchgef√ºhrt\r\n  gameState.isEndingTurn = false;\r\n\r\n  // ‚úÖ Karte nachziehen am Ende eines Zugs (nur wenn NICHT \"pass\")\r\n  if (!gameState.passed[current]) {\r\n    const drawnCard = gameState.decks[current].shift();\r\n    if (drawnCard) {\r\n      gameState.hands[current].push(drawnCard);\r\n      log(`üî• Zug-Ende: +1 Karte gezogen (${drawnCard.name})`);\r\n    }\r\n  } else {\r\n    log(`‚è≠Ô∏è P${current} hat gepasst ‚Äì kein Nachziehen.`);\r\n  }\r\n\r\n  // Check if round should end\r\n  const shouldEndRound = checkRoundEnd(gameState);\r\n  if (shouldEndRound) {\r\n    log(`üèÅ Runde ${gameState.round} wird beendet (Zug-Ende).`);\r\n    return resolveRound(gameState, log);\r\n  }\r\n\r\n  // Spielerwechsel + AP reset\r\n  const newCurrent: Player = current === 1 ? 2 : 1;\r\n  gameState.current = newCurrent;\r\n  gameState.actionPoints = { ...gameState.actionPoints, [newCurrent]: 2 };\r\n  gameState.passed = { ...gameState.passed, [newCurrent]: false };\r\n\r\n            // Apply new start-of-turn hooks\r\n          applyStartOfTurnFlags(gameState, newCurrent, log);\r\n\r\n        // üî• CLUSTER 3: Auren-Flags beim Zugstart neu berechnen\r\n        recomputeAuraFlags(gameState);\r\n\r\n  // Reset turn-bezogener Flag-Nutzungen (handled in applyStartOfTurnFlags)\r\n\r\n  log(`üîÑ Zug-Ende: Spieler ${newCurrent} ist am Zug (2 AP verf√ºgbar)`);\r\n\r\n  return gameState;\r\n}\r\n\r\n// Helper function to resolve round and start new one\r\nfunction resolveRound(gameState: GameState, log: (msg: string) => void): GameState {\r\n  // Calculate influence for both players\r\n  const p1Influence = sumGovernmentInfluenceWithAuras(gameState, 1);\r\n  const p2Influence = sumGovernmentInfluenceWithAuras(gameState, 2);\r\n\r\n  log(`üìä Rundenauswertung: P1 ${p1Influence} Einfluss vs P2 ${p2Influence} Einfluss`);\r\n\r\n  // Determine winner\r\n  let roundWinner: Player;\r\n  if (p1Influence > p2Influence) {\r\n    roundWinner = 1;\r\n    log(`üèÜ Spieler 1 gewinnt die Runde! (${p1Influence} > ${p2Influence})`);\r\n  } else if (p2Influence > p1Influence) {\r\n    roundWinner = 2;\r\n    log(`üèÜ Spieler 2 gewinnt die Runde! (${p2Influence} > ${p1Influence})`);\r\n  } else {\r\n    // Tie - current player wins\r\n    roundWinner = gameState.current;\r\n    log(`ü§ù Unentschieden! Spieler ${roundWinner} gewinnt als aktiver Spieler.`);\r\n  }\r\n\r\n  // Collect all cards to move to discard\r\n  const cardsToDiscard: Card[] = [\r\n    ...gameState.board[1].innen,\r\n    ...gameState.board[1].aussen,\r\n    ...gameState.board[2].innen,\r\n    ...gameState.board[2].aussen,\r\n    ...(gameState.permanentSlots[1].government ? [gameState.permanentSlots[1].government] : []),\r\n    ...(gameState.permanentSlots[1].public ? [gameState.permanentSlots[1].public] : []),\r\n    ...(gameState.permanentSlots[2].government ? [gameState.permanentSlots[2].government] : []),\r\n    ...(gameState.permanentSlots[2].public ? [gameState.permanentSlots[2].public] : []),\r\n    ...gameState.board[1].sofort,\r\n    ...gameState.board[2].sofort\r\n  ];\r\n\r\n  // Draw 5 new cards for each player\r\n  const newP1Hand = drawCardsFromDeck(gameState, 1, 5);\r\n  const newP2Hand = drawCardsFromDeck(gameState, 2, 5);\r\n\r\n  // Calculate new rounds won\r\n  const newRoundsWon = {\r\n    ...gameState.roundsWon,\r\n    [roundWinner]: gameState.roundsWon[roundWinner] + 1\r\n  };\r\n\r\n  // Check if game should end (Best of 3: first to 2 wins)\r\n  const p1Wins = newRoundsWon[1];\r\n  const p2Wins = newRoundsWon[2];\r\n\r\n  if (p1Wins >= 2 || p2Wins >= 2) {\r\n    const gameWinner = p1Wins >= 2 ? 1 : 2;\r\n    log(`üèÜüéâ SPIEL BEENDET! Spieler ${gameWinner} gewinnt das Match! (${p1Wins}-${p2Wins})`);\r\n    log(`üî• Gesamtergebnis: Player ${gameWinner} ist der Sieger!`);\r\n\r\n    // Return final state with game winner\r\n    return {\r\n      ...gameState,\r\n      roundsWon: newRoundsWon,\r\n      gameWinner,\r\n      // Keep current board state for final display\r\n      passed: { 1: true, 2: true }, // Both passed to indicate game end\r\n    };\r\n  }\r\n\r\n  // Create new state for next round\r\n  const newState: GameState = {\r\n    ...gameState,\r\n    round: gameState.round + 1,\r\n    current: roundWinner, // Winner starts next round\r\n         passed: { 1: false, 2: false }, // Reset pass status\r\n     actionPoints: { 1: 2, 2: 2 }, // Reset AP\r\n     actionsUsed: { 1: 0, 2: 0 }, // Reset actions (kept for compatibility)\r\n     roundsWon: newRoundsWon,\r\n    effectFlags: {\r\n      1: createDefaultEffectFlags(),\r\n      2: createDefaultEffectFlags()\r\n    },\r\n    // Clear all board positions\r\n    board: emptyBoard(),\r\n    // Clear permanent slots\r\n    permanentSlots: {\r\n      1: { government: null, public: null, initiativePermanent: null },\r\n      2: { government: null, public: null, initiativePermanent: null }\r\n    },\r\n    // instantSlot wird nicht mehr verwendet - Sofort-Initiativen gehen in board[player].sofort\r\n    // New hands with 5 cards each\r\n    hands: {\r\n      1: newP1Hand,\r\n      2: newP2Hand\r\n    },\r\n    // Update decks (cards were removed during drawing)\r\n    decks: {\r\n      1: gameState.decks[1].slice(newP1Hand.length),\r\n      2: gameState.decks[2].slice(newP2Hand.length)\r\n    },\r\n    // Update discard pile\r\n    discard: [...gameState.discard, ...cardsToDiscard]\r\n  };\r\n\r\n  log(`üÜï Runde ${newState.round} startet! Spieler ${roundWinner} beginnt. (Rundenstand: P1 ${newState.roundsWon[1]} - P2 ${newState.roundsWon[2]})`);\r\n  log(`üÉè Beide Spieler erhalten 5 neue Handkarten.`);\r\n\r\n  return newState;\r\n}\r\n\r\nexport function useGameActions(\r\n  gameState: GameState,\r\n  setGameState: React.Dispatch<React.SetStateAction<GameState>>,\r\n  log: (msg: string) => void,\r\n  afterQueueResolved?: () => void\r\n) {\r\n  const startMatchWithDecks = useCallback((p1DeckEntries: BuilderEntry[], p2DeckEntries: BuilderEntry[]) => {\r\n    const p1Cards = buildDeckFromEntries(p1DeckEntries);\r\n    const p2Cards = buildDeckFromEntries(p2DeckEntries);\r\n\r\n        // Debug: Log deck composition with detailed tag analysis\r\n    const p1NgoCarten = p1Cards.filter(c => (c as any).tag === 'NGO');\r\n    const p1PlatformCards = p1Cards.filter(c => (c as any).tag === 'Plattform');\r\n    const p1JoschaCards = p1Cards.filter(c => (c as any).effect === 'ngo_boost');\r\n    const p1PublicCards = p1Cards.filter(c => c.kind === 'spec' && (c as any).type === '√ñffentlichkeitskarte');\r\n\r\n    log(`üîç DECK DEBUG P1: ${p1Cards.length} Karten total`);\r\n    log(`üß™ P1 Public Cards: ${p1PublicCards.map(c => `${c.name}${(c as any).tag ? `[${(c as any).tag}]` : ''}`).join(', ')}`);\r\n    log(`üå± P1 NGO-Karten: ${p1NgoCarten.length > 0 ? p1NgoCarten.map(c => c.name).join(', ') : 'Keine'}`);\r\n    log(`üíª P1 Plattform-Karten: ${p1PlatformCards.length > 0 ? p1PlatformCards.map(c => c.name).join(', ') : 'Keine'}`);\r\n    log(`üéØ JOSCHKA FISCHER: ${p1JoschaCards.length > 0 ? '‚úÖ IM DECK' : '‚ùå NICHT IM DECK'}`);\r\n\r\n    const d1 = [...p1Cards];\r\n    const d2 = [...p2Cards];\r\n    const h1 = d1.splice(0, Math.min(5, d1.length));\r\n    const h2 = d2.splice(0, Math.min(5, d2.length));\r\n\r\n    setGameState({\r\n      ...gameState,\r\n      round: 1,\r\n      current: 1,\r\n      passed: { 1: false, 2: false },\r\n      decks: { 1: d1, 2: d2 },\r\n      hands: { 1: h1, 2: h2 },\r\n      board: { 1: { innen: [], aussen: [], sofort: [] }, 2: { innen: [], aussen: [], sofort: [] } },\r\n      traps: { 1: [], 2: [] },\r\n      permanentSlots: {\r\n        1: { government: null, public: null, initiativePermanent: null },\r\n        2: { government: null, public: null, initiativePermanent: null },\r\n      },\r\n      // instantSlot wird nicht mehr verwendet - Sofort-Initiativen gehen in board[player].sofort\r\n      discard: [],\r\n      shields: new Set(), // Set<UID>\r\n      effectFlags: {\r\n        1: createDefaultEffectFlags(),\r\n        2: createDefaultEffectFlags()\r\n      },\r\n      actionsUsed: { 1: 0, 2: 0 },\r\n      log: [\r\n        `Match gestartet. P1 und P2 erhalten je ${h1.length}/${h2.length} Startkarten.`,\r\n        `üîç DECK DEBUG P1: ${p1Cards.length} Karten total`,\r\n        `üß™ P1 Public Cards: ${p1PublicCards.map(c => `${c.name}${(c as any).tag ? `[${(c as any).tag}]` : ''}`).join(', ')}`,\r\n        `üå± P1 NGO-Karten: ${p1NgoCarten.length > 0 ? p1NgoCarten.map(c => c.name).join(', ') : 'Keine'}`,\r\n        `üíª P1 Plattform-Karten: ${p1PlatformCards.length > 0 ? p1PlatformCards.map(c => c.name).join(', ') : 'Keine'}`,\r\n        `üéØ JOSCHKA FISCHER: ${p1JoschaCards.length > 0 ? '‚úÖ IM DECK' : '‚ùå NICHT IM DECK'}`,\r\n        `üìã INITIAL BOARD P1: Regierung=[] | √ñffentlichkeit=[]`,\r\n        `üìã INITIAL BOARD P2: Regierung=[] | √ñffentlichkeit=[]`,\r\n        `üè† PERMANENT SLOTS: Alle leer`\r\n      ],\r\n      activeRefresh: { 1: 0, 2: 0 },\r\n    });\r\n  }, [gameState, setGameState, log]);\r\n\r\n  const startMatchVsAI = useCallback((p1DeckEntries: BuilderEntry[], presetKey: keyof typeof PRESET_DECKS = 'AUTORITAERER_REALIST') => {\r\n    const p2DeckEntries = PRESET_DECKS[presetKey] as BuilderEntry[];\r\n    startMatchWithDecks(p1DeckEntries, p2DeckEntries);\r\n  }, [startMatchWithDecks]);\r\n\r\n  const playCard = useCallback((player: Player, handIndex: number, lane?: 'innen' | 'aussen') => {\r\n    setGameState(prev => {\r\n      // Test-only baseline fix ‚Äì ensures AP=5 at game start inside test runner\r\n      ensureTestBaselineAP(prev);\r\n\r\n      // Validate input parameters\r\n      if (prev.current !== player) {\r\n        log(`‚ùå ERROR: Not player turn - Current: ${prev.current}, Attempted: ${player}`);\r\n        return prev;\r\n      }\r\n\r\n      const hand = prev.hands[player];\r\n      if (handIndex < 0 || handIndex >= hand.length) {\r\n        log(`‚ùå ERROR: Invalid hand index - Index: ${handIndex}, Hand length: ${hand.length}`);\r\n        return prev;\r\n      }\r\n\r\n      // Debug: Log current hand contents with detailed tag info\r\n      log(`üîç HAND DEBUG P${player}: ${hand.map((c, i) => `${i}:${c.name}${(c as any).tag ? `[${(c as any).tag}]` : ''}`).join(', ')}`);\r\n      const ngoCards = hand.filter(c => (c as any).tag === 'NGO');\r\n      const platformCards = hand.filter(c => (c as any).tag === 'Plattform');\r\n      if (ngoCards.length > 0) {\r\n        log(`üå± NGO-Karten in Hand P${player}: ${ngoCards.map(c => c.name).join(', ')}`);\r\n      }\r\n      if (platformCards.length > 0) {\r\n        log(`üíª Plattform-Karten in Hand P${player}: ${platformCards.map(c => c.name).join(', ')}`);\r\n      }\r\n\r\n      const selectedCard = hand[handIndex];\r\n      if (!canPlayCard(prev, player, selectedCard)) {\r\n        log('üö´ Kann Karte nicht spielen (keine AP verf√ºgbar).');\r\n        return prev;\r\n      }\r\n\r\n      const { cost } = getNetApCost(prev, player, selectedCard);\r\n      const prevAp = prev.actionPoints[player];\r\n\r\n      const newState = { ...prev };\r\n\r\n      // Simplified AP system: All cards cost exactly 1 AP\r\n      newState.actionPoints[player] = Math.max(0, newState.actionPoints[player] - cost);\r\n      log(`üí≥ Kosten verbucht: AP ${prevAp}‚Üí${newState.actionPoints[player]}`);\r\n\r\n      // Flags KONSUMIEREN (einheitlich, NUR HIER!)\r\n      ensureFlags(newState, player);\r\n      const ef = newState.effectFlags[player];\r\n\r\n      // Simplified AP system: No refunds or discounts\r\n      // All cards cost exactly 1 AP\r\n\r\n      // Remove card from hand\r\n      const newHand = [...newState.hands[player]];\r\n      const [playedCard] = newHand.splice(handIndex, 1);\r\n      newState.hands = { ...newState.hands, [player]: newHand };\r\n\r\n      // üîß CLUSTER 3 DEBUG: Zeige jede gespielte Karte\r\n      log(`üîß CLUSTER 3 GLOBAL DEBUG: P${player} spielt ${(playedCard as any).name} (${playedCard.kind}) - Type: ${(playedCard as any).type || 'KEIN TYPE'}`);\r\n\r\n      // üîß CLUSTER 3 DEBUG: Zeige aktuelles Board\r\n      const currentBoard = newState.board[player];\r\n      const publicCardsOnBoard = currentBoard.innen.filter(card => card.kind === 'spec');\r\n      log(`üîß CLUSTER 3 GLOBAL DEBUG: √ñffentlichkeitskarten auf dem Feld: ${publicCardsOnBoard.map(c => (c as any).name).join(', ')}`);\r\n\r\n      // Jennifer Doudna check removed - not needed for current game logic\r\n\r\n      // Handle different card types\r\n      if (playedCard.kind === 'pol') {\r\n        const polCard = playedCard as any;\r\n        const targetLane = lane || (polCard.tag === 'Staatsoberhaupt' || polCard.tag === 'Regierungschef' || polCard.tag === 'Diplomat' ? 'aussen' : 'innen');\r\n\r\n        if (newState.board[player][targetLane].length >= 5) {\r\n          log(`‚ùå ERROR: Lane full - Lane: ${targetLane}, Current: ${newState.board[player][targetLane].length}/5`);\r\n          return prev;\r\n        }\r\n\r\n        // Add to board (immutable clone to avoid accidental double references)\r\n        const laneArray = [...newState.board[player][targetLane], playedCard];\r\n        const playerBoardCloned = { ...newState.board[player], [targetLane]: laneArray } as any;\r\n        newState.board = { ...newState.board, [player]: playerBoardCloned } as any;\r\n        log(`üÉè Player ${player}: ${playedCard.name} gespielt in ${targetLane === 'aussen' ? 'Regierung' : '√ñffentlichkeit'}`);\r\n\r\n        // 3) Nachdem die Karte gelegt wurde: gegnerische Traps pr√ºfen\r\n        applyTrapsOnCardPlayed(\r\n          newState,\r\n          player,\r\n          playedCard,\r\n          (event) => {\r\n            if (!newState._effectQueue) newState._effectQueue = [];\r\n            newState._effectQueue.push(event);\r\n          },\r\n          log\r\n        );\r\n\r\n        // üëâ Erst JETZT Auren anwenden (damit +2 Basis erhalten bleibt)\r\n        applyAurasForPlayer(newState, player, log);\r\n\r\n        // 6) Karteneffekte enqueuen + Queue aufl√∂sen\r\n        triggerCardEffects(newState, player, playedCard);\r\n        // Migration Helper verwenden\r\n        migrateLegacyQueue(newState);\r\n        // Nur noch _effectQueue verwenden\r\n        if (newState._effectQueue && newState._effectQueue.length > 0) {\r\n          resolveQueue(newState, newState._effectQueue);\r\n          newState._effectQueue = [];\r\n          // Nach Queue-Aufl√∂sung: Hand-Arrays immutabel neu zuweisen\r\n          afterQueueResolved?.();\r\n        }\r\n\r\n        // Check for trap triggers\r\n        applyTrapsOnCardPlayed(\r\n          newState,\r\n          player,\r\n          playedCard,\r\n          (e) => (newState._effectQueue ??= []).push(e),\r\n          (m) => (newState._effectQueue ??= []).push({ type: 'LOG', msg: m })\r\n        );\r\n\r\n        // üî• ROMAN ABRAMOVICH EFFEKT: Wenn Regierungskarte mit Einfluss ‚â§5 gespielt wird\r\n        if (playedCard.kind === 'pol' && (playedCard as any).influence <= 5) {\r\n          const opponent = player === 1 ? 2 : 1;\r\n          const opponentBoard = newState.board[opponent];\r\n          const romanAbramovich = opponentBoard.innen.find(card =>\r\n            card.kind === 'spec' && (card as any).name === 'Roman Abramovich'\r\n          );\r\n\r\n          if (romanAbramovich) {\r\n            // Ziehe eine Karte f√ºr den Gegner\r\n            if (newState.decks[opponent].length > 0) {\r\n              const drawnCard = newState.decks[opponent].shift();\r\n              if (drawnCard) {\r\n                newState.hands[opponent].push(drawnCard);\r\n                log(`üî• ROMAN ABRAMOVICH EFFEKT: P${opponent} zieht 1 Karte (${drawnCard.name}) - Regierungskarte mit Einfluss ‚â§5 gespielt`);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // üîç BOARD DEBUG: Zeige aktuelles Board nach dem Spielen\r\n        const currentBoard = newState.board[player];\r\n        const regierungKarten = currentBoard.aussen.map(c => `${c.name}[${c.kind === 'pol' ? (c as any).influence + 'I' : 'S'}]`);\r\n        const √∂ffentlichkeitKarten = currentBoard.innen.map(c => `${c.name}[${c.kind === 'spec' ? (c as any).tag || 'S' : 'P'}]`);\r\n        log(`üìã P${player} BOARD: Regierung=[${regierungKarten.join(', ')}] | √ñffentlichkeit=[${√∂ffentlichkeitKarten.join(', ')}]`);\r\n\r\n                // üî• JOSCHKA FISCHER NGO-EFFEKT: Jetzt als kontinuierlicher Aura-Effekt in sumRowWithAuras implementiert\r\n        log(`üîç DEBUG: Karte gespielt - Name: ${playedCard.name}, Tag: ${(playedCard as any).tag || 'Kein Tag'}, Lane: ${targetLane}, Kind: ${playedCard.kind}`);\r\n\r\n        if ((playedCard as any).tag === 'NGO') {\r\n          log(`üîç NGO-Karte gespielt: ${playedCard.name} [NGO] - Kontinuierliche Aura-Effekte werden bei Rundenauswertung berechnet`);\r\n\r\n          // üéØ SOFORTIGE SYNERGIE-PR√úFUNG: Joschka Fischer + NGO\r\n          const joschaFischer = currentBoard.aussen.find(card =>\r\n            card.kind === 'pol' && (card as any).effect === 'ngo_boost'\r\n          );\r\n\r\n          if (joschaFischer) {\r\n            log(`üî•üî•üî• SYNERGIE AKTIVIERT! üî•üî•üî• Joschka Fischer + ${playedCard.name}[NGO] ‚Üí +1 Einfluss bei Rundenauswertung`);\r\n          }\r\n        }\r\n\r\n      } else if (playedCard.kind === 'spec') {\r\n        const specCard = playedCard as any;\r\n        const typeStr = String(specCard.type || '').toLowerCase();\r\n        const isInitiative = /initiative/.test(typeStr); // matcht \"Initiative\", \"Sofort-Initiative\", etc.\r\n\r\n                  // 1) Falls es eine \"Systemrelevant\" ist (sofortiger Buff auf letzte eigene Regierungskarte)\r\n        if (playedCard.kind === 'spec' && (playedCard as any).type?.toLowerCase().includes('systemrelevant')) {\r\n          const ownBoard = newState.board[player];\r\n          const candidates = [...ownBoard.aussen, ...ownBoard.innen].filter(c => c.kind === 'pol') as PoliticianCard[];\r\n          const target = candidates[candidates.length - 1]; // letzte eigene Regierungskarte\r\n          if (target) {\r\n            (target as any).protected = true;\r\n            log(`üõ°Ô∏è ${target.name} erh√§lt einmaligen Schutz.`);\r\n          } else {\r\n            log('üõà Systemrelevant: Keine eigene Regierungskarte im Spiel ‚Äì Effekt verpufft.');\r\n          }\r\n          // danach die Spezialkarte normal entsorgen\r\n          newState.discard.push(playedCard);\r\n          return newState;\r\n        }\r\n\r\n        // 1) Dauerhaft-Initiative (Ongoing)\r\n        if (typeStr.includes('dauerhaft')) {\r\n          // Slot-Mapping: Dauerhaft-Initiativen ‚Üí initiativePermanent, nicht government\r\n          const slotType = 'initiativePermanent';\r\n          if (!newState.permanentSlots[player][slotType]) {\r\n            newState.permanentSlots[player][slotType] = playedCard;\r\n            log(`P${player} spielt ${playedCard.name} als Dauerhafte Initiative (Slot: ${slotType})`);\r\n          } else {\r\n            log(`‚ö†Ô∏è WARN: Slot occupied - Slot ${slotType} already has ${newState.permanentSlots[player][slotType]?.name}`);\r\n          }\r\n\r\n          // 6) Karteneffekte enqueuen + Queue aufl√∂sen\r\n          triggerCardEffects(newState, player, playedCard);\r\n          // Migration Helper verwenden\r\n          migrateLegacyQueue(newState);\r\n          // Nur noch _effectQueue verwenden\r\n          if (newState._effectQueue && newState._effectQueue.length > 0) {\r\n            resolveQueue(newState, newState._effectQueue);\r\n            newState._effectQueue = [];\r\n            // Nach Queue-Aufl√∂sung: Hand-Arrays immutabel neu zuweisen\r\n            afterQueueResolved?.();\r\n          }\r\n\r\n          // Check for trap triggers\r\n          applyTrapsOnCardPlayed(\r\n            newState,\r\n            player,\r\n            playedCard,\r\n            (e) => (newState._effectQueue ??= []).push(e),\r\n            (m) => (newState._effectQueue ??= []).push({ type: 'LOG', msg: m })\r\n          );\r\n\r\n          return newState;\r\n        }\r\n\r\n        // 2) Sofort-/Sofort-Initiativen (Instant)\r\n        if (isInitiative) {\r\n          if (!specCard.effectKey) {\r\n            log(`‚ùå Initiative ohne effectKey: ${specCard.name}`);\r\n          } else {\r\n            log(`üß© INIT: ${specCard.name} [${String(specCard.effectKey)}] gespielt`);\r\n          }\r\n\r\n          // üîß NEU: Sofort-Initiativen werden in das sofort Array gelegt statt sofort aktiviert\r\n          if (typeStr.includes('sofort')) {\r\n            // Pr√ºfe ob bereits eine Sofort-Initiative im Slot liegt\r\n            if (newState.board[player].sofort.length > 0) {\r\n              log(`‚ùå ERROR: Sofort-Initiative-Slot bereits besetzt - ${newState.board[player].sofort[0]?.name} muss erst aktiviert werden`);\r\n              // Karte zur√ºck in die Hand\r\n              newState.hands[player] = [...newState.hands[player], playedCard];\r\n              // AP zur√ºckgeben\r\n              newState.actionPoints[player] += cost;\r\n              // AP zur√ºckgegeben, keine Aktion r√ºckg√§ngig zu machen\r\n              return newState;\r\n            }\r\n\r\n            // Sofort-Initiative in das sofort Array legen\r\n            newState.board[player].sofort = [playedCard];\r\n            log(`üéØ P${player} legt ${playedCard.name} in Sofort-Initiative-Slot (kann sp√§ter aktiviert werden)`);\r\n\r\n            // Sofort-Initiativen: auf Board.sofort legen (nicht direkt entsorgen)\r\n            if (!newState._effectQueue) newState._effectQueue = [];\r\n            newState._effectQueue.push({ type: 'LOG', msg: `üîî Sofort-Initiative bereit: ${playedCard.name} (zum Aktivieren anklicken oder Taste 'A')` });\r\n            return newState;\r\n          }\r\n\r\n          // Dauerhaft-Initiativen werden weiterhin sofort aktiviert\r\n          // Initiative in den Ablagestapel\r\n          newState.discard = [...newState.discard, playedCard];\r\n          log(`P${player} spielt Initiative: ${playedCard.name}`);\r\n\r\n                     // 6) Karteneffekte enqueuen + Queue aufl√∂sen\r\n           triggerCardEffects(newState, player, playedCard);\r\n           // Migration Helper verwenden\r\n           migrateLegacyQueue(newState);\r\n           // Nur noch _effectQueue verwenden\r\n         if (newState._effectQueue && newState._effectQueue.length > 0) {\r\n           resolveQueue(newState, newState._effectQueue);\r\n           newState._effectQueue = [];\r\n           // Nach Queue-Aufl√∂sung: Hand-Arrays immutabel neu zuweisen\r\n           afterQueueResolved?.();\r\n         }\r\n\r\n           // Check for trap triggers\r\n           applyTrapsOnCardPlayed(\r\n             newState,\r\n             player,\r\n             playedCard,\r\n             (e) => (newState._effectQueue ??= []).push(e),\r\n             (m) => (newState._effectQueue ??= []).push({ type: 'LOG', msg: m })\r\n           );\r\n\r\n           // üî• CLUSTER 3: Auren-Flags neu berechnen (nach Kartenspielen)\r\n          recomputeAuraFlags(newState);\r\n\r\n          // üî• CLUSTER 3: Ai Weiwei Bonus wird bei Aktivierung angewendet (nicht beim Spielen)\r\n\r\n          // üî• PASSIVE EFFEKTE NACH INITIATIVE: Mark Zuckerberg & Sam Altman\r\n\r\n          // Mark Zuckerberg: \"Nach einer Initiative: +1 Aktionspunkt zur√ºck (einmal pro Runde)\"\r\n          const markZuckerberg = newState.board[player].innen.find(card =>\r\n            card.kind === 'spec' && (card as any).name === 'Mark Zuckerberg'\r\n          );\r\n          if (markZuckerberg && !newState.effectFlags[player]?.markZuckerbergUsed) {\r\n            newState.actionPoints[player] += 1;\r\n            newState.effectFlags[player] = { ...newState.effectFlags[player], markZuckerbergUsed: true };\r\n            log(`üî• MARK ZUCKERBERG EFFEKT: +1 AP zur√ºck nach Initiative (${newState.actionPoints[player] - 1} ‚Üí ${newState.actionPoints[player]})`);\r\n          }\r\n\r\n          // Sam Altman: \"Bei einer KI-bezogenen Initiative: ziehe 1 Karte + 1 Aktionspunkt zur√ºck\"\r\n          const samAltman = newState.board[player].innen.find(card =>\r\n            card.kind === 'spec' && (card as any).name === 'Sam Altman'\r\n          );\r\n          if (samAltman && (playedCard as any).tag === 'Intelligenz') {\r\n            // Ziehe 1 Karte\r\n            if (newState.decks[player].length > 0) {\r\n              const drawnCard = newState.decks[player].shift();\r\n              if (drawnCard) {\r\n                newState.hands[player].push(drawnCard);\r\n                log(`üî• SAM ALTMAN EFFEKT: +1 Karte gezogen (${drawnCard.name}) - KI-Initiative`);\r\n              }\r\n            }\r\n            // +1 AP zur√ºck\r\n            newState.actionPoints[player] += 1;\r\n            log(`üî• SAM ALTMAN EFFEKT: +1 AP zur√ºck (${newState.actionPoints[player] - 1} ‚Üí ${newState.actionPoints[player]}) - KI-Initiative`);\r\n          }\r\n\r\n\r\n          return newState;\r\n        }\r\n\r\n        // 3) √ñffentlichkeit (Public)\r\n        if (\r\n          typeStr === '√∂ffentlichkeitskarte' ||\r\n          typeStr === 'oeffentlichkeitskarte' ||\r\n          typeStr === '√∂ffentlichkeit' ||\r\n          typeStr === 'public'\r\n        ) {\r\n          if (newState.board[player].innen.length < 5) {\r\n            const innenArray = [...newState.board[player].innen, playedCard];\r\n            const playerBoardCloned = { ...newState.board[player], innen: innenArray } as any;\r\n            newState.board = { ...newState.board, [player]: playerBoardCloned } as any;\r\n            log(`P${player} spielt ${playedCard.name} in √ñffentlichkeit`);\r\n\r\n            // Sofort Auren pr√ºfen (z.B. JF +1, wenn JF schon liegt)\r\n            applyAurasForPlayer(newState, player, log);\r\n\r\n                         // 6) Karteneffekte enqueuen + Queue aufl√∂sen\r\n             triggerCardEffects(newState, player, playedCard);\r\n             // Migration Helper verwenden\r\n             migrateLegacyQueue(newState);\r\n         if (newState._effectQueue && newState._effectQueue.length > 0) {\r\n           resolveQueue(newState, newState._effectQueue);\r\n           newState._effectQueue = [];\r\n           // Nach Queue-Aufl√∂sung: Hand-Arrays immutabel neu zuweisen\r\n           afterQueueResolved?.();\r\n         }\r\n\r\n             // Check for trap triggers\r\n             applyTrapsOnCardPlayed(\r\n               newState,\r\n               player,\r\n               playedCard,\r\n               (e) => (newState._effectQueue ??= []).push(e),\r\n               (m) => (newState._effectQueue ??= []).push({ type: 'LOG', msg: m })\r\n             );\r\n\r\n\r\n\r\n            // üî• PUBLIC CARD EFFECTS - Passive effects when played\r\n\r\n            // Helper function to draw a card for the player\r\n            const drawCardForPlayer = (cardName: string) => {\r\n              if (newState.decks[player].length > 0) {\r\n                const drawnCard = newState.decks[player].shift();\r\n                if (drawnCard) {\r\n                  newState.hands[player].push(drawnCard);\r\n                  log(`üî• ${cardName.toUpperCase()} EFFEKT: +1 Karte gezogen (${drawnCard.name})`);\r\n                  return true;\r\n                }\r\n              }\r\n              return false;\r\n            };\r\n\r\n            if (specCard.name === 'Elon Musk') {\r\n              // Effect: \"Ziehe 1 Karte. Deine erste Initiative pro Runde kostet 1 Aktionspunkt weniger.\"\r\n              drawCardForPlayer('Elon Musk');\r\n              // üî• QUEUE-SYSTEM: Erste Initiative pro Runde ‚Üí Refund wird √ºber triggerCardEffects gehandhabt\r\n\r\n            } else if (specCard.name === 'Bill Gates') {\r\n              // Effect: \"Ziehe 1 Karte. Deine n√§chste Initiative kostet 1 Aktionspunkt weniger.\"\r\n              drawCardForPlayer('Bill Gates');\r\n              // üî• QUEUE-SYSTEM: N√§chste Initiative ‚Üí Refund wird √ºber triggerCardEffects gehandhabt\r\n\r\n            } else if (specCard.name === 'Jeff Bezos') {\r\n              // Effect: \"Ziehe 1 Karte beim Ausspielen. Wenn eine Plattform liegt: +1 Aktionspunkt.\"\r\n              drawCardForPlayer('Jeff Bezos');\r\n              const hasPlatform = newState.board[player].innen.some(c =>\r\n                c.kind === 'spec' && (c as any).tag === 'Plattform'\r\n              );\r\n              if (hasPlatform) {\r\n                newState.actionPoints[player] += 1;\r\n                log(`üî• JEFF BEZOS: +1 AP durch Plattform-Synergie! (${newState.actionPoints[player] - 1} ‚Üí ${newState.actionPoints[player]})`);\r\n              }\r\n\r\n            } else if (specCard.name === 'Warren Buffett') {\r\n              // Effect: \"Ziehe 1 Karte. Bei einer Wirtschafts-Initiative: +1 Effekt.\"\r\n              drawCardForPlayer('Warren Buffett');\r\n              // TODO: Implement \"Wirtschafts-Initiative +1 Effect\" logic\r\n              log(`üìä WARREN BUFFETT: Bei Wirtschafts-Initiativen +1 Effekt! (TODO: Implementierung)`);\r\n\r\n            } else if (specCard.name === 'Gautam Adani') {\r\n              // Effect: \"Ziehe 1 Karte. Bei einer Infrastruktur-Initiative: +1 Effekt.\"\r\n              drawCardForPlayer('Gautam Adani');\r\n              // TODO: Implement \"Infrastruktur-Initiative +1 Effect\" logic\r\n              log(`üìä GAUTAM ADANI: Bei Infrastruktur-Initiativen +1 Effekt! (TODO: Implementierung)`);\r\n\r\n            } else if (specCard.name === 'Zhang Yiming') {\r\n              // Effect: \"Ziehe 1 Karte. Bei Medien auf dem Feld: -1 Aktionspunkt auf deine n√§chste Initiative.\"\r\n              drawCardForPlayer('Zhang Yiming');\r\n              const hasMedia = newState.board[player].innen.some(c =>\r\n                c.kind === 'spec' && (c as any).tag === 'Medien'\r\n              );\r\n              if (hasMedia) {\r\n                // TODO: Implement \"n√§chste Initiative -1 AP\" logic\r\n                log(`üî• ZHANG YIMING: N√§chste Initiative kostet 1 AP weniger durch Medien-Synergie! (TODO: Implementierung)`);\r\n              }\r\n\r\n            } else if (specCard.name === 'George Soros') {\r\n              // Effect: \"+1 Aktionspunkt wenn der Gegner eine autorit√§re Regierungskarte hat.\"\r\n              const opponent = player === 1 ? 2 : 1;\r\n              const hasAuthoritarianCard = newState.board[opponent].aussen.some(card => {\r\n                const polCard = card as any;\r\n                return polCard.tag === 'Staatsoberhaupt' && polCard.influence >= 8; // High influence leaders\r\n              });\r\n\r\n              if (hasAuthoritarianCard) {\r\n                newState.actionPoints[player] += 1;\r\n                log(`üî• GEORGE SOROS EFFEKT: +1 AP durch autorit√§re Regierung des Gegners!`);\r\n                log(`üìä SOROS: Aktionspunkte ${newState.actionPoints[player] - 1} ‚Üí ${newState.actionPoints[player]}`);\r\n              } else {\r\n                log(`üí≠ George Soros: Keine autorit√§ren Karten beim Gegner - Effekt nicht ausgel√∂st`);\r\n              }\r\n            }\r\n\r\n            // üîó NGO-Synergie: Wenn eine NGO gelegt wird und Joschka Fischer liegt, erh√§lt P${player} +1 Einfluss (Rundenauswertung)\r\n            if ((specCard as any).tag === 'NGO') {\r\n              const hasJoschka = newState.board[player].aussen.some(c => c.kind === 'pol' && (c as any).name === 'Joschka Fischer' && !(c as any).deactivated);\r\n              if (hasJoschka) {\r\n                log(`üî•üî•üî• SYNERGIE AKTIVIERT! üî•üî•üî• Joschka Fischer + ${playedCard.name}[NGO] ‚Üí +1 Einfluss bei Rundenauswertung`);\r\n              }\r\n            }\r\n          } else {\r\n            log(`‚ùå ERROR: Lane full - √ñffentlichkeit ist voll (5/5)`);\r\n          }\r\n\r\n          // Simplified AP system: No refunds\r\n          return newState;\r\n        }\r\n\r\n                  // 4) Default: Traps/Interventions\r\n                  // Falls Trap-Karte gelegt wird\r\n          if (playedCard.kind === 'spec' && (playedCard as any).type?.toLowerCase().includes('trap')) {\r\n            registerTrap(newState, player, playedCard.key || playedCard.name.toLowerCase().replace(/[- ]/g, '_'));\r\n            // NICHT sofort checken ‚Äì sie wartet auf den Gegner\r\n            return newState;\r\n          }\r\n\r\n        newState.traps[player] = [...newState.traps[player], playedCard];\r\n        log(`P${player} spielt ${playedCard.name} als ${specCard.type}`);\r\n\r\n        // 6) Karteneffekte enqueuen + Queue aufl√∂sen\r\n        triggerCardEffects(newState, player, playedCard);\r\n        // Migration Helper verwenden\r\n        migrateLegacyQueue(newState);\r\n        // Nur noch _effectQueue verwenden\r\n        if (newState._effectQueue && newState._effectQueue.length > 0) {\r\n          resolveQueue(newState, newState._effectQueue);\r\n          newState._effectQueue = [];\r\n          // Nach Queue-Aufl√∂sung: Hand-Arrays immutabel neu zuweisen\r\n          afterQueueResolved?.();\r\n        }\r\n\r\n        // Check for trap triggers\r\n        applyTrapsOnCardPlayed(\r\n          newState,\r\n          player,\r\n          playedCard,\r\n          (e) => (newState._effectQueue ??= []).push(e),\r\n          (m) => (newState._effectQueue ??= []).push({ type: 'LOG', msg: m })\r\n        );\r\n\r\n        // Simplified AP system: No refunds\r\n        return newState;\r\n      }\r\n\r\n      // 6) Karteneffekte enqueuen + Queue aufl√∂sen (fallback f√ºr unbekannte Kartentypen)\r\n      triggerCardEffects(newState, player, selectedCard);\r\n      // Migration Helper verwenden\r\n      migrateLegacyQueue(newState);\r\n      // Nur noch _effectQueue verwenden\r\n        if (newState._effectQueue && newState._effectQueue.length > 0) {\r\n          resolveQueue(newState, newState._effectQueue);\r\n          newState._effectQueue = [];\r\n          // Nach Queue-Aufl√∂sung: Hand-Arrays immutabel neu zuweisen\r\n          afterQueueResolved?.();\r\n        }\r\n\r\n      // Check for trap triggers\r\n      applyTrapsOnCardPlayed(\r\n        newState,\r\n        player,\r\n        selectedCard,\r\n        (e) => (newState._effectQueue ??= []).push(e),\r\n        (m) => (newState._effectQueue ??= []).push({ type: 'LOG', msg: m })\r\n      );\r\n\r\n      // Simplified AP system: No refunds\r\n\r\n      // Kein Aktionenlimit mehr ‚Üí automatischer Turnwechsel entf√§llt\r\n\r\n\r\n      return newState;\r\n    });\r\n  }, [setGameState, log]);\r\n\r\n  const activateInstantInitiative = useCallback((player: Player) => {\r\n    setGameState(prev => {\r\n      if (prev.current !== player) {\r\n        log(`‚ùå ERROR: Not player turn - Current: ${prev.current}, Attempted: ${player}`);\r\n        return prev;\r\n      }\r\n\r\n      const instantCard = prev.board[player].sofort[0];\r\n      if (!instantCard) {\r\n        log(`‚ùå ERROR: No Sofort-Initiative in slot for player ${player}`);\r\n        return prev;\r\n      }\r\n\r\n      const newState = { ...prev };\r\n\r\n      // 1) Normale Karten-Effekte der Sofort-Karte feuern\r\n      triggerCardEffects(newState, player, instantCard);\r\n\r\n      // Check for trap triggers\r\n      applyTrapsOnCardPlayed(\r\n        newState,\r\n        player,\r\n        instantCard,\r\n        (e) => (newState._effectQueue ??= []).push(e),\r\n        (m) => (newState._effectQueue ??= []).push({ type: 'LOG', msg: m })\r\n      );\r\n\r\n      // 2) Queue aufl√∂sen (BEVOR die Karte entfernt wird)\r\n      if (newState._effectQueue && newState._effectQueue.length > 0) {\r\n        resolveQueue(newState, [...newState._effectQueue]);\r\n        newState._effectQueue = [];\r\n        // Nach Queue-Aufl√∂sung: Hand-Arrays immutabel neu zuweisen\r\n        afterQueueResolved?.();\r\n      }\r\n\r\n      // 3) Karte NACH Queue-Aufl√∂sung in den Ablagestapel\r\n      const [played] = newState.board[player].sofort.splice(0, 1);\r\n      newState.discard.push(played);\r\n\r\n      return newState;\r\n    });\r\n  }, [setGameState, log]);\r\n\r\n  const endTurn = useCallback((reason: 'button_end_turn' | 'auto' = 'button_end_turn') => {\r\n    setGameState((prev): GameState => {\r\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n      const current = prev.current;\r\n\r\n      // 1) Schon im Abschluss? -> Nichts tun (Idempotenz)\r\n      if (prev.isEndingTurn) {\r\n        log('üîÅ Zugabschluss l√§uft bereits ‚Äì warte auf Queue.');\r\n        return prev;\r\n      }\r\n\r\n      const newState = { ...prev, isEndingTurn: true };\r\n\r\n      // 2) H√§ngen noch Effekte in der Queue? -> Aufl√∂sen lassen\r\n      if (newState._effectQueue && newState._effectQueue.length > 0) {\r\n        log('‚è≥ Effekte werden noch aufgel√∂st ‚Äì Zugwechsel folgt automatisch.');\r\n        resolveQueue(newState, [...newState._effectQueue]);\r\n        newState._effectQueue = [];\r\n        // Nach Queue-Aufl√∂sung: Wenn Flag noch gesetzt, Zug beenden\r\n        if (newState.isEndingTurn) {\r\n          return reallyEndTurn(newState, log);\r\n        }\r\n        return newState;\r\n      }\r\n\r\n      // 3) Keine Effekte mehr -> sofort beenden\r\n      return reallyEndTurn(newState, log);\r\n    });\r\n  }, [setGameState, log]);\r\n\r\n  // Legacy: nextTurn als Alias f√ºr endTurn f√ºr Kompatibilit√§t\r\n  const nextTurn = useCallback(() => {\r\n    endTurn('auto');\r\n  }, [endTurn]);\r\n\r\n    const passTurn = useCallback((player: Player) => {\r\n    console.log(`üîß DEBUG: passTurn called for player ${player}`);\r\n\r\n    setGameState(prev => {\r\n      console.log(`üîß DEBUG: passTurn setState - current: ${prev.current}, player: ${player}`);\r\n\r\n      if (prev.current !== player) {\r\n        console.log(`üîß DEBUG: Wrong player turn - current: ${prev.current}, attempted: ${player}`);\r\n        return prev;\r\n      }\r\n\r\n      const newState = { ...prev, passed: { ...prev.passed, [player]: true } };\r\n      console.log(`üîß DEBUG: Pass status updated - P1: ${newState.passed[1]}, P2: ${newState.passed[2]}`);\r\n      log(`üö´ Spieler ${player} passt.`);\r\n\r\n      // ‚ùó Kein Nachziehen bei Pass:\r\n      // Der passierende Spieler kommt in dieser Runde nicht mehr dran.\r\n      // Die n√§chste Runde startet ohnehin mit 5 neuen Handkarten.\r\n\r\n      // Check if round should end (both players passed)\r\n      const shouldEndRound = checkRoundEnd(newState);\r\n      console.log(`üîß DEBUG: Should end round? ${shouldEndRound}`);\r\n\r\n      if (shouldEndRound) {\r\n        log(`üèÅ Runde ${newState.round} wird beendet und ausgewertet.`);\r\n        return resolveRound(newState, log);\r\n      } else {\r\n        // Switch turn to other player for their final chance\r\n        const otherPlayer: Player = player === 1 ? 2 : 1;\r\n        console.log(`üîß DEBUG: Switching to other player ${otherPlayer}, has passed: ${newState.passed[otherPlayer]}`);\r\n\r\n        // Only switch if other player hasn't passed yet\r\n        if (!newState.passed[otherPlayer]) {\r\n                     newState.current = otherPlayer;\r\n           newState.actionPoints = { ...newState.actionPoints, [otherPlayer]: 2 };\r\n\r\n          // Apply new start-of-turn hooks\r\n          applyStartOfTurnFlags(newState, otherPlayer, log);\r\n\r\n        // üî• CLUSTER 3: Auren-Flags beim Zugstart neu berechnen\r\n        recomputeAuraFlags(newState);\r\n\r\n          log(`‚è≠Ô∏è Spieler ${otherPlayer} hat noch einen letzten Zug.`);\r\n          console.log(`üîß DEBUG: Turn switched to player ${otherPlayer}`);\r\n        } else {\r\n          // Both players have passed now, end round\r\n          log(`üèÅ Runde ${newState.round} wird beendet (beide Spieler haben gepasst).`);\r\n          return resolveRound(newState, log);\r\n        }\r\n      }\r\n\r\n      return newState;\r\n    });\r\n  }, [setGameState, log]);\r\n\r\n  return {\r\n    startMatchWithDecks,\r\n    startMatchVsAI,\r\n    playCard,\r\n    activateInstantInitiative,\r\n    passTurn,\r\n    nextTurn,\r\n    endTurn,\r\n  };\r\n  }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}