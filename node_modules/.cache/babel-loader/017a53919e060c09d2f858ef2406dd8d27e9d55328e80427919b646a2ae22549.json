{"ast":null,"code":"// src/qte/atlasLoader.ts - simple runtime loader for TexturePacker JSON (ARRAY) format\n// The JSON layout we expect (TexturePacker \"JSON (Hash)\" or \"JSON (Array)\" works):\n// {\n//   \"frames\": {\n//      \"idle_0\": { \"frame\": {\"x\":0,\"y\":0,\"w\":256,\"h\":256}, ... },\n//      \"idle_1\": {...},\n//      \"walk_0\": {...}\n//   },\n//   \"meta\": { \"image\": \"atlas.png\" }\n// }\n// Each frame key is expected to be <state>_<index> (index starting at 0).\n// We group them into an array per state and keep the order of index.\n\nexport async function loadAtlas(basePath) {\n  // Expects `${basePath}/atlas.json` and `${basePath}/atlas.png`\n  const cacheBuster = Date.now();\n  const jsonUrl = `${basePath}/atlas.json?v=${cacheBuster}`;\n  console.log(`[atlas] Loading ${jsonUrl}`);\n  const res = await fetch(jsonUrl);\n  if (!res.ok) throw new Error(`Atlas JSON not found ${jsonUrl} (status: ${res.status})`);\n  const text = await res.text();\n  console.log(`[atlas] JSON response length: ${text.length}, starts with: ${text.substring(0, 100)}`);\n  let data;\n  try {\n    data = JSON.parse(text);\n  } catch (e) {\n    console.error(`[atlas] JSON parse error:`, e);\n    console.error(`[atlas] Invalid JSON text:`, text.substring(0, 200));\n    throw e;\n  }\n  const framesData = data.frames;\n  const meta = data.meta || {};\n  const imgPath = `${basePath}/${meta.image || 'atlas.png'}?v=${cacheBuster}`;\n  console.log(`[atlas] Loading image ${imgPath}`);\n  const image = await loadImage(imgPath);\n  const stateMap = {};\n  for (const key in framesData) {\n    const state = key.replace(/_\\d+$/, \"\");\n    const idxMatch = /_(\\d+)$/.exec(key);\n    const idx = idxMatch ? parseInt(idxMatch[1], 10) : 0;\n    if (!stateMap[state]) stateMap[state] = [];\n    const f = framesData[key].frame;\n    stateMap[state][idx] = {\n      x: f.x,\n      y: f.y,\n      w: f.w,\n      h: f.h\n    };\n  }\n\n  // Determine frame size from first frame\n  const firstState = Object.keys(stateMap)[0];\n  const firstFrame = firstState ? stateMap[firstState][0] : {\n    w: 64,\n    h: 64\n  };\n  const animations = {};\n  for (const s of Object.keys(stateMap)) {\n    animations[s] = {\n      frames: stateMap[s],\n      fps: 12,\n      loop: s !== 'attack' && s !== 'parry'\n    };\n  }\n  return {\n    image,\n    animations,\n    frameW: firstFrame.w,\n    frameH: firstFrame.h\n  };\n}\nfunction loadImage(src) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n}","map":{"version":3,"names":["loadAtlas","basePath","cacheBuster","Date","now","jsonUrl","console","log","res","fetch","ok","Error","status","text","length","substring","data","JSON","parse","e","error","framesData","frames","meta","imgPath","image","loadImage","stateMap","key","state","replace","idxMatch","exec","idx","parseInt","f","frame","x","y","w","h","firstState","Object","keys","firstFrame","animations","s","fps","loop","frameW","frameH","src","Promise","resolve","reject","img","Image","onload","onerror"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/qte/atlasLoader.ts"],"sourcesContent":["// src/qte/atlasLoader.ts - simple runtime loader for TexturePacker JSON (ARRAY) format\r\n// The JSON layout we expect (TexturePacker \"JSON (Hash)\" or \"JSON (Array)\" works):\r\n// {\r\n//   \"frames\": {\r\n//      \"idle_0\": { \"frame\": {\"x\":0,\"y\":0,\"w\":256,\"h\":256}, ... },\r\n//      \"idle_1\": {...},\r\n//      \"walk_0\": {...}\r\n//   },\r\n//   \"meta\": { \"image\": \"atlas.png\" }\r\n// }\r\n// Each frame key is expected to be <state>_<index> (index starting at 0).\r\n// We group them into an array per state and keep the order of index.\r\n\r\nexport interface Rect { x: number; y: number; w: number; h: number }\r\nexport interface AtlasAnimation {\r\n  frames: Rect[];\r\n  fps: number;\r\n  loop: boolean;\r\n}\r\n\r\nexport interface LoadedAtlas {\r\n  image: HTMLImageElement;\r\n  animations: Record<string, AtlasAnimation>;\r\n  frameW: number;\r\n  frameH: number;\r\n}\r\n\r\nexport async function loadAtlas(basePath: string): Promise<LoadedAtlas> {\r\n  // Expects `${basePath}/atlas.json` and `${basePath}/atlas.png`\r\n  const cacheBuster = Date.now();\r\n  const jsonUrl = `${basePath}/atlas.json?v=${cacheBuster}`;\r\n  console.log(`[atlas] Loading ${jsonUrl}`);\r\n  const res = await fetch(jsonUrl);\r\n  if (!res.ok) throw new Error(`Atlas JSON not found ${jsonUrl} (status: ${res.status})`);\r\n  \r\n  const text = await res.text();\r\n  console.log(`[atlas] JSON response length: ${text.length}, starts with: ${text.substring(0, 100)}`);\r\n  \r\n  let data;\r\n  try {\r\n    data = JSON.parse(text);\r\n  } catch (e) {\r\n    console.error(`[atlas] JSON parse error:`, e);\r\n    console.error(`[atlas] Invalid JSON text:`, text.substring(0, 200));\r\n    throw e;\r\n  }\r\n  const framesData = data.frames;\r\n  const meta = data.meta || {};\r\n  const imgPath = `${basePath}/${meta.image || 'atlas.png'}?v=${cacheBuster}`;\r\n  console.log(`[atlas] Loading image ${imgPath}`);\r\n  const image = await loadImage(imgPath);\r\n\r\n  const stateMap: Record<string, Rect[]> = {};\r\n  for (const key in framesData) {\r\n    const state = key.replace(/_\\d+$/, \"\");\r\n    const idxMatch = /_(\\d+)$/.exec(key);\r\n    const idx = idxMatch ? parseInt(idxMatch[1], 10) : 0;\r\n    if (!stateMap[state]) stateMap[state] = [];\r\n    const f = framesData[key].frame as { x: number; y: number; w: number; h: number };\r\n    stateMap[state][idx] = { x: f.x, y: f.y, w: f.w, h: f.h };\r\n  }\r\n\r\n  // Determine frame size from first frame\r\n  const firstState = Object.keys(stateMap)[0];\r\n  const firstFrame = firstState ? stateMap[firstState][0] : { w: 64, h: 64 };\r\n\r\n  const animations: Record<string, AtlasAnimation> = {};\r\n  for (const s of Object.keys(stateMap)) {\r\n    animations[s] = { frames: stateMap[s], fps: 12, loop: s !== 'attack' && s !== 'parry' };\r\n  }\r\n\r\n  return { image, animations, frameW: firstFrame.w, frameH: firstFrame.h };\r\n}\r\n\r\nfunction loadImage(src: string): Promise<HTMLImageElement> {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.onload = () => resolve(img);\r\n    img.onerror = reject;\r\n    img.src = src;\r\n  });\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}