{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useCallback, useRef, useEffect } from 'react';\nimport { createDefaultEffectFlags } from '../types/game';\nimport { buildDeckFromEntries, sumGovernmentInfluenceWithAuras } from '../utils/gameUtils';\nimport { PRESET_DECKS } from '../data/gameData';\nimport { getCardActionPointCost, getNetApCost, canPlayCard } from '../utils/ap';\nimport { triggerCardEffects } from '../effects/cards';\nimport { ensureTestBaselineAP } from '../utils/testCompat';\nimport { resolveQueue } from '../utils/queue';\nimport { applyStartOfTurnFlags } from '../utils/startOfTurnHooks';\nimport { registerTrap, applyTrapsOnCardPlayed } from '../utils/traps';\nimport { recomputeAuraFlags } from '../state/effects';\nimport { emptyBoard } from '../state/board';\nimport { logger } from '../debug/logger';\nimport { useVisualEffectsSafe } from '../context/VisualEffectsContext';\n// TS: sometimes asset module resolution fails in some setups â€” ignore typecheck for this import\n// @ts-ignore\nimport slotGovGif from '../ui/layout/slot_gov.webm';\nimport { getUiTransform, getGovernmentRects } from '../ui/layout';\n\n// Migration Helper fÃ¼r Queue-Vereinheitlichung\nconst migrateLegacyQueue = state => {\n  // Queue migration completed - only _effectQueue exists now\n};\n\n// Helper function for getting the other player\nconst other = p => p === 1 ? 2 : 1;\n\n// Hilfsfunktion: stellt sicher, dass effectFlags vorhanden sind\nconst ensureFlags = (s, p) => {\n  if (!s.effectFlags) {\n    s.effectFlags = {\n      1: createDefaultEffectFlags(),\n      2: createDefaultEffectFlags()\n    };\n  } else {\n    s.effectFlags[p] = {\n      ...createDefaultEffectFlags(),\n      ...s.effectFlags[p]\n    };\n  }\n};\n\n// Lane-Heuristik wie in playCard\nconst pickLane = c => {\n  const tag = c.tag;\n  if (c.kind === 'pol' && (tag === 'Staatsoberhaupt' || tag === 'Regierungschef' || tag === 'Diplomat')) return 'aussen';\n  return 'innen';\n};\nconst isCardPlayableNow = (state, player, card) => {\n  if (card.deactivated) return false;\n  if (card.kind === 'pol') {\n    const lane = pickLane(card);\n    return state.board[player][lane].length < 5;\n  }\n  if (card.kind === 'spec') {\n    const t = String(card.type || '').toLowerCase();\n    // Public cards\n    if (t === 'Ã¶ffentlichkeitskarte' || t === 'oeffentlichkeitskarte' || t === 'public') {\n      return state.board[player].innen.length < 5;\n    }\n\n    // Detect Ongoing / Permanent Initiatives by explicit tags or by effectKey namespace\n    const tags = card.tags || card.tags || [];\n    const isOngoingInitiative = card.type && String(card.type).toLowerCase().includes('initiative') && (tags.includes('Ongoing') || String(card.effectKey || '').startsWith('init.') && tags.includes('Ongoing'));\n    if (isOngoingInitiative) {\n      // Determine which permanent slot this initiative should occupy. Prefer explicit slot metadata, otherwise default to government.\n      const preferredSlot = card.permanentSlot || (card.tags && card.tags.includes('Public') ? 'public' : 'government');\n      return !state.permanentSlots[player][preferredSlot];\n    }\n\n    // sonst: Fallen/Interventionen â€“ aktuell immer erlaubt\n    return true;\n  }\n  return false;\n};\nexport const hasPlayableZeroCost = (state, player) => {\n  for (const c of state.hands[player]) {\n    const {\n      cost\n    } = getCardActionPointCost(state, player, c);\n    if (cost === 0 && isCardPlayableNow(state, player, c)) return true;\n  }\n  return false;\n};\n\n// Helper function to apply auras for a player (instant updates for Joschka Fischer + NGO synergy)\nfunction applyAurasForPlayer(state, player, log) {\n  const board = state.board[player];\n  const hasNgo = board.innen.some(c => c.kind === 'spec' && c.type === 'Ã–ffentlichkeitskarte' && c.tag === 'NGO' && !c.deactivated);\n  const newAussen = board.aussen.map(card => {\n    if (card.kind !== 'pol') return card;\n    const pol = {\n      ...card\n    };\n    if (pol.baseInfluence == null) pol.baseInfluence = pol.influence;\n    const prev = pol.influence;\n    let bonus = 0;\n    if (!pol.deactivated && pol.name === 'Joschka Fischer' && pol.effect === 'ngo_boost' && hasNgo) {\n      bonus += 1;\n    }\n    pol.influence = pol.baseInfluence + bonus;\n    if (log && pol.influence > prev) log(`PASSIV: ${pol.name} +${pol.influence - prev} I (jetzt ${pol.influence}).`);\n    return pol;\n  });\n  state.board = {\n    ...state.board,\n    [player]: {\n      ...state.board[player],\n      aussen: newAussen\n    }\n  };\n}\n\n// Helper function to check if round should end\nfunction checkRoundEnd(gameState) {\n  // Round ends if both players have passed\n  const result = gameState.passed[1] && gameState.passed[2];\n  logger.dbg(`checkRoundEnd P1=${gameState.passed[1]} P2=${gameState.passed[2]} result=${result}`);\n  return result;\n}\n\n// Helper function to draw cards from deck\nfunction drawCardsFromDeck(gameState, player, count) {\n  const deck = [...gameState.decks[player]];\n  const drawnCards = deck.splice(0, Math.min(count, deck.length));\n  return drawnCards;\n}\n\n// Helper function to really end a turn (extracted from nextTurn logic)\nfunction reallyEndTurn(gameState, log) {\n  const current = gameState.current;\n\n  // Flag zurÃ¼cksetzen - Zug-Ende wird jetzt wirklich durchgefÃ¼hrt\n  gameState.isEndingTurn = false;\n\n  // âœ… Karte nachziehen am Ende eines Zugs (nur wenn NICHT \"pass\")\n  if (!gameState.passed[current]) {\n    const drawnCard = gameState.decks[current].shift();\n    if (drawnCard) {\n      gameState.hands[current].push(drawnCard);\n      log(`ğŸ”¥ Zug-Ende: +1 Karte gezogen (${drawnCard.name})`);\n    }\n  } else {\n    log(`â­ï¸ P${current} hat gepasst â€“ kein Nachziehen.`);\n  }\n\n  // Check if round should end\n  const shouldEndRound = checkRoundEnd(gameState);\n  if (shouldEndRound) {\n    log(`ğŸ Runde ${gameState.round} wird beendet (Zug-Ende).`);\n    return resolveRound(gameState, log);\n  }\n\n  // Spielerwechsel + AP reset\n  const newCurrent = current === 1 ? 2 : 1;\n  gameState.current = newCurrent;\n  gameState.actionPoints = {\n    ...gameState.actionPoints,\n    [newCurrent]: 2\n  };\n  gameState.passed = {\n    ...gameState.passed,\n    [newCurrent]: false\n  };\n\n  // Apply new start-of-turn hooks\n  applyStartOfTurnFlags(gameState, newCurrent, log);\n\n  // ğŸ”¥ CLUSTER 3: Auren-Flags beim Zugstart neu berechnen\n  recomputeAuraFlags(gameState);\n\n  // Reset turn-bezogener Flag-Nutzungen (handled in applyStartOfTurnFlags)\n\n  log(`ğŸ”„ Zug-Ende: Spieler ${newCurrent} ist am Zug (2 AP verfÃ¼gbar)`);\n  return gameState;\n}\n\n// Helper function to resolve round and start new one\nfunction resolveRound(gameState, log) {\n  // Calculate influence for both players\n  const p1Influence = sumGovernmentInfluenceWithAuras(gameState, 1);\n  const p2Influence = sumGovernmentInfluenceWithAuras(gameState, 2);\n  log(`ğŸ“Š Rundenauswertung: P1 ${p1Influence} Einfluss vs P2 ${p2Influence} Einfluss`);\n\n  // Determine winner\n  let roundWinner;\n  if (p1Influence > p2Influence) {\n    roundWinner = 1;\n    log(`ğŸ† Spieler 1 gewinnt die Runde! (${p1Influence} > ${p2Influence})`);\n  } else if (p2Influence > p1Influence) {\n    roundWinner = 2;\n    log(`ğŸ† Spieler 2 gewinnt die Runde! (${p2Influence} > ${p1Influence})`);\n  } else {\n    // Tie - current player wins\n    roundWinner = gameState.current;\n    log(`ğŸ¤ Unentschieden! Spieler ${roundWinner} gewinnt als aktiver Spieler.`);\n  }\n\n  // Collect all cards to move to discard\n  const cardsToDiscard = [...gameState.board[1].innen, ...gameState.board[1].aussen, ...gameState.board[2].innen, ...gameState.board[2].aussen, ...(gameState.permanentSlots[1].government ? [gameState.permanentSlots[1].government] : []), ...(gameState.permanentSlots[1].public ? [gameState.permanentSlots[1].public] : []), ...(gameState.permanentSlots[2].government ? [gameState.permanentSlots[2].government] : []), ...(gameState.permanentSlots[2].public ? [gameState.permanentSlots[2].public] : []), ...gameState.board[1].sofort, ...gameState.board[2].sofort];\n\n  // Draw 5 new cards for each player\n  const newP1Hand = drawCardsFromDeck(gameState, 1, 5);\n  const newP2Hand = drawCardsFromDeck(gameState, 2, 5);\n\n  // Calculate new rounds won\n  const newRoundsWon = {\n    ...gameState.roundsWon,\n    [roundWinner]: gameState.roundsWon[roundWinner] + 1\n  };\n\n  // Check if game should end (Best of 3: first to 2 wins)\n  const p1Wins = newRoundsWon[1];\n  const p2Wins = newRoundsWon[2];\n  if (p1Wins >= 2 || p2Wins >= 2) {\n    const gameWinner = p1Wins >= 2 ? 1 : 2;\n    log(`ğŸ†ğŸ‰ SPIEL BEENDET! Spieler ${gameWinner} gewinnt das Match! (${p1Wins}-${p2Wins})`);\n    log(`ğŸ”¥ Gesamtergebnis: Player ${gameWinner} ist der Sieger!`);\n\n    // Return final state with game winner\n    return {\n      ...gameState,\n      roundsWon: newRoundsWon,\n      gameWinner,\n      // Keep current board state for final display\n      passed: {\n        1: true,\n        2: true\n      } // Both passed to indicate game end\n    };\n  }\n\n  // Create new state for next round\n  const newState = {\n    ...gameState,\n    round: gameState.round + 1,\n    current: roundWinner,\n    // Winner starts next round\n    passed: {\n      1: false,\n      2: false\n    },\n    // Reset pass status\n    actionPoints: {\n      1: 2,\n      2: 2\n    },\n    // Reset AP\n    actionsUsed: {\n      1: 0,\n      2: 0\n    },\n    // Reset actions (kept for compatibility)\n    roundsWon: newRoundsWon,\n    effectFlags: {\n      1: createDefaultEffectFlags(),\n      2: createDefaultEffectFlags()\n    },\n    // Clear all board positions\n    board: emptyBoard(),\n    // Clear permanent slots\n    permanentSlots: {\n      1: {\n        government: null,\n        public: null,\n        initiativePermanent: null\n      },\n      2: {\n        government: null,\n        public: null,\n        initiativePermanent: null\n      }\n    },\n    // instantSlot wird nicht mehr verwendet - Sofort-Initiativen gehen in board[player].sofort\n    // New hands with 5 cards each\n    hands: {\n      1: newP1Hand,\n      2: newP2Hand\n    },\n    // Update decks (cards were removed during drawing)\n    decks: {\n      1: gameState.decks[1].slice(newP1Hand.length),\n      2: gameState.decks[2].slice(newP2Hand.length)\n    },\n    // Update discard pile\n    discard: [...gameState.discard, ...cardsToDiscard]\n  };\n  log(`ğŸ†• Runde ${newState.round} startet! Spieler ${roundWinner} beginnt. (Rundenstand: P1 ${newState.roundsWon[1]} - P2 ${newState.roundsWon[2]})`);\n  log(`ğŸƒ Beide Spieler erhalten 5 neue Handkarten.`);\n  return newState;\n}\nexport function useGameActions(gameState, setGameState, log, afterQueueResolved) {\n  _s();\n  // Visual effects context (spawn helpers)\n  // Use safe hook variant which returns null when no provider is present\n  const visualEffects = useVisualEffectsSafe();\n  // Helper: spawn lightweight UI visuals via window hooks (prototype only)\n  const spawnCardVisual = useCallback((card, stateOverride) => {\n    try {\n      var _card$uid, _card$uid2, _politicardDebug2;\n      if (!card) return;\n      console.debug('[GameActions] spawnCardVisual called', {\n        uid: (_card$uid = card.uid) !== null && _card$uid !== void 0 ? _card$uid : card.id,\n        name: card.name\n      });\n      const uid = (_card$uid2 = card.uid) !== null && _card$uid2 !== void 0 ? _card$uid2 : card.id;\n      // prefer VisualEffects context if available\n      const effectiveState = stateOverride || gameState;\n      if (visualEffects) {\n        var _politicardDebug;\n        // Prefer authoritative board-based slot centering (gov slots) using effectiveState\n        try {\n          let located = null;\n          for (const p of [1, 2]) {\n            const aussen = effectiveState.board[p].aussen || [];\n            const idxA = aussen.findIndex(c => {\n              var _c$uid, _card$uid3;\n              return ((_c$uid = c.uid) !== null && _c$uid !== void 0 ? _c$uid : c.id) === ((_card$uid3 = card.uid) !== null && _card$uid3 !== void 0 ? _card$uid3 : card.id);\n            });\n            if (idxA >= 0) {\n              located = {\n                player: p,\n                lane: 'aussen',\n                index: idxA\n              };\n              break;\n            }\n            const innen = effectiveState.board[p].innen || [];\n            const idxI = innen.findIndex(c => {\n              var _c$uid2, _card$uid4;\n              return ((_c$uid2 = c.uid) !== null && _c$uid2 !== void 0 ? _c$uid2 : c.id) === ((_card$uid4 = card.uid) !== null && _card$uid4 !== void 0 ? _card$uid4 : card.id);\n            });\n            if (idxI >= 0) {\n              located = {\n                player: p,\n                lane: 'innen',\n                index: idxI\n              };\n              break;\n            }\n          }\n          if (located && located.lane === 'aussen') {\n            var _card$uid5, _card$uid6;\n            const rects = getGovernmentRects(located.player === 1 ? 'player' : 'opponent');\n            const slot = rects[located.index] || rects[0] || {\n              x: 960 - 128,\n              y: 540 - 128,\n              w: 256,\n              h: 256\n            };\n            const cx_slot = slot.x + slot.w / 2;\n            const cy_slot = slot.y + slot.h / 2;\n            visualEffects.spawnParticles(cx_slot, cy_slot, 18);\n            visualEffects.spawnPop((_card$uid5 = card.uid) !== null && _card$uid5 !== void 0 ? _card$uid5 : card.id);\n            console.debug('[GameActions] spawnCardVisual particles/pop (gov slot)', {\n              uid: (_card$uid6 = card.uid) !== null && _card$uid6 !== void 0 ? _card$uid6 : card.id,\n              cx: cx_slot,\n              cy: cy_slot,\n              slot\n            });\n            const canvas = document.querySelector('canvas');\n            if (canvas) {\n              var _card$uid7, _card$uid8;\n              const rect = canvas.getBoundingClientRect();\n              const {\n                scale,\n                offsetX,\n                offsetY\n              } = getUiTransform(canvas.width, canvas.height);\n              // Apply offset first, then scale (matches canvas transform order)\n              const screenCx = rect.left + (cx_slot + offsetX) * scale;\n              const screenCy = rect.top + (cy_slot + offsetY) * scale;\n              // Use dedicated government slot GIF provided by user\n              // Use UI-based overlay spawner so we always align to canvas-derived\n              // pulsing slot fields exactly (handles scale+offset internally).\n              visualEffects.spawnGifOverlayUi({\n                id: (_card$uid7 = card.uid) !== null && _card$uid7 !== void 0 ? _card$uid7 : card.id,\n                cx: cx_slot,\n                cy: cy_slot,\n                w: 256,\n                h: 256,\n                src: slotGovGif,\n                duration: 700\n              });\n              console.debug('[GameActions] spawnCardVisual spawnGifOverlay (gov slot)', {\n                uid: (_card$uid8 = card.uid) !== null && _card$uid8 !== void 0 ? _card$uid8 : card.id,\n                screenCx,\n                screenCy,\n                src: slotGovGif\n              });\n            }\n            try {\n              var _card$uid9;\n              visualEffects.playAnimsRef.current.push({\n                uid: (_card$uid9 = card.uid) !== null && _card$uid9 !== void 0 ? _card$uid9 : card.id,\n                started: performance.now(),\n                duration: 420\n              });\n            } catch (e) {}\n            return;\n          }\n        } catch (e) {\n          console.debug('[GameActions] gov-slot centering failed, falling back', e);\n        }\n        // attempt to find a row_slot zone center via debug snapshot (avoid hand slots)\n        const zones = ((_politicardDebug = window.__politicardDebug) === null || _politicardDebug === void 0 ? void 0 : _politicardDebug.clickZones) || [];\n        const zone = zones.find(z => {\n          var _z$data$card$uid;\n          return z.data && z.data.type === 'row_slot' && z.data.card && ((_z$data$card$uid = z.data.card.uid) !== null && _z$data$card$uid !== void 0 ? _z$data$card$uid : z.data.card.id) === uid;\n        });\n        const cx = zone ? zone.x + (zone.w || 256) / 2 : 960;\n        const cy = zone ? zone.y + (zone.h || 256) / 2 : 540;\n        visualEffects.spawnParticles(cx, cy, 18);\n        visualEffects.spawnPop(uid);\n        console.debug('[GameActions] spawnCardVisual particles/pop (fallback)', {\n          uid,\n          cx,\n          cy,\n          zone\n        });\n        // Add play animation entry so canvas will fade-in the card itself\n        try {\n          visualEffects.playAnimsRef.current.push({\n            uid,\n            started: performance.now(),\n            duration: 420\n          });\n          console.debug('[GameActions] spawnCardVisual playAnimsRef push', uid);\n        } catch (e) {\n          console.debug('[GameActions] spawnCardVisual playAnimsRef push failed', e);\n        }\n        return;\n      }\n      // fallback to old window-based prototype\n      const zones = ((_politicardDebug2 = window.__politicardDebug) === null || _politicardDebug2 === void 0 ? void 0 : _politicardDebug2.clickZones) || [];\n      const zone = zones.find(z => {\n        var _z$data$card$uid2;\n        return z.data && z.data.card && ((_z$data$card$uid2 = z.data.card.uid) !== null && _z$data$card$uid2 !== void 0 ? _z$data$card$uid2 : z.data.card.id) === uid;\n      });\n      const cx = zone ? zone.x + (zone.w || 256) / 2 : 960;\n      const cy = zone ? zone.y + (zone.h || 256) / 2 : 540;\n      window.__pc_particles = window.__pc_particles || [];\n      for (let i = 0; i < 18; i++) {\n        window.__pc_particles.push({\n          start: performance.now(),\n          life: 600 + Math.random() * 400,\n          x: cx + (Math.random() - 0.5) * 40,\n          y: cy + (Math.random() - 0.5) * 40,\n          vx: (Math.random() - 0.5) * 6,\n          vy: -Math.random() * 6,\n          size: 3 + Math.random() * 5,\n          color: ['#ffd166', '#ff6b6b', '#4ade80'][Math.floor(Math.random() * 3)],\n          gravity: 0.12\n        });\n      }\n      window.__pc_pops = window.__pc_pops || [];\n      window.__pc_pops.push({\n        uid,\n        started: performance.now(),\n        duration: 420\n      });\n      // Fallback: add play anim entry to global when VisualEffects not available\n      window.__pc_play_anims = window.__pc_play_anims || [];\n      window.__pc_play_anims.push({\n        uid,\n        started: performance.now(),\n        duration: 420\n      });\n      // Also attempt to use provider fallback on window if available\n      try {\n        const wv = window.__pc_visual_effects;\n        if (wv && typeof wv.spawnGifOverlay === 'function') {\n          // Compute screen coords based on canvas if possible\n          const canvas = document.querySelector('canvas');\n          if (canvas) {\n            var _politicardDebug3;\n            const rect = canvas.getBoundingClientRect();\n            const ui = ((_politicardDebug3 = window.__politicardDebug) === null || _politicardDebug3 === void 0 ? void 0 : _politicardDebug3.uiTransform) || {\n              scale: 1,\n              offsetX: 0,\n              offsetY: 0\n            };\n            const screenCx = rect.left + (cx + ui.offsetX) * ui.scale;\n            const screenCy = rect.top + (cy + ui.offsetY) * ui.scale;\n            try {\n              if (typeof wv.spawnGifOverlayUi === 'function') {\n                // pass canvas-space coords so provider will align to UI\n                try {\n                  wv.spawnGifOverlayUi({\n                    id: uid,\n                    cx: cx,\n                    cy: cy,\n                    w: 256,\n                    h: 256,\n                    src: slotGovGif,\n                    duration: 700\n                  });\n                  console.debug('[GameActions] fallback window.__pc_visual_effects.spawnGifOverlayUi', uid);\n                } catch (e) {\n                  console.debug('[GameActions] fallback spawnGifOverlayUi failed', e);\n                }\n              } else {\n                wv.spawnGifOverlay({\n                  id: uid,\n                  cx: screenCx,\n                  cy: screenCy,\n                  w: 256 * ui.scale,\n                  h: 256 * ui.scale,\n                  src: slotGovGif,\n                  duration: 700\n                });\n                console.debug('[GameActions] fallback window.__pc_visual_effects.spawnGifOverlay', uid);\n              }\n            } catch (e) {\n              console.debug('[GameActions] fallback spawnGifOverlay failed', e);\n            }\n          }\n        }\n      } catch (e) {}\n    } catch (e) {\n      // swallow - non-critical\n    }\n  }, [visualEffects, gameState]);\n  // Guard against duplicate concurrent playCard calls for the same card UID\n  const playingUidRef = useRef(new Set());\n  // Listen for target selection & dice result (global events)\n  useEffect(() => {\n    const handlePickTarget = ev => {\n      var _ev$detail, _ev$detail2;\n      const uid = (_ev$detail = ev.detail) === null || _ev$detail === void 0 ? void 0 : _ev$detail.targetUid;\n      const player = (_ev$detail2 = ev.detail) === null || _ev$detail2 === void 0 ? void 0 : _ev$detail2.player;\n      if (!uid || !player) return;\n      try {\n        log(`ğŸ¯ Corruption: Ziel gewÃ¤hlt (uid=${uid})`);\n      } catch (e) {}\n    };\n\n    // Listener: when UI/modal requests a corruption roll, perform RNG and trigger visual dice\n    const handleRequestRoll = ev => {\n      try {\n        var _ev$detail3, _ev$detail4;\n        const player = (_ev$detail3 = ev.detail) === null || _ev$detail3 === void 0 ? void 0 : _ev$detail3.player;\n        const targetUid = (_ev$detail4 = ev.detail) === null || _ev$detail4 === void 0 ? void 0 : _ev$detail4.targetUid;\n        if (!player || !targetUid) return;\n        console.log('ğŸ² CORRUPTION: Requesting roll for player', player, 'target', targetUid);\n        // Quick visual fallback: dispatch an engine_dice_result immediately so the Dice3D shows a value\n        try {\n          const fallbackRoll = 1 + Math.floor(Math.random() * 6);\n          console.debug('ğŸ² CORRUPTION: dispatching fallback engine_dice_result', fallbackRoll);\n          window.dispatchEvent(new CustomEvent('pc:engine_dice_result', {\n            detail: {\n              roll: fallbackRoll,\n              player,\n              targetUid\n            }\n          }));\n        } catch (e) {\n          console.debug('ğŸ² CORRUPTION: fallback engine_dice_result dispatch failed', e);\n        }\n\n        // Enqueue the corruption resolve event - engine will also calculate roll and trigger 3D dice via resolver\n        setGameState(prev => {\n          const events = [];\n          events.push({\n            type: 'CORRUPTION_STEAL_GOV_RESOLVE',\n            player,\n            targetUid\n          });\n          // Process immediately\n          try {\n            resolveQueue(prev, events);\n          } catch (e) {\n            console.error('resolveQueue error in handleRequestRoll', e);\n          }\n          if (afterQueueResolved) afterQueueResolved();\n          return {\n            ...prev,\n            _effectQueue: []\n          };\n        });\n      } catch (e) {\n        logger.dbg('corruption request roll error', e);\n      }\n    };\n    window.addEventListener('pc:corruption_pick_target', handlePickTarget);\n    window.addEventListener('pc:corruption_request_roll', handleRequestRoll);\n    return () => {\n      window.removeEventListener('pc:corruption_pick_target', handlePickTarget);\n      window.removeEventListener('pc:corruption_request_roll', handleRequestRoll);\n    };\n  }, [setGameState, afterQueueResolved, log]);\n  const startMatchWithDecks = useCallback((p1DeckEntries, p2DeckEntries) => {\n    const p1Cards = buildDeckFromEntries(p1DeckEntries);\n    const p2Cards = buildDeckFromEntries(p2DeckEntries);\n\n    // Debug: Log deck composition with detailed tag analysis\n    const p1NgoCarten = p1Cards.filter(c => c.tag === 'NGO');\n    const p1PlatformCards = p1Cards.filter(c => c.tag === 'Plattform');\n    const p1JoschaCards = p1Cards.filter(c => c.effect === 'ngo_boost');\n    const p1PublicCards = p1Cards.filter(c => c.kind === 'spec' && c.type === 'Ã–ffentlichkeitskarte');\n    log(`ğŸ” DECK DEBUG P1: ${p1Cards.length} Karten total`);\n    log(`ğŸ§ª P1 Public Cards: ${p1PublicCards.map(c => `${c.name}${c.tag ? `[${c.tag}]` : ''}`).join(', ')}`);\n    log(`ğŸŒ± P1 NGO-Karten: ${p1NgoCarten.length > 0 ? p1NgoCarten.map(c => c.name).join(', ') : 'Keine'}`);\n    log(`ğŸ’» P1 Plattform-Karten: ${p1PlatformCards.length > 0 ? p1PlatformCards.map(c => c.name).join(', ') : 'Keine'}`);\n    log(`ğŸ¯ JOSCHKA FISCHER: ${p1JoschaCards.length > 0 ? 'âœ… IM DECK' : 'âŒ NICHT IM DECK'}`);\n    const d1 = [...p1Cards];\n    const d2 = [...p2Cards];\n    const h1 = d1.splice(0, Math.min(5, d1.length));\n    const h2 = d2.splice(0, Math.min(5, d2.length));\n    setGameState(prev => ({\n      ...prev,\n      round: 1,\n      current: 1,\n      passed: {\n        1: false,\n        2: false\n      },\n      decks: {\n        1: d1,\n        2: d2\n      },\n      hands: {\n        1: h1,\n        2: h2\n      },\n      board: {\n        1: {\n          innen: [],\n          aussen: [],\n          sofort: []\n        },\n        2: {\n          innen: [],\n          aussen: [],\n          sofort: []\n        }\n      },\n      traps: {\n        1: [],\n        2: []\n      },\n      permanentSlots: {\n        1: {\n          government: null,\n          public: null,\n          initiativePermanent: null\n        },\n        2: {\n          government: null,\n          public: null,\n          initiativePermanent: null\n        }\n      },\n      // instantSlot wird nicht mehr verwendet - Sofort-Initiativen gehen in board[player].sofort\n      discard: [],\n      shields: new Set(),\n      // Set<UID>\n      effectFlags: {\n        1: createDefaultEffectFlags(),\n        2: createDefaultEffectFlags()\n      },\n      actionsUsed: {\n        1: 0,\n        2: 0\n      },\n      log: [`Match gestartet. P1 und P2 erhalten je ${h1.length}/${h2.length} Startkarten.`, `ğŸ” DECK DEBUG P1: ${p1Cards.length} Karten total`, `ğŸ§ª P1 Public Cards: ${p1PublicCards.map(c => `${c.name}${c.tag ? `[${c.tag}]` : ''}`).join(', ')}`, `ğŸŒ± P1 NGO-Karten: ${p1NgoCarten.length > 0 ? p1NgoCarten.map(c => c.name).join(', ') : 'Keine'}`, `ğŸ’» P1 Plattform-Karten: ${p1PlatformCards.length > 0 ? p1PlatformCards.map(c => c.name).join(', ') : 'Keine'}`, `ğŸ¯ JOSCHKA FISCHER: ${p1JoschaCards.length > 0 ? 'âœ… IM DECK' : 'âŒ NICHT IM DECK'}`, `ğŸ“‹ INITIAL BOARD P1: Regierung=[] | Ã–ffentlichkeit=[]`, `ğŸ“‹ INITIAL BOARD P2: Regierung=[] | Ã–ffentlichkeit=[]`, `ğŸ  PERMANENT SLOTS: Alle leer`],\n      activeRefresh: {\n        1: 0,\n        2: 0\n      },\n      // preserve any aiEnabled flags set before calling this\n      aiEnabled: prev.aiEnabled || {\n        1: false,\n        2: false\n      }\n    }));\n  }, [gameState, setGameState, log]);\n  const startMatchVsAI = useCallback((p1DeckEntries, presetKey = 'AUTORITAERER_REALIST') => {\n    const p2DeckEntries = PRESET_DECKS[presetKey];\n    // Enable AI for P2 first so nextTurn/auto-run sees the flag immediately\n    setGameState(prev => ({\n      ...prev,\n      aiEnabled: {\n        ...(prev.aiEnabled || {\n          1: false,\n          2: false\n        }),\n        2: true\n      }\n    }));\n    log('ğŸ”§ AI aktiviert fÃ¼r Spieler 2');\n    startMatchWithDecks(p1DeckEntries, p2DeckEntries);\n  }, [startMatchWithDecks]);\n  const playCard = useCallback((player, handIndex, lane) => {\n    logger.info(`playCard START P${player} idx=${handIndex}`);\n    setGameState(prev => {\n      // Test-only baseline fix â€“ ensures AP=5 at game start inside test runner\n      ensureTestBaselineAP(prev);\n\n      // Validate input parameters\n      if (prev.current !== player) {\n        log(`âŒ ERROR: Not player turn - Current: ${prev.current}, Attempted: ${player}`);\n        logger.warn(`playCard abort: wrong turn`);\n        return prev;\n      }\n      const hand = prev.hands[player];\n      if (handIndex < 0 || handIndex >= hand.length) {\n        log(`âŒ ERROR: Invalid hand index - Index: ${handIndex}, Hand length: ${hand.length}`);\n        return prev;\n      }\n\n      // Debug: Log current hand contents with detailed tag info\n      log(`ğŸ” HAND DEBUG P${player}: ${hand.map((c, i) => `${i}:${c.name}${c.tag ? `[${c.tag}]` : ''}`).join(', ')}`);\n      const ngoCards = hand.filter(c => c.tag === 'NGO');\n      const platformCards = hand.filter(c => c.tag === 'Plattform');\n      if (ngoCards.length > 0) {\n        log(`ğŸŒ± NGO-Karten in Hand P${player}: ${ngoCards.map(c => c.name).join(', ')}`);\n      }\n      if (platformCards.length > 0) {\n        log(`ğŸ’» Plattform-Karten in Hand P${player}: ${platformCards.map(c => c.name).join(', ')}`);\n      }\n      const selectedCard = hand[handIndex];\n      if (!canPlayCard(prev, player, selectedCard)) {\n        log('ğŸš« Kann Karte nicht spielen (keine AP verfÃ¼gbar).');\n        return prev;\n      }\n      const {\n        cost\n      } = getNetApCost(prev, player, selectedCard);\n      const prevAp = prev.actionPoints[player];\n      const newState = {\n        ...prev\n      };\n\n      // Simplified AP system: All cards cost exactly 1 AP\n      newState.actionPoints[player] = Math.max(0, newState.actionPoints[player] - cost);\n      log(`ğŸ’³ Kosten verbucht: AP ${prevAp}â†’${newState.actionPoints[player]}`);\n\n      // Flags KONSUMIEREN (einheitlich, NUR HIER!)\n      ensureFlags(newState, player);\n      const ef = newState.effectFlags[player];\n\n      // Simplified AP system: No refunds or discounts\n      // All cards cost exactly 1 AP\n\n      // Remove card from hand\n      const newHand = [...newState.hands[player]];\n      const [playedCard] = newHand.splice(handIndex, 1);\n      newState.hands = {\n        ...newState.hands,\n        [player]: newHand\n      };\n\n      // Prevent double-playing the same UID concurrently\n      if (playedCard.uid) {\n        if (playingUidRef.current.has(playedCard.uid)) {\n          log(`âš ï¸ Duplicate play prevented for UID ${playedCard.uid}`);\n          return prev;\n        }\n        playingUidRef.current.add(playedCard.uid);\n      }\n\n      // ğŸ”§ CLUSTER 3 DEBUG: Zeige jede gespielte Karte\n      log(`ğŸ”§ CLUSTER 3 GLOBAL DEBUG: P${player} spielt ${playedCard.name} (${playedCard.kind}) - Type: ${playedCard.type || 'KEIN TYPE'}`);\n\n      // ğŸ”§ CLUSTER 3 DEBUG: Zeige aktuelles Board\n      const currentBoard = newState.board[player];\n      const publicCardsOnBoard = currentBoard.innen.filter(card => card.kind === 'spec');\n      log(`ğŸ”§ CLUSTER 3 GLOBAL DEBUG: Ã–ffentlichkeitskarten auf dem Feld: ${publicCardsOnBoard.map(c => c.name).join(', ')}`);\n\n      // Jennifer Doudna check removed - not needed for current game logic\n\n      // Handle different card types\n      if (playedCard.kind === 'pol') {\n        const polCard = playedCard;\n        const targetLane = lane || (polCard.tag === 'Staatsoberhaupt' || polCard.tag === 'Regierungschef' || polCard.tag === 'Diplomat' ? 'aussen' : 'innen');\n        if (newState.board[player][targetLane].length >= 5) {\n          log(`âŒ ERROR: Lane full - Lane: ${targetLane}, Current: ${newState.board[player][targetLane].length}/5`);\n          return prev;\n        }\n\n        // Add to board (immutable clone to avoid accidental double references)\n        const laneArray = [...newState.board[player][targetLane], playedCard];\n        const playerBoardCloned = {\n          ...newState.board[player],\n          [targetLane]: laneArray\n        };\n        newState.board = {\n          ...newState.board,\n          [player]: playerBoardCloned\n        };\n\n        // VISUAL: spawn GIF overlay centered over the government slot icon when placing a government card\n        try {\n          if (targetLane === 'aussen') {\n            const rects = getGovernmentRects(player === 1 ? 'player' : 'opponent');\n            const slotIndex = newState.board[player].aussen.length - 1;\n            const slotRect = rects[slotIndex] || rects[0] || {\n              x: 960 - 128,\n              y: 540 - 128,\n              w: 256,\n              h: 256\n            };\n            const cx = slotRect.x + slotRect.w / 2;\n            const cy = slotRect.y + slotRect.h / 2;\n\n            // particles/pop in canvas coords\n            try {\n              visualEffects === null || visualEffects === void 0 ? void 0 : visualEffects.spawnParticles(cx, cy, 18);\n            } catch (e) {}\n            try {\n              var _playedCard$uid;\n              visualEffects === null || visualEffects === void 0 ? void 0 : visualEffects.spawnPop((_playedCard$uid = playedCard.uid) !== null && _playedCard$uid !== void 0 ? _playedCard$uid : playedCard.id);\n            } catch (e) {}\n\n            // compute screen coords and spawn 300x300 overlay\n            const canvas = document.querySelector('canvas');\n            if (canvas) {\n              // Prefer reliable canvas spritesheet animation directly on the target slot\n              try {\n                const key = `${player}.${'aussen'}.${slotIndex}`;\n                const trig = window.__pc_triggerGovAnim || window.pc_triggerGovAnim;\n                if (typeof trig === 'function') trig(key);\n              } catch (e) {}\n              // Only fade-in anim\n              try {\n                var _visualEffects$playAn, _visualEffects$playAn2, _playedCard$uid2;\n                visualEffects === null || visualEffects === void 0 ? void 0 : (_visualEffects$playAn = visualEffects.playAnimsRef) === null || _visualEffects$playAn === void 0 ? void 0 : (_visualEffects$playAn2 = _visualEffects$playAn.current) === null || _visualEffects$playAn2 === void 0 ? void 0 : _visualEffects$playAn2.push({\n                  uid: (_playedCard$uid2 = playedCard.uid) !== null && _playedCard$uid2 !== void 0 ? _playedCard$uid2 : playedCard.id,\n                  started: performance.now(),\n                  duration: 420\n                });\n              } catch (e) {}\n            }\n          }\n        } catch (e) {\n          console.debug('[GameActions] GOV overlay failed', e);\n        }\n        log(`ğŸƒ Player ${player}: ${playedCard.name} gespielt in ${targetLane === 'aussen' ? 'Regierung' : 'Ã–ffentlichkeit'}`);\n\n        // 3) Nachdem die Karte gelegt wurde: gegnerische Traps prÃ¼fen\n        applyTrapsOnCardPlayed(newState, player, playedCard, event => {\n          if (!newState._effectQueue) newState._effectQueue = [];\n          newState._effectQueue.push(event);\n        }, log);\n\n        // ğŸ‘‰ Erst JETZT Auren anwenden (damit +2 Basis erhalten bleibt)\n        applyAurasForPlayer(newState, player, log);\n\n        // 6) Karteneffekte enqueuen + Queue auflÃ¶sen\n        triggerCardEffects(newState, player, playedCard);\n        // UI visual: particle burst + pop scale for played card (prototype hook)\n        try {\n          spawnCardVisual(playedCard, newState);\n        } catch (e) {}\n        // Migration Helper verwenden\n        migrateLegacyQueue(newState);\n        // Nur noch _effectQueue verwenden\n        if (newState._effectQueue && newState._effectQueue.length > 0) {\n          try {\n            log(`DEBUG: about to resolve queue (pol play) -> ${JSON.stringify(newState._effectQueue.map(e => ({\n              type: e.type,\n              amount: e.amount,\n              msg: e.msg\n            })).slice(0, 50))}`);\n          } catch (e) {}\n          log(`DEBUG AP before resolve (pol play): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n          resolveQueue(newState, newState._effectQueue);\n          newState._effectQueue = [];\n          // Nach Queue-AuflÃ¶sung: Hand-Arrays immutabel neu zuweisen\n          afterQueueResolved === null || afterQueueResolved === void 0 ? void 0 : afterQueueResolved();\n          log(`DEBUG AP after resolve (pol play): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n        }\n\n        // Release playing UID after queue resolved\n        if (playedCard.uid) playingUidRef.current.delete(playedCard.uid);\n\n        // Check for trap triggers\n        applyTrapsOnCardPlayed(newState, player, playedCard, e => (newState._effectQueue ??= []).push(e), m => (newState._effectQueue ??= []).push({\n          type: 'LOG',\n          msg: m\n        }));\n\n        // ğŸ”¥ ROMAN ABRAMOVICH EFFEKT: Wenn Regierungskarte mit Einfluss â‰¤5 gespielt wird\n        if (playedCard.kind === 'pol' && playedCard.influence <= 5) {\n          const opponent = player === 1 ? 2 : 1;\n          const opponentBoard = newState.board[opponent];\n          const romanAbramovich = opponentBoard.innen.find(card => card.kind === 'spec' && card.name === 'Roman Abramovich');\n          if (romanAbramovich) {\n            // Ziehe eine Karte fÃ¼r den Gegner\n            if (newState.decks[opponent].length > 0) {\n              const drawnCard = newState.decks[opponent].shift();\n              if (drawnCard) {\n                newState.hands[opponent].push(drawnCard);\n                log(`ğŸ”¥ ROMAN ABRAMOVICH EFFEKT: P${opponent} zieht 1 Karte (${drawnCard.name}) - Regierungskarte mit Einfluss â‰¤5 gespielt`);\n              }\n            }\n          }\n        }\n\n        // ğŸ” BOARD DEBUG: Zeige aktuelles Board nach dem Spielen\n        const currentBoard = newState.board[player];\n        const regierungKarten = currentBoard.aussen.map(c => `${c.name}[${c.kind === 'pol' ? c.influence + 'I' : 'S'}]`);\n        const Ã¶ffentlichkeitKarten = currentBoard.innen.map(c => `${c.name}[${c.kind === 'spec' ? c.tag || 'S' : 'P'}]`);\n        log(`ğŸ“‹ P${player} BOARD: Regierung=[${regierungKarten.join(', ')}] | Ã–ffentlichkeit=[${Ã¶ffentlichkeitKarten.join(', ')}]`);\n\n        // ğŸ”¥ JOSCHKA FISCHER NGO-EFFEKT: Jetzt als kontinuierlicher Aura-Effekt in sumRowWithAuras implementiert\n        log(`ğŸ” DEBUG: Karte gespielt - Name: ${playedCard.name}, Tag: ${playedCard.tag || 'Kein Tag'}, Lane: ${targetLane}, Kind: ${playedCard.kind}`);\n        if (playedCard.tag === 'NGO') {\n          log(`ğŸ” NGO-Karte gespielt: ${playedCard.name} [NGO] - Kontinuierliche Aura-Effekte werden bei Rundenauswertung berechnet`);\n\n          // ğŸ¯ SOFORTIGE SYNERGIE-PRÃœFUNG: Joschka Fischer + NGO\n          const joschaFischer = currentBoard.aussen.find(card => card.kind === 'pol' && card.effect === 'ngo_boost');\n          if (joschaFischer) {\n            log(`ğŸ”¥ğŸ”¥ğŸ”¥ SYNERGIE AKTIVIERT! ğŸ”¥ğŸ”¥ğŸ”¥ Joschka Fischer + ${playedCard.name}[NGO] â†’ +1 Einfluss bei Rundenauswertung`);\n          }\n        }\n      } else if (playedCard.kind === 'spec') {\n        var _type, _type2;\n        const specCard = playedCard;\n        const typeStr = String(specCard.type || '').toLowerCase();\n        const isInitiative = /initiative/.test(typeStr); // matcht \"Initiative\", \"Sofort-Initiative\", etc.\n\n        // 1) Falls es eine \"Systemrelevant\" ist (sofortiger Buff auf letzte eigene Regierungskarte)\n        if (playedCard.kind === 'spec' && (_type = playedCard.type) !== null && _type !== void 0 && _type.toLowerCase().includes('systemrelevant')) {\n          const ownBoard = newState.board[player];\n          const candidates = [...ownBoard.aussen, ...ownBoard.innen].filter(c => c.kind === 'pol');\n          const target = candidates[candidates.length - 1]; // letzte eigene Regierungskarte\n          if (target) {\n            target.protected = true;\n            log(`ğŸ›¡ï¸ ${target.name} erhÃ¤lt einmaligen Schutz.`);\n          } else {\n            log('ğŸ›ˆ Systemrelevant: Keine eigene Regierungskarte im Spiel â€“ Effekt verpufft.');\n          }\n          // danach die Spezialkarte normal entsorgen\n          newState.discard.push(playedCard);\n          return newState;\n        }\n\n        // 1) Dauerhaft-Initiative (Ongoing)\n        if (typeStr.includes('dauerhaft')) {\n          // Slot-Mapping: Dauerhaft-Initiativen â†’ map to permanentSlots.government or .public\n          // Prefer explicit metadata on the card, fallback to tag-based heuristic, default to 'government'\n          const preferredSlot = specCard.permanentSlot || ((specCard.tags || []).includes('Public') ? 'public' : 'government');\n          if (!newState.permanentSlots[player][preferredSlot]) {\n            // ensure card is stored as a shallow clone to avoid accidental shared references\n            newState.permanentSlots[player] = {\n              ...newState.permanentSlots[player],\n              [preferredSlot]: {\n                ...playedCard\n              }\n            };\n            log(`P${player} spielt ${playedCard.name} als Dauerhafte Initiative (Slot: ${preferredSlot})`);\n          } else {\n            var _newState$permanentSl;\n            log(`âš ï¸ WARN: Slot occupied - Slot ${preferredSlot} already has ${(_newState$permanentSl = newState.permanentSlots[player][preferredSlot]) === null || _newState$permanentSl === void 0 ? void 0 : _newState$permanentSl.name}`);\n            // Return the card to hand and refund AP as graceful fallback\n            newState.hands[player] = [...newState.hands[player], playedCard];\n            newState.actionPoints[player] += cost;\n            return newState;\n          }\n\n          // 6) Karteneffekte enqueuen + Queue auflÃ¶sen\n          triggerCardEffects(newState, player, playedCard);\n          // Migration Helper verwenden\n          migrateLegacyQueue(newState);\n          // Nur noch _effectQueue verwenden\n          if (newState._effectQueue && newState._effectQueue.length > 0) {\n            try {\n              log(`DEBUG: about to resolve queue (spec ongoing) -> ${JSON.stringify(newState._effectQueue.map(e => ({\n                type: e.type,\n                amount: e.amount,\n                msg: e.msg\n              })).slice(0, 50))}`);\n            } catch (e) {}\n            log(`DEBUG AP before resolve (spec ongoing): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n            resolveQueue(newState, newState._effectQueue);\n            newState._effectQueue = [];\n            // Nach Queue-AuflÃ¶sung: Hand-Arrays immutabel neu zuweisen\n            afterQueueResolved === null || afterQueueResolved === void 0 ? void 0 : afterQueueResolved();\n            log(`DEBUG AP after resolve (spec ongoing): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n          }\n\n          // Check for trap triggers\n          applyTrapsOnCardPlayed(newState, player, playedCard, e => (newState._effectQueue ??= []).push(e), m => (newState._effectQueue ??= []).push({\n            type: 'LOG',\n            msg: m\n          }));\n          return newState;\n        }\n\n        // 2) Sofort-/Sofort-Initiativen (Instant)\n        if (isInitiative) {\n          if (!specCard.effectKey) {\n            log(`âŒ Initiative ohne effectKey: ${specCard.name}`);\n          } else {\n            log(`ğŸ§© INIT: ${specCard.name} [${String(specCard.effectKey)}] gespielt`);\n          }\n\n          // ğŸ”§ NEU: Sofort-Initiativen werden in das sofort Array gelegt statt sofort aktiviert\n          if (typeStr.includes('sofort')) {\n            // PrÃ¼fe ob bereits eine Sofort-Initiative im Slot liegt\n            if (newState.board[player].sofort.length > 0) {\n              var _newState$board$playe;\n              log(`âŒ ERROR: Sofort-Initiative-Slot bereits besetzt - ${(_newState$board$playe = newState.board[player].sofort[0]) === null || _newState$board$playe === void 0 ? void 0 : _newState$board$playe.name} muss erst aktiviert werden`);\n              // Karte zurÃ¼ck in die Hand\n              newState.hands[player] = [...newState.hands[player], playedCard];\n              // AP zurÃ¼ckgeben\n              newState.actionPoints[player] += cost;\n              // AP zurÃ¼ckgegeben, keine Aktion rÃ¼ckgÃ¤ngig zu machen\n              return newState;\n            }\n\n            // Sofort-Initiative in das sofort Array legen\n            newState.board[player].sofort = [playedCard];\n            log(`ğŸ¯ P${player} legt ${playedCard.name} in Sofort-Initiative-Slot (kann spÃ¤ter aktiviert werden)`);\n\n            // Sofort-Initiativen: auf Board.sofort legen (nicht direkt entsorgen)\n            if (!newState._effectQueue) newState._effectQueue = [];\n            newState._effectQueue.push({\n              type: 'LOG',\n              msg: `ğŸ”” Sofort-Initiative bereit: ${playedCard.name} (zum Aktivieren anklicken oder Taste 'A')`\n            });\n            return newState;\n          }\n\n          // Dauerhaft-Initiativen werden weiterhin sofort aktiviert\n          // Initiative in den Ablagestapel\n          newState.discard = [...newState.discard, playedCard];\n          log(`P${player} spielt Initiative: ${playedCard.name}`);\n\n          // 6) Karteneffekte enqueuen + Queue auflÃ¶sen\n          console.log('ğŸ”¥ ABOUT TO TRIGGER CARD EFFECTS (INITIATIVE):', playedCard.name, 'effectKey:', playedCard.effectKey);\n          triggerCardEffects(newState, player, playedCard);\n          // Migration Helper verwenden\n          migrateLegacyQueue(newState);\n          // Nur noch _effectQueue verwenden\n          if (newState._effectQueue && newState._effectQueue.length > 0) {\n            resolveQueue(newState, newState._effectQueue);\n            newState._effectQueue = [];\n            // Nach Queue-AuflÃ¶sung: Hand-Arrays immutabel neu zuweisen\n            afterQueueResolved === null || afterQueueResolved === void 0 ? void 0 : afterQueueResolved();\n          }\n\n          // Check for trap triggers\n          applyTrapsOnCardPlayed(newState, player, playedCard, e => (newState._effectQueue ??= []).push(e), m => (newState._effectQueue ??= []).push({\n            type: 'LOG',\n            msg: m\n          }));\n\n          // ğŸ”¥ CLUSTER 3: Auren-Flags neu berechnen (nach Kartenspielen)\n          recomputeAuraFlags(newState);\n\n          // ğŸ”¥ CLUSTER 3: Ai Weiwei Bonus wird bei Aktivierung angewendet (nicht beim Spielen)\n\n          // ğŸ”¥ PASSIVE EFFEKTE NACH INITIATIVE: Mark Zuckerberg & Sam Altman\n          // Diese Effekte werden jetzt Ã¼ber INITIATIVE_ACTIVATED Event + Board-Check gehandhabt\n          // Keine direkten Flag-Mutationen mehr - alles Ã¼ber Events\n\n          return newState;\n        }\n\n        // 3) Ã–ffentlichkeit (Public)\n        if (typeStr === 'Ã¶ffentlichkeitskarte' || typeStr === 'oeffentlichkeitskarte' || typeStr === 'Ã¶ffentlichkeit' || typeStr === 'public') {\n          if (newState.board[player].innen.length < 5) {\n            const innenArray = [...newState.board[player].innen, playedCard];\n            const playerBoardCloned = {\n              ...newState.board[player],\n              innen: innenArray\n            };\n            newState.board = {\n              ...newState.board,\n              [player]: playerBoardCloned\n            };\n            log(`P${player} spielt ${playedCard.name} in Ã–ffentlichkeit`);\n\n            // Sofort Auren prÃ¼fen (z.B. JF +1, wenn JF schon liegt)\n            applyAurasForPlayer(newState, player, log);\n\n            // 6) Karteneffekte enqueuen + Queue auflÃ¶sen\n            triggerCardEffects(newState, player, playedCard);\n            // Migration Helper verwenden\n            migrateLegacyQueue(newState);\n            if (newState._effectQueue && newState._effectQueue.length > 0) {\n              resolveQueue(newState, newState._effectQueue);\n              newState._effectQueue = [];\n              // Nach Queue-AuflÃ¶sung: Hand-Arrays immutabel neu zuweisen\n              afterQueueResolved === null || afterQueueResolved === void 0 ? void 0 : afterQueueResolved();\n            }\n\n            // Check for trap triggers\n            applyTrapsOnCardPlayed(newState, player, playedCard, e => (newState._effectQueue ??= []).push(e), m => (newState._effectQueue ??= []).push({\n              type: 'LOG',\n              msg: m\n            }));\n\n            // ğŸ”¥ PUBLIC CARD EFFECTS - Passive effects when played\n\n            // Helper function to draw a card for the player\n            const drawCardForPlayer = cardName => {\n              if (newState.decks[player].length > 0) {\n                const drawnCard = newState.decks[player].shift();\n                if (drawnCard) {\n                  newState.hands[player].push(drawnCard);\n                  log(`ğŸ”¥ ${cardName.toUpperCase()} EFFEKT: +1 Karte gezogen (${drawnCard.name})`);\n                  return true;\n                }\n              }\n              return false;\n            };\n            if (specCard.name === 'Elon Musk') {\n              // Effect: \"Ziehe 1 Karte. Deine erste Initiative pro Runde kostet 1 Aktionspunkt weniger.\"\n              drawCardForPlayer('Elon Musk');\n              // ğŸ”¥ QUEUE-SYSTEM: Erste Initiative pro Runde â†’ Refund wird Ã¼ber triggerCardEffects gehandhabt\n            } else if (specCard.name === 'Bill Gates') {\n              // Effect: \"Ziehe 1 Karte. Deine nÃ¤chste Initiative kostet 1 Aktionspunkt weniger.\"\n              drawCardForPlayer('Bill Gates');\n              // ğŸ”¥ QUEUE-SYSTEM: NÃ¤chste Initiative â†’ Refund wird Ã¼ber triggerCardEffects gehandhabt\n            } else if (specCard.name === 'Jeff Bezos') {\n              // Effect: \"Ziehe 1 Karte beim Ausspielen. Wenn eine Plattform liegt: +1 Aktionspunkt.\"\n              drawCardForPlayer('Jeff Bezos');\n              const hasPlatform = newState.board[player].innen.some(c => c.kind === 'spec' && c.tag === 'Plattform');\n              if (hasPlatform) {\n                newState.actionPoints[player] += 1;\n                log(`ğŸ”¥ JEFF BEZOS: +1 AP durch Plattform-Synergie! (${newState.actionPoints[player] - 1} â†’ ${newState.actionPoints[player]})`);\n              }\n            } else if (specCard.name === 'Warren Buffett') {\n              // Effect: \"Ziehe 1 Karte. Bei einer Wirtschafts-Initiative: +1 Effekt.\"\n              drawCardForPlayer('Warren Buffett');\n              // TODO: Implement \"Wirtschafts-Initiative +1 Effect\" logic\n              log(`ğŸ“Š WARREN BUFFETT: Bei Wirtschafts-Initiativen +1 Effekt! (TODO: Implementierung)`);\n            } else if (specCard.name === 'Gautam Adani') {\n              // Effect: \"Ziehe 1 Karte. Bei einer Infrastruktur-Initiative: +1 Effekt.\"\n              drawCardForPlayer('Gautam Adani');\n              // TODO: Implement \"Infrastruktur-Initiative +1 Effect\" logic\n              log(`ğŸ“Š GAUTAM ADANI: Bei Infrastruktur-Initiativen +1 Effekt! (TODO: Implementierung)`);\n            } else if (specCard.name === 'Zhang Yiming') {\n              // Effect: \"Ziehe 1 Karte. Bei Medien auf dem Feld: -1 Aktionspunkt auf deine nÃ¤chste Initiative.\"\n              drawCardForPlayer('Zhang Yiming');\n              const hasMedia = newState.board[player].innen.some(c => c.kind === 'spec' && c.tag === 'Medien');\n              if (hasMedia) {\n                // TODO: Implement \"nÃ¤chste Initiative -1 AP\" logic\n                log(`ğŸ”¥ ZHANG YIMING: NÃ¤chste Initiative kostet 1 AP weniger durch Medien-Synergie! (TODO: Implementierung)`);\n              }\n            } else if (specCard.name === 'George Soros') {\n              // Effect: \"+1 Aktionspunkt wenn der Gegner eine autoritÃ¤re Regierungskarte hat.\"\n              const opponent = player === 1 ? 2 : 1;\n              const hasAuthoritarianCard = newState.board[opponent].aussen.some(card => {\n                const polCard = card;\n                return polCard.tag === 'Staatsoberhaupt' && polCard.influence >= 8; // High influence leaders\n              });\n              if (hasAuthoritarianCard) {\n                newState.actionPoints[player] += 1;\n                log(`ğŸ”¥ GEORGE SOROS EFFEKT: +1 AP durch autoritÃ¤re Regierung des Gegners!`);\n                log(`ğŸ“Š SOROS: Aktionspunkte ${newState.actionPoints[player] - 1} â†’ ${newState.actionPoints[player]}`);\n              } else {\n                log(`ğŸ’­ George Soros: Keine autoritÃ¤ren Karten beim Gegner - Effekt nicht ausgelÃ¶st`);\n              }\n            }\n\n            // ğŸ”— NGO-Synergie: Wenn eine NGO gelegt wird und Joschka Fischer liegt, erhÃ¤lt P${player} +1 Einfluss (Rundenauswertung)\n            if (specCard.tag === 'NGO') {\n              const hasJoschka = newState.board[player].aussen.some(c => c.kind === 'pol' && c.name === 'Joschka Fischer' && !c.deactivated);\n              if (hasJoschka) {\n                log(`ğŸ”¥ğŸ”¥ğŸ”¥ SYNERGIE AKTIVIERT! ğŸ”¥ğŸ”¥ğŸ”¥ Joschka Fischer + ${playedCard.name}[NGO] â†’ +1 Einfluss bei Rundenauswertung`);\n              }\n            }\n          } else {\n            log(`âŒ ERROR: Lane full - Ã–ffentlichkeit ist voll (5/5)`);\n          }\n\n          // Simplified AP system: No refunds\n          return newState;\n        }\n\n        // 4) Default: Traps/Interventions\n        // Falls Trap-Karte gelegt wird\n        if (playedCard.kind === 'spec' && (_type2 = playedCard.type) !== null && _type2 !== void 0 && _type2.toLowerCase().includes('trap')) {\n          registerTrap(newState, player, playedCard.key || playedCard.name.toLowerCase().replace(/[- ]/g, '_'));\n          // NICHT sofort checken â€“ sie wartet auf den Gegner\n          return newState;\n        }\n        newState.traps[player] = [...newState.traps[player], playedCard];\n        log(`P${player} spielt ${playedCard.name} als ${specCard.type}`);\n\n        // 6) Karteneffekte enqueuen + Queue auflÃ¶sen\n        console.log('ğŸ”¥ ABOUT TO TRIGGER CARD EFFECTS:', playedCard.name, 'effectKey:', playedCard.effectKey);\n        triggerCardEffects(newState, player, playedCard);\n        // Migration Helper verwenden\n        migrateLegacyQueue(newState);\n        // Nur noch _effectQueue verwenden\n        if (newState._effectQueue && newState._effectQueue.length > 0) {\n          try {\n            log(`DEBUG: about to resolve queue (spec instant) -> ${JSON.stringify(newState._effectQueue.map(e => ({\n              type: e.type,\n              amount: e.amount,\n              msg: e.msg\n            })).slice(0, 50))}`);\n          } catch (e) {}\n          log(`DEBUG AP before resolve (spec instant): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n          resolveQueue(newState, newState._effectQueue);\n          newState._effectQueue = [];\n          // Nach Queue-AuflÃ¶sung: Hand-Arrays immutabel neu zuweisen\n          afterQueueResolved === null || afterQueueResolved === void 0 ? void 0 : afterQueueResolved();\n          log(`DEBUG AP after resolve (spec instant): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n        }\n\n        // Check for trap triggers\n        applyTrapsOnCardPlayed(newState, player, playedCard, e => (newState._effectQueue ??= []).push(e), m => (newState._effectQueue ??= []).push({\n          type: 'LOG',\n          msg: m\n        }));\n\n        // Simplified AP system: No refunds\n        return newState;\n      }\n\n      // 6) Karteneffekte enqueuen + Queue auflÃ¶sen (fallback fÃ¼r unbekannte Kartentypen)\n      triggerCardEffects(newState, player, selectedCard);\n      // Migration Helper verwenden\n      migrateLegacyQueue(newState);\n      // Nur noch _effectQueue verwenden\n      if (newState._effectQueue && newState._effectQueue.length > 0) {\n        try {\n          log(`DEBUG: about to resolve queue (spec public/default) -> ${JSON.stringify(newState._effectQueue.map(e => ({\n            type: e.type,\n            amount: e.amount,\n            msg: e.msg\n          })).slice(0, 50))}`);\n        } catch (e) {}\n        log(`DEBUG AP before resolve (spec public/default): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n        resolveQueue(newState, newState._effectQueue);\n        newState._effectQueue = [];\n        // Nach Queue-AuflÃ¶sung: Hand-Arrays immutabel neu zuweisen\n        afterQueueResolved === null || afterQueueResolved === void 0 ? void 0 : afterQueueResolved();\n        log(`DEBUG AP after resolve (spec public/default): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n      }\n\n      // Check for trap triggers\n      applyTrapsOnCardPlayed(newState, player, selectedCard, e => (newState._effectQueue ??= []).push(e), m => (newState._effectQueue ??= []).push({\n        type: 'LOG',\n        msg: m\n      }));\n\n      // Simplified AP system: No refunds\n\n      // Kein Aktionenlimit mehr â†’ automatischer Turnwechsel entfÃ¤llt\n\n      return newState;\n    });\n  }, [setGameState, log]);\n  const activateInstantInitiative = useCallback(player => {\n    logger.info(`activateInstantInitiative START P${player}`);\n    setGameState(prev => {\n      if (prev.current !== player) {\n        log(`âŒ ERROR: Not player turn - Current: ${prev.current}, Attempted: ${player}`);\n        return prev;\n      }\n      const instantCard = prev.board[player].sofort[0];\n      if (!instantCard) {\n        log(`âŒ ERROR: No Sofort-Initiative in slot for player ${player}`);\n        return prev;\n      }\n      const newState = {\n        ...prev\n      };\n\n      // 1) Normale Karten-Effekte der Sofort-Karte feuern\n      triggerCardEffects(newState, player, instantCard);\n\n      // UI visual: initiative ripple + AP pop (prototype hook)\n      try {\n        var _politicardDebug4;\n        const zones = ((_politicardDebug4 = window.__politicardDebug) === null || _politicardDebug4 === void 0 ? void 0 : _politicardDebug4.clickZones) || [];\n        const boardZone = zones.find(z => z.data && z.data.type === 'row_slot');\n        const cx = boardZone ? boardZone.x + (boardZone.w || 256) / 2 : 960;\n        const cy = boardZone ? boardZone.y + (boardZone.h || 256) / 2 : 300;\n        if (visualEffects) {\n          visualEffects.spawnRipple(cx, cy, {\n            radius: 640,\n            showAp: true,\n            apX: cx,\n            apY: cy + 40\n          });\n          try {\n            const trigI = window.__pc_triggerInstantAnim || window.pc_triggerInstantAnim;\n            if (typeof trigI === 'function') trigI('1.instant.0');\n          } catch (e) {}\n        } else {\n          window.__pc_ripples = window.__pc_ripples || [];\n          window.__pc_ripples.push({\n            cx,\n            cy,\n            started: performance.now(),\n            duration: 700,\n            radius: 640,\n            showAp: true,\n            apX: cx,\n            apY: cy + 40\n          });\n        }\n      } catch (e) {}\n\n      // Check for trap triggers\n      applyTrapsOnCardPlayed(newState, player, instantCard, e => (newState._effectQueue ??= []).push(e), m => (newState._effectQueue ??= []).push({\n        type: 'LOG',\n        msg: m\n      }));\n\n      // 2) Queue auflÃ¶sen (BEVOR die Karte entfernt wird)\n      if (newState._effectQueue && newState._effectQueue.length > 0) {\n        resolveQueue(newState, [...newState._effectQueue]);\n        newState._effectQueue = [];\n        // Nach Queue-AuflÃ¶sung: Hand-Arrays immutabel neu zuweisen\n        afterQueueResolved === null || afterQueueResolved === void 0 ? void 0 : afterQueueResolved();\n      }\n\n      // 3) Karte NACH Queue-AuflÃ¶sung in den Ablagestapel\n      const [played] = newState.board[player].sofort.splice(0, 1);\n      newState.discard.push(played);\n\n      // Visual: listen for dice roll event to animate & bind to SKANDALSPIRALE_TRIGGER if present\n      try {\n        const diceHandler = ev => {\n          try {\n            var _ev$detail5, _newState$_effectQueu;\n            const face = (_ev$detail5 = ev.detail) === null || _ev$detail5 === void 0 ? void 0 : _ev$detail5.face;\n            if (face == null) return;\n            // If last enqueued event was SKANDALSPIRALE_TRIGGER, attach a LOG with the face\n            const last = ((_newState$_effectQueu = newState._effectQueue) !== null && _newState$_effectQueu !== void 0 ? _newState$_effectQueu : []).slice(-1)[0];\n            // Emit a LOG event for visibility\n            if (!newState._effectQueue) newState._effectQueue = [];\n            newState._effectQueue.push({\n              type: 'LOG',\n              msg: `WÃ¼rfel: ${face}`\n            });\n          } catch (e) {}\n        };\n        window.addEventListener('pc:dice_roll', diceHandler);\n        // remove after short timeout to avoid leaking listeners\n        setTimeout(() => window.removeEventListener('pc:dice_roll', diceHandler), 2000);\n      } catch (e) {}\n      return newState;\n    });\n  }, [setGameState, log]);\n  const endTurn = useCallback((reason = 'button_end_turn') => {\n    logger.info(`endTurn START reason=${reason}`);\n    setGameState(prev => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const current = prev.current;\n\n      // 1) Schon im Abschluss? -> Nichts tun (Idempotenz)\n      if (prev.isEndingTurn) {\n        log('ğŸ” Zugabschluss lÃ¤uft bereits â€“ warte auf Queue.');\n        return prev;\n      }\n      const newState = {\n        ...prev,\n        isEndingTurn: true\n      };\n\n      // 2) HÃ¤ngen noch Effekte in der Queue? -> AuflÃ¶sen lassen\n      if (newState._effectQueue && newState._effectQueue.length > 0) {\n        log('â³ Effekte werden noch aufgelÃ¶st â€“ Zugwechsel folgt automatisch.');\n        resolveQueue(newState, [...newState._effectQueue]);\n        newState._effectQueue = [];\n        // Nach Queue-AuflÃ¶sung: Wenn Flag noch gesetzt, Zug beenden\n        if (newState.isEndingTurn) {\n          return reallyEndTurn(newState, log);\n        }\n        return newState;\n      }\n\n      // 3) Keine Effekte mehr -> sofort beenden\n      return reallyEndTurn(newState, log);\n    });\n  }, [setGameState, log]);\n\n  // Legacy: nextTurn als Alias fÃ¼r endTurn fÃ¼r KompatibilitÃ¤t\n  const nextTurn = useCallback(() => {\n    logger.info('nextTurn alias called');\n    endTurn('auto');\n  }, [endTurn]);\n\n  // Global listener: handle visual dice results and apply Skandalspirale effects automatically\n  useEffect(() => {\n    const handler = ev => {\n      var _ev$detail6;\n      const face = ev === null || ev === void 0 ? void 0 : (_ev$detail6 = ev.detail) === null || _ev$detail6 === void 0 ? void 0 : _ev$detail6.face;\n      if (typeof face !== 'number') return;\n      setGameState(prev => {\n        try {\n          const pending = prev._pendingSkandal;\n          if (!pending) return prev;\n          // only accept recent pending requests (avoid stale triggers)\n          if (Date.now() - (pending.ts || 0) > 8000) {\n            const n = {\n              ...prev\n            };\n            delete n._pendingSkandal;\n            return n;\n          }\n          const newState = {\n            ...prev\n          };\n          // clear pending marker\n          delete newState._pendingSkandal;\n\n          // Prepare events based on face\n          newState._effectQueue = newState._effectQueue || [];\n          if (face >= 1 && face <= 3) {\n            const loss = face;\n            // enqueue negative buff (debuff) on disadvantaged player's strongest gov\n            newState._effectQueue.push({\n              type: 'BUFF_STRONGEST_GOV',\n              player: pending.player,\n              amount: -loss\n            });\n            newState._effectQueue.push({\n              type: 'LOG',\n              msg: `Skandalspirale: Spieler ${pending.player} wÃ¼rfelt ${face} â†’ stÃ¤rkste Regierung -${loss}.`\n            });\n          } else {\n            newState._effectQueue.push({\n              type: 'LOG',\n              msg: `Skandalspirale: Spieler ${pending.player} wÃ¼rfelt ${face} â†’ Keine Auswirkung.`\n            });\n          }\n\n          // Resolve immediately so effect is visible without waiting\n          if (newState._effectQueue && newState._effectQueue.length > 0) {\n            try {\n              resolveQueue(newState, [...newState._effectQueue]);\n            } catch (e) {\n              logger.dbg('resolveQueue failed on dice handler', e);\n            }\n            newState._effectQueue = [];\n          }\n\n          // Ensure React sees shallow-copied hands for UI update\n          try {\n            newState.hands = {\n              1: [...newState.hands[1]],\n              2: [...newState.hands[2]]\n            };\n          } catch (e) {}\n\n          // run after-queue hook if provided (best-effort)\n          try {\n            if (window.__afterQueueResolved) window.__afterQueueResolved();\n          } catch (e) {}\n          return newState;\n        } catch (err) {\n          logger.dbg('dice handler setGameState error', err);\n          return prev;\n        }\n      });\n    };\n    window.addEventListener('pc:dice_roll', handler);\n    return () => window.removeEventListener('pc:dice_roll', handler);\n  }, [setGameState]);\n  const passTurn = useCallback(player => {\n    logger.info(`passTurn START P${player}`);\n    setGameState(prev => {\n      logger.dbg(`passTurn setState current=${prev.current} player=${player}`);\n      if (prev.current !== player) {\n        logger.dbg(`passTurn wrong turn current=${prev.current} attempted=${player}`);\n        return prev;\n      }\n      const newState = {\n        ...prev,\n        passed: {\n          ...prev.passed,\n          [player]: true\n        }\n      };\n      logger.dbg(`Pass status updated P1=${newState.passed[1]} P2=${newState.passed[2]}`);\n      log(`ğŸš« Spieler ${player} passt.`);\n\n      // â— Kein Nachziehen bei Pass:\n      // Der passierende Spieler kommt in dieser Runde nicht mehr dran.\n      // Die nÃ¤chste Runde startet ohnehin mit 5 neuen Handkarten.\n\n      // Check if round should end (both players passed)\n      const shouldEndRound = checkRoundEnd(newState);\n      logger.dbg(`Should end round? ${shouldEndRound}`);\n      if (shouldEndRound) {\n        log(`ğŸ Runde ${newState.round} wird beendet und ausgewertet.`);\n        return resolveRound(newState, log);\n      } else {\n        // Switch turn to other player for their final chance\n        const otherPlayer = player === 1 ? 2 : 1;\n        logger.dbg(`Switching to other player ${otherPlayer} hasPassed=${newState.passed[otherPlayer]}`);\n\n        // Only switch if other player hasn't passed yet\n        if (!newState.passed[otherPlayer]) {\n          newState.current = otherPlayer;\n          newState.actionPoints = {\n            ...newState.actionPoints,\n            [otherPlayer]: 2\n          };\n\n          // Apply new start-of-turn hooks\n          applyStartOfTurnFlags(newState, otherPlayer, log);\n\n          // ğŸ”¥ CLUSTER 3: Auren-Flags beim Zugstart neu berechnen\n          recomputeAuraFlags(newState);\n          log(`â­ï¸ Spieler ${otherPlayer} hat noch einen letzten Zug.`);\n          logger.dbg(`Turn switched to player ${otherPlayer}`);\n        } else {\n          // Both players have passed now, end round\n          log(`ğŸ Runde ${newState.round} wird beendet (beide Spieler haben gepasst).`);\n          return resolveRound(newState, log);\n        }\n      }\n      return newState;\n    });\n  }, [setGameState, log]);\n  return {\n    startMatchWithDecks,\n    startMatchVsAI,\n    playCard,\n    activateInstantInitiative,\n    passTurn,\n    nextTurn,\n    endTurn\n  };\n}\n_s(useGameActions, \"XYqjzE4e8Z38peMewMDEwdGBW9g=\", false, function () {\n  return [useVisualEffectsSafe];\n});","map":{"version":3,"names":["useCallback","useRef","useEffect","createDefaultEffectFlags","buildDeckFromEntries","sumGovernmentInfluenceWithAuras","PRESET_DECKS","getCardActionPointCost","getNetApCost","canPlayCard","triggerCardEffects","ensureTestBaselineAP","resolveQueue","applyStartOfTurnFlags","registerTrap","applyTrapsOnCardPlayed","recomputeAuraFlags","emptyBoard","logger","useVisualEffectsSafe","slotGovGif","getUiTransform","getGovernmentRects","migrateLegacyQueue","state","other","p","ensureFlags","s","effectFlags","pickLane","c","tag","kind","isCardPlayableNow","player","card","deactivated","lane","board","length","t","String","type","toLowerCase","innen","tags","isOngoingInitiative","includes","effectKey","startsWith","preferredSlot","permanentSlot","permanentSlots","hasPlayableZeroCost","hands","cost","applyAurasForPlayer","log","hasNgo","some","newAussen","aussen","map","pol","baseInfluence","influence","prev","bonus","name","effect","checkRoundEnd","gameState","result","passed","dbg","drawCardsFromDeck","count","deck","decks","drawnCards","splice","Math","min","reallyEndTurn","current","isEndingTurn","drawnCard","shift","push","shouldEndRound","round","resolveRound","newCurrent","actionPoints","p1Influence","p2Influence","roundWinner","cardsToDiscard","government","public","sofort","newP1Hand","newP2Hand","newRoundsWon","roundsWon","p1Wins","p2Wins","gameWinner","newState","actionsUsed","initiativePermanent","slice","discard","useGameActions","setGameState","afterQueueResolved","_s","visualEffects","spawnCardVisual","stateOverride","_card$uid","_card$uid2","_politicardDebug2","console","debug","uid","id","effectiveState","_politicardDebug","located","idxA","findIndex","_c$uid","_card$uid3","index","idxI","_c$uid2","_card$uid4","_card$uid5","_card$uid6","rects","slot","x","y","w","h","cx_slot","cy_slot","spawnParticles","spawnPop","cx","cy","canvas","document","querySelector","_card$uid7","_card$uid8","rect","getBoundingClientRect","scale","offsetX","offsetY","width","height","screenCx","left","screenCy","top","spawnGifOverlayUi","src","duration","_card$uid9","playAnimsRef","started","performance","now","e","zones","window","__politicardDebug","clickZones","zone","find","z","_z$data$card$uid","data","_z$data$card$uid2","__pc_particles","i","start","life","random","vx","vy","size","color","floor","gravity","__pc_pops","__pc_play_anims","wv","__pc_visual_effects","spawnGifOverlay","_politicardDebug3","ui","uiTransform","playingUidRef","Set","handlePickTarget","ev","_ev$detail","_ev$detail2","detail","targetUid","handleRequestRoll","_ev$detail3","_ev$detail4","fallbackRoll","dispatchEvent","CustomEvent","roll","events","error","_effectQueue","addEventListener","removeEventListener","startMatchWithDecks","p1DeckEntries","p2DeckEntries","p1Cards","p2Cards","p1NgoCarten","filter","p1PlatformCards","p1JoschaCards","p1PublicCards","join","d1","d2","h1","h2","traps","shields","activeRefresh","aiEnabled","startMatchVsAI","presetKey","playCard","handIndex","info","warn","hand","ngoCards","platformCards","selectedCard","prevAp","max","ef","newHand","playedCard","has","add","currentBoard","publicCardsOnBoard","polCard","targetLane","laneArray","playerBoardCloned","slotIndex","slotRect","_playedCard$uid","key","trig","__pc_triggerGovAnim","pc_triggerGovAnim","_visualEffects$playAn","_visualEffects$playAn2","_playedCard$uid2","event","JSON","stringify","amount","msg","delete","m","opponent","opponentBoard","romanAbramovich","regierungKarten","Ã¶ffentlichkeitKarten","joschaFischer","_type","_type2","specCard","typeStr","isInitiative","test","ownBoard","candidates","target","protected","_newState$permanentSl","_newState$board$playe","innenArray","drawCardForPlayer","cardName","toUpperCase","hasPlatform","hasMedia","hasAuthoritarianCard","hasJoschka","replace","activateInstantInitiative","instantCard","_politicardDebug4","boardZone","spawnRipple","radius","showAp","apX","apY","trigI","__pc_triggerInstantAnim","pc_triggerInstantAnim","__pc_ripples","played","diceHandler","_ev$detail5","_newState$_effectQueu","face","last","setTimeout","endTurn","reason","nextTurn","handler","_ev$detail6","pending","_pendingSkandal","Date","ts","n","loss","__afterQueueResolved","err","passTurn","otherPlayer"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/hooks/useGameActions.ts"],"sourcesContent":["import { useCallback, useRef, useEffect } from 'react';\nimport { GameState, Card, Player, BuilderEntry, PoliticianCard } from '../types/game';\nimport { createDefaultEffectFlags } from '../types/game';\nimport { buildDeckFromEntries, sumGovernmentInfluenceWithAuras } from '../utils/gameUtils';\nimport { PRESET_DECKS } from '../data/gameData';\nimport { getCardActionPointCost, getNetApCost, canPlayCard, isInitiativeCard, isGovernmentCard } from '../utils/ap';\nimport { triggerCardEffects } from '../effects/cards';\nimport { ensureTestBaselineAP } from '../utils/testCompat';\nimport { resolveQueue } from '../utils/queue';\nimport { applyStartOfTurnFlags } from '../utils/startOfTurnHooks';\nimport { registerTrap, applyTrapsOnCardPlayed } from '../utils/traps';\nimport { recomputeAuraFlags } from '../state/effects';\nimport { activateInstantInitiative as activateInstantInitiativeRuntime } from '../state/instantRuntime';\nimport { isInstantInitiative } from '../utils/initiative';\nimport { emptyBoard } from '../state/board';\nimport type { EffectEvent } from '../types/effects';\nimport { logger } from '../debug/logger';\nimport { useVisualEffects, useVisualEffectsSafe } from '../context/VisualEffectsContext';\n// TS: sometimes asset module resolution fails in some setups â€” ignore typecheck for this import\n// @ts-ignore\nimport slotGovGif from '../ui/layout/slot_gov.webm';\nimport { getUiTransform, getGovernmentRects } from '../ui/layout';\n\n// Migration Helper fÃ¼r Queue-Vereinheitlichung\nconst migrateLegacyQueue = (state: any) => {\n  // Queue migration completed - only _effectQueue exists now\n};\n\n// Helper function for getting the other player\nconst other = (p: Player): Player => (p === 1 ? 2 : 1) as Player;\n\n// Hilfsfunktion: stellt sicher, dass effectFlags vorhanden sind\nconst ensureFlags = (s: GameState, p: Player) => {\n  if (!s.effectFlags) {\n    (s as any).effectFlags = { 1: createDefaultEffectFlags(), 2: createDefaultEffectFlags() };\n  } else {\n    s.effectFlags[p] = { ...createDefaultEffectFlags(), ...s.effectFlags[p] };\n  }\n};\n\n// Lane-Heuristik wie in playCard\nconst pickLane = (c: Card): 'innen'|'aussen' => {\n  const tag = (c as any).tag;\n  if (c.kind === 'pol' && (tag === 'Staatsoberhaupt' || tag === 'Regierungschef' || tag === 'Diplomat')) return 'aussen';\n  return 'innen';\n};\n\nconst isCardPlayableNow = (state: GameState, player: Player, card: Card): boolean => {\n  if ((card as any).deactivated) return false;\n\n  if (card.kind === 'pol') {\n    const lane = pickLane(card);\n    return state.board[player][lane].length < 5;\n  }\n\n  if (card.kind === 'spec') {\n    const t = String((card as any).type || '').toLowerCase();\n    // Public cards\n    if (t === 'Ã¶ffentlichkeitskarte' || t === 'oeffentlichkeitskarte' || t === 'public') {\n      return state.board[player].innen.length < 5;\n    }\n\n    // Detect Ongoing / Permanent Initiatives by explicit tags or by effectKey namespace\n    const tags: string[] = (card as any).tags || (card as any).tags || [];\n    const isOngoingInitiative = ((card as any).type && String((card as any).type).toLowerCase().includes('initiative')) && (tags.includes('Ongoing') || (String((card as any).effectKey || '').startsWith('init.') && tags.includes('Ongoing')));\n    if (isOngoingInitiative) {\n      // Determine which permanent slot this initiative should occupy. Prefer explicit slot metadata, otherwise default to government.\n      const preferredSlot = (card as any).permanentSlot || ((card as any).tags && (card as any).tags.includes('Public') ? 'public' : 'government');\n      return !state.permanentSlots[player][preferredSlot as 'government' | 'public'];\n    }\n\n    // sonst: Fallen/Interventionen â€“ aktuell immer erlaubt\n    return true;\n  }\n\n  return false;\n};\n\nexport const hasPlayableZeroCost = (state: GameState, player: Player): boolean => {\n  for (const c of state.hands[player]) {\n    const { cost } = getCardActionPointCost(state, player, c);\n    if (cost === 0 && isCardPlayableNow(state, player, c)) return true;\n  }\n  return false;\n};\n\n// Helper function to apply auras for a player (instant updates for Joschka Fischer + NGO synergy)\nfunction applyAurasForPlayer(state: GameState, player: Player, log?: (msg: string) => void) {\n  const board = state.board[player];\n  const hasNgo = board.innen.some(c =>\n    c.kind === 'spec' &&\n    (c as any).type === 'Ã–ffentlichkeitskarte' &&\n    (c as any).tag === 'NGO' &&\n    !(c as any).deactivated\n  );\n\n  const newAussen = board.aussen.map(card => {\n    if (card.kind !== 'pol') return card;\n    const pol: any = { ...card };\n    if (pol.baseInfluence == null) pol.baseInfluence = pol.influence;\n    const prev = pol.influence as number;\n\n    let bonus = 0;\n    if (!pol.deactivated && pol.name === 'Joschka Fischer' && pol.effect === 'ngo_boost' && hasNgo) {\n      bonus += 1;\n    }\n    pol.influence = (pol.baseInfluence as number) + bonus;\n    if (log && pol.influence > prev) log(`PASSIV: ${pol.name} +${pol.influence - prev} I (jetzt ${pol.influence}).`);\n    return pol;\n  });\n\n  state.board = {\n    ...state.board,\n    [player]: { ...state.board[player], aussen: newAussen },\n  } as any;\n}\n\n\n\n// Helper function to check if round should end\nfunction checkRoundEnd(gameState: GameState): boolean {\n  // Round ends if both players have passed\n  const result = gameState.passed[1] && gameState.passed[2];\n  logger.dbg(`checkRoundEnd P1=${gameState.passed[1]} P2=${gameState.passed[2]} result=${result}`);\n  return result;\n}\n\n// Helper function to draw cards from deck\nfunction drawCardsFromDeck(gameState: GameState, player: Player, count: number): Card[] {\n  const deck = [...gameState.decks[player]];\n  const drawnCards = deck.splice(0, Math.min(count, deck.length));\n  return drawnCards;\n}\n\n// Helper function to really end a turn (extracted from nextTurn logic)\nfunction reallyEndTurn(gameState: GameState, log: (msg: string) => void): GameState {\n  const current = gameState.current;\n\n  // Flag zurÃ¼cksetzen - Zug-Ende wird jetzt wirklich durchgefÃ¼hrt\n  gameState.isEndingTurn = false;\n\n  // âœ… Karte nachziehen am Ende eines Zugs (nur wenn NICHT \"pass\")\n  if (!gameState.passed[current]) {\n    const drawnCard = gameState.decks[current].shift();\n    if (drawnCard) {\n      gameState.hands[current].push(drawnCard);\n      log(`ğŸ”¥ Zug-Ende: +1 Karte gezogen (${drawnCard.name})`);\n    }\n  } else {\n    log(`â­ï¸ P${current} hat gepasst â€“ kein Nachziehen.`);\n  }\n\n  // Check if round should end\n  const shouldEndRound = checkRoundEnd(gameState);\n  if (shouldEndRound) {\n    log(`ğŸ Runde ${gameState.round} wird beendet (Zug-Ende).`);\n    return resolveRound(gameState, log);\n  }\n\n  // Spielerwechsel + AP reset\n  const newCurrent: Player = current === 1 ? 2 : 1;\n  gameState.current = newCurrent;\n  gameState.actionPoints = { ...gameState.actionPoints, [newCurrent]: 2 };\n  gameState.passed = { ...gameState.passed, [newCurrent]: false };\n\n            // Apply new start-of-turn hooks\n          applyStartOfTurnFlags(gameState, newCurrent, log);\n\n        // ğŸ”¥ CLUSTER 3: Auren-Flags beim Zugstart neu berechnen\n        recomputeAuraFlags(gameState);\n\n  // Reset turn-bezogener Flag-Nutzungen (handled in applyStartOfTurnFlags)\n\n  log(`ğŸ”„ Zug-Ende: Spieler ${newCurrent} ist am Zug (2 AP verfÃ¼gbar)`);\n\n  return gameState;\n}\n\n// Helper function to resolve round and start new one\nfunction resolveRound(gameState: GameState, log: (msg: string) => void): GameState {\n  // Calculate influence for both players\n  const p1Influence = sumGovernmentInfluenceWithAuras(gameState, 1);\n  const p2Influence = sumGovernmentInfluenceWithAuras(gameState, 2);\n\n  log(`ğŸ“Š Rundenauswertung: P1 ${p1Influence} Einfluss vs P2 ${p2Influence} Einfluss`);\n\n  // Determine winner\n  let roundWinner: Player;\n  if (p1Influence > p2Influence) {\n    roundWinner = 1;\n    log(`ğŸ† Spieler 1 gewinnt die Runde! (${p1Influence} > ${p2Influence})`);\n  } else if (p2Influence > p1Influence) {\n    roundWinner = 2;\n    log(`ğŸ† Spieler 2 gewinnt die Runde! (${p2Influence} > ${p1Influence})`);\n  } else {\n    // Tie - current player wins\n    roundWinner = gameState.current;\n    log(`ğŸ¤ Unentschieden! Spieler ${roundWinner} gewinnt als aktiver Spieler.`);\n  }\n\n  // Collect all cards to move to discard\n  const cardsToDiscard: Card[] = [\n    ...gameState.board[1].innen,\n    ...gameState.board[1].aussen,\n    ...gameState.board[2].innen,\n    ...gameState.board[2].aussen,\n    ...(gameState.permanentSlots[1].government ? [gameState.permanentSlots[1].government] : []),\n    ...(gameState.permanentSlots[1].public ? [gameState.permanentSlots[1].public] : []),\n    ...(gameState.permanentSlots[2].government ? [gameState.permanentSlots[2].government] : []),\n    ...(gameState.permanentSlots[2].public ? [gameState.permanentSlots[2].public] : []),\n    ...gameState.board[1].sofort,\n    ...gameState.board[2].sofort\n  ];\n\n  // Draw 5 new cards for each player\n  const newP1Hand = drawCardsFromDeck(gameState, 1, 5);\n  const newP2Hand = drawCardsFromDeck(gameState, 2, 5);\n\n  // Calculate new rounds won\n  const newRoundsWon = {\n    ...gameState.roundsWon,\n    [roundWinner]: gameState.roundsWon[roundWinner] + 1\n  };\n\n  // Check if game should end (Best of 3: first to 2 wins)\n  const p1Wins = newRoundsWon[1];\n  const p2Wins = newRoundsWon[2];\n\n  if (p1Wins >= 2 || p2Wins >= 2) {\n    const gameWinner = p1Wins >= 2 ? 1 : 2;\n    log(`ğŸ†ğŸ‰ SPIEL BEENDET! Spieler ${gameWinner} gewinnt das Match! (${p1Wins}-${p2Wins})`);\n    log(`ğŸ”¥ Gesamtergebnis: Player ${gameWinner} ist der Sieger!`);\n\n    // Return final state with game winner\n    return {\n      ...gameState,\n      roundsWon: newRoundsWon,\n      gameWinner,\n      // Keep current board state for final display\n      passed: { 1: true, 2: true }, // Both passed to indicate game end\n    };\n  }\n\n  // Create new state for next round\n  const newState: GameState = {\n    ...gameState,\n    round: gameState.round + 1,\n    current: roundWinner, // Winner starts next round\n         passed: { 1: false, 2: false }, // Reset pass status\n     actionPoints: { 1: 2, 2: 2 }, // Reset AP\n     actionsUsed: { 1: 0, 2: 0 }, // Reset actions (kept for compatibility)\n     roundsWon: newRoundsWon,\n    effectFlags: {\n      1: createDefaultEffectFlags(),\n      2: createDefaultEffectFlags()\n    },\n    // Clear all board positions\n    board: emptyBoard(),\n    // Clear permanent slots\n    permanentSlots: {\n      1: { government: null, public: null, initiativePermanent: null },\n      2: { government: null, public: null, initiativePermanent: null }\n    },\n    // instantSlot wird nicht mehr verwendet - Sofort-Initiativen gehen in board[player].sofort\n    // New hands with 5 cards each\n    hands: {\n      1: newP1Hand,\n      2: newP2Hand\n    },\n    // Update decks (cards were removed during drawing)\n    decks: {\n      1: gameState.decks[1].slice(newP1Hand.length),\n      2: gameState.decks[2].slice(newP2Hand.length)\n    },\n    // Update discard pile\n    discard: [...gameState.discard, ...cardsToDiscard]\n  };\n\n  log(`ğŸ†• Runde ${newState.round} startet! Spieler ${roundWinner} beginnt. (Rundenstand: P1 ${newState.roundsWon[1]} - P2 ${newState.roundsWon[2]})`);\n  log(`ğŸƒ Beide Spieler erhalten 5 neue Handkarten.`);\n\n  return newState;\n}\n\nexport function useGameActions(\n  gameState: GameState,\n  setGameState: React.Dispatch<React.SetStateAction<GameState>>,\n  log: (msg: string) => void,\n  afterQueueResolved?: () => void\n) {\n  // Visual effects context (spawn helpers)\n  // Use safe hook variant which returns null when no provider is present\n  const visualEffects = useVisualEffectsSafe();\n  // Helper: spawn lightweight UI visuals via window hooks (prototype only)\n  const spawnCardVisual = useCallback((card: any, stateOverride?: GameState) => {\n    try {\n      if (!card) return;\n      console.debug('[GameActions] spawnCardVisual called', { uid: card.uid ?? card.id, name: card.name });\n      const uid = card.uid ?? card.id;\n      // prefer VisualEffects context if available\n      const effectiveState = stateOverride || gameState;\n      if (visualEffects) {\n        // Prefer authoritative board-based slot centering (gov slots) using effectiveState\n        try {\n          let located: { player: number; lane: 'aussen' | 'innen'; index: number } | null = null;\n          for (const p of [1, 2] as const) {\n            const aussen = effectiveState.board[p].aussen || [];\n            const idxA = aussen.findIndex((c: any) => (c.uid ?? c.id) === (card.uid ?? card.id));\n            if (idxA >= 0) { located = { player: p, lane: 'aussen', index: idxA }; break; }\n            const innen = effectiveState.board[p].innen || [];\n            const idxI = innen.findIndex((c: any) => (c.uid ?? c.id) === (card.uid ?? card.id));\n            if (idxI >= 0) { located = { player: p, lane: 'innen', index: idxI }; break; }\n          }\n\n          if (located && located.lane === 'aussen') {\n            const rects = getGovernmentRects(located.player === 1 ? 'player' : 'opponent');\n            const slot = rects[located.index] || rects[0] || { x: 960 - 128, y: 540 - 128, w: 256, h: 256 };\n            const cx_slot = slot.x + slot.w / 2;\n            const cy_slot = slot.y + slot.h / 2;\n            visualEffects.spawnParticles(cx_slot, cy_slot, 18);\n            visualEffects.spawnPop(card.uid ?? card.id);\n            console.debug('[GameActions] spawnCardVisual particles/pop (gov slot)', { uid: card.uid ?? card.id, cx: cx_slot, cy: cy_slot, slot });\n\n            const canvas = document.querySelector('canvas');\n            if (canvas) {\n              const rect = canvas.getBoundingClientRect();\n              const { scale, offsetX, offsetY } = getUiTransform(canvas.width, canvas.height);\n              // Apply offset first, then scale (matches canvas transform order)\n              const screenCx = rect.left + (cx_slot + offsetX) * scale;\n              const screenCy = rect.top  + (cy_slot + offsetY) * scale;\n              // Use dedicated government slot GIF provided by user\n              // Use UI-based overlay spawner so we always align to canvas-derived\n              // pulsing slot fields exactly (handles scale+offset internally).\n              visualEffects.spawnGifOverlayUi({ id: card.uid ?? card.id, cx: cx_slot, cy: cy_slot, w: 256, h: 256, src: slotGovGif, duration: 700 });\n              console.debug('[GameActions] spawnCardVisual spawnGifOverlay (gov slot)', { uid: card.uid ?? card.id, screenCx, screenCy, src: slotGovGif });\n            }\n\n            try { visualEffects.playAnimsRef.current.push({ uid: card.uid ?? card.id, started: performance.now(), duration: 420 }); } catch (e) {}\n            return;\n          }\n        } catch (e) {\n          console.debug('[GameActions] gov-slot centering failed, falling back', e);\n        }\n        // attempt to find a row_slot zone center via debug snapshot (avoid hand slots)\n        const zones = (window as any).__politicardDebug?.clickZones || [];\n        const zone = zones.find((z: any) => z.data && z.data.type === 'row_slot' && z.data.card && ((z.data.card.uid ?? z.data.card.id) === uid));\n        const cx = zone ? zone.x + (zone.w || 256) / 2 : 960;\n        const cy = zone ? zone.y + (zone.h || 256) / 2 : 540;\n        visualEffects.spawnParticles(cx, cy, 18);\n        visualEffects.spawnPop(uid);\n        console.debug('[GameActions] spawnCardVisual particles/pop (fallback)', { uid, cx, cy, zone });\n        // Add play animation entry so canvas will fade-in the card itself\n        try {\n          visualEffects.playAnimsRef.current.push({ uid, started: performance.now(), duration: 420 });\n          console.debug('[GameActions] spawnCardVisual playAnimsRef push', uid);\n        } catch (e) { console.debug('[GameActions] spawnCardVisual playAnimsRef push failed', e); }\n        return;\n      }\n      // fallback to old window-based prototype\n      const zones = (window as any).__politicardDebug?.clickZones || [];\n      const zone = zones.find((z: any) => z.data && z.data.card && ((z.data.card.uid ?? z.data.card.id) === uid));\n      const cx = zone ? zone.x + (zone.w || 256) / 2 : 960;\n      const cy = zone ? zone.y + (zone.h || 256) / 2 : 540;\n      (window as any).__pc_particles = (window as any).__pc_particles || [];\n      for (let i = 0; i < 18; i++) {\n        (window as any).__pc_particles.push({ start: performance.now(), life: 600 + Math.random() * 400, x: cx + (Math.random() - 0.5) * 40, y: cy + (Math.random() - 0.5) * 40, vx: (Math.random() - 0.5) * 6, vy: -Math.random() * 6, size: 3 + Math.random() * 5, color: ['#ffd166', '#ff6b6b', '#4ade80'][Math.floor(Math.random() * 3)], gravity: 0.12 });\n      }\n      (window as any).__pc_pops = (window as any).__pc_pops || [];\n      (window as any).__pc_pops.push({ uid, started: performance.now(), duration: 420 });\n      // Fallback: add play anim entry to global when VisualEffects not available\n      (window as any).__pc_play_anims = (window as any).__pc_play_anims || [];\n      (window as any).__pc_play_anims.push({ uid, started: performance.now(), duration: 420 });\n      // Also attempt to use provider fallback on window if available\n      try {\n        const wv = (window as any).__pc_visual_effects;\n        if (wv && typeof wv.spawnGifOverlay === 'function') {\n          // Compute screen coords based on canvas if possible\n          const canvas = document.querySelector('canvas');\n          if (canvas) {\n            const rect = canvas.getBoundingClientRect();\n            const ui = (window as any).__politicardDebug?.uiTransform || { scale: 1, offsetX: 0, offsetY: 0 };\n            const screenCx = rect.left + (cx + ui.offsetX) * ui.scale;\n            const screenCy = rect.top  + (cy + ui.offsetY) * ui.scale;\n            try {\n              if (typeof wv.spawnGifOverlayUi === 'function') {\n                // pass canvas-space coords so provider will align to UI\n                try { wv.spawnGifOverlayUi({ id: uid, cx: cx, cy: cy, w: 256, h: 256, src: slotGovGif, duration: 700 }); console.debug('[GameActions] fallback window.__pc_visual_effects.spawnGifOverlayUi', uid); } catch (e) { console.debug('[GameActions] fallback spawnGifOverlayUi failed', e); }\n              } else {\n                wv.spawnGifOverlay({ id: uid, cx: screenCx, cy: screenCy, w: 256 * ui.scale, h: 256 * ui.scale, src: slotGovGif, duration: 700 });\n                console.debug('[GameActions] fallback window.__pc_visual_effects.spawnGifOverlay', uid);\n              }\n            } catch (e) { console.debug('[GameActions] fallback spawnGifOverlay failed', e); }\n          }\n        }\n      } catch (e) {}\n    } catch (e) {\n      // swallow - non-critical\n    }\n  }, [visualEffects, gameState]);\n  // Guard against duplicate concurrent playCard calls for the same card UID\n  const playingUidRef = useRef<Set<number>>(new Set());\n  // Listen for target selection & dice result (global events)\n  useEffect(() => {\n    const handlePickTarget = (ev: any) => {\n      const uid = ev.detail?.targetUid as number | undefined;\n      const player = ev.detail?.player as Player | undefined;\n      if (!uid || !player) return;\n      try { log(`ğŸ¯ Corruption: Ziel gewÃ¤hlt (uid=${uid})`); } catch (e) {}\n    };\n\n    // Listener: when UI/modal requests a corruption roll, perform RNG and trigger visual dice\n    const handleRequestRoll = (ev: any) => {\n      try {\n        const player = ev.detail?.player as Player | undefined;\n        const targetUid = ev.detail?.targetUid as number | undefined;\n        if (!player || !targetUid) return;\n\n        console.log('ğŸ² CORRUPTION: Requesting roll for player', player, 'target', targetUid);\n        // Quick visual fallback: dispatch an engine_dice_result immediately so the Dice3D shows a value\n        try {\n          const fallbackRoll = 1 + Math.floor(Math.random() * 6);\n          console.debug('ğŸ² CORRUPTION: dispatching fallback engine_dice_result', fallbackRoll);\n          window.dispatchEvent(new CustomEvent('pc:engine_dice_result', { detail: { roll: fallbackRoll, player, targetUid } }));\n        } catch (e) { console.debug('ğŸ² CORRUPTION: fallback engine_dice_result dispatch failed', e); }\n\n        // Enqueue the corruption resolve event - engine will also calculate roll and trigger 3D dice via resolver\n        setGameState(prev => {\n          const events: EffectEvent[] = [];\n          events.push({ type: 'CORRUPTION_STEAL_GOV_RESOLVE', player, targetUid } as any);\n          // Process immediately\n          try { resolveQueue(prev as any, events); } catch (e) { console.error('resolveQueue error in handleRequestRoll', e); }\n          if (afterQueueResolved) afterQueueResolved();\n          return { ...prev, _effectQueue: [] };\n        });\n      } catch (e) {\n        logger.dbg('corruption request roll error', e);\n      }\n    };\n    window.addEventListener('pc:corruption_pick_target', handlePickTarget as EventListener);\n    window.addEventListener('pc:corruption_request_roll', handleRequestRoll as EventListener);\n    return () => {\n      window.removeEventListener('pc:corruption_pick_target', handlePickTarget as EventListener);\n      window.removeEventListener('pc:corruption_request_roll', handleRequestRoll as EventListener);\n    };\n  }, [setGameState, afterQueueResolved, log]);\n  const startMatchWithDecks = useCallback((p1DeckEntries: BuilderEntry[], p2DeckEntries: BuilderEntry[]) => {\n    const p1Cards = buildDeckFromEntries(p1DeckEntries);\n    const p2Cards = buildDeckFromEntries(p2DeckEntries);\n\n        // Debug: Log deck composition with detailed tag analysis\n    const p1NgoCarten = p1Cards.filter(c => (c as any).tag === 'NGO');\n    const p1PlatformCards = p1Cards.filter(c => (c as any).tag === 'Plattform');\n    const p1JoschaCards = p1Cards.filter(c => (c as any).effect === 'ngo_boost');\n    const p1PublicCards = p1Cards.filter(c => c.kind === 'spec' && (c as any).type === 'Ã–ffentlichkeitskarte');\n\n    log(`ğŸ” DECK DEBUG P1: ${p1Cards.length} Karten total`);\n    log(`ğŸ§ª P1 Public Cards: ${p1PublicCards.map(c => `${c.name}${(c as any).tag ? `[${(c as any).tag}]` : ''}`).join(', ')}`);\n    log(`ğŸŒ± P1 NGO-Karten: ${p1NgoCarten.length > 0 ? p1NgoCarten.map(c => c.name).join(', ') : 'Keine'}`);\n    log(`ğŸ’» P1 Plattform-Karten: ${p1PlatformCards.length > 0 ? p1PlatformCards.map(c => c.name).join(', ') : 'Keine'}`);\n    log(`ğŸ¯ JOSCHKA FISCHER: ${p1JoschaCards.length > 0 ? 'âœ… IM DECK' : 'âŒ NICHT IM DECK'}`);\n\n    const d1 = [...p1Cards];\n    const d2 = [...p2Cards];\n    const h1 = d1.splice(0, Math.min(5, d1.length));\n    const h2 = d2.splice(0, Math.min(5, d2.length));\n\n    setGameState(prev => ({\n      ...prev,\n      round: 1,\n      current: 1,\n      passed: { 1: false, 2: false },\n      decks: { 1: d1, 2: d2 },\n      hands: { 1: h1, 2: h2 },\n      board: { 1: { innen: [], aussen: [], sofort: [] }, 2: { innen: [], aussen: [], sofort: [] } },\n      traps: { 1: [], 2: [] },\n      permanentSlots: {\n        1: { government: null, public: null, initiativePermanent: null },\n        2: { government: null, public: null, initiativePermanent: null },\n      },\n      // instantSlot wird nicht mehr verwendet - Sofort-Initiativen gehen in board[player].sofort\n      discard: [],\n      shields: new Set(), // Set<UID>\n      effectFlags: {\n        1: createDefaultEffectFlags(),\n        2: createDefaultEffectFlags()\n      },\n      actionsUsed: { 1: 0, 2: 0 },\n      log: [\n        `Match gestartet. P1 und P2 erhalten je ${h1.length}/${h2.length} Startkarten.`,\n        `ğŸ” DECK DEBUG P1: ${p1Cards.length} Karten total`,\n        `ğŸ§ª P1 Public Cards: ${p1PublicCards.map(c => `${c.name}${(c as any).tag ? `[${(c as any).tag}]` : ''}`).join(', ')}`,\n        `ğŸŒ± P1 NGO-Karten: ${p1NgoCarten.length > 0 ? p1NgoCarten.map(c => c.name).join(', ') : 'Keine'}`,\n        `ğŸ’» P1 Plattform-Karten: ${p1PlatformCards.length > 0 ? p1PlatformCards.map(c => c.name).join(', ') : 'Keine'}`,\n        `ğŸ¯ JOSCHKA FISCHER: ${p1JoschaCards.length > 0 ? 'âœ… IM DECK' : 'âŒ NICHT IM DECK'}`,\n        `ğŸ“‹ INITIAL BOARD P1: Regierung=[] | Ã–ffentlichkeit=[]`,\n        `ğŸ“‹ INITIAL BOARD P2: Regierung=[] | Ã–ffentlichkeit=[]`,\n        `ğŸ  PERMANENT SLOTS: Alle leer`\n      ],\n      activeRefresh: { 1: 0, 2: 0 },\n      // preserve any aiEnabled flags set before calling this\n      aiEnabled: prev.aiEnabled || { 1: false, 2: false }\n    }));\n  }, [gameState, setGameState, log]);\n\n  const startMatchVsAI = useCallback((p1DeckEntries: BuilderEntry[], presetKey: keyof typeof PRESET_DECKS = 'AUTORITAERER_REALIST') => {\n    const p2DeckEntries = PRESET_DECKS[presetKey] as BuilderEntry[];\n    // Enable AI for P2 first so nextTurn/auto-run sees the flag immediately\n    setGameState(prev => ({ ...prev, aiEnabled: { ...(prev.aiEnabled || { 1: false, 2: false }), 2: true } }));\n    log('ğŸ”§ AI aktiviert fÃ¼r Spieler 2');\n    startMatchWithDecks(p1DeckEntries, p2DeckEntries);\n  }, [startMatchWithDecks]);\n\n  const playCard = useCallback((player: Player, handIndex: number, lane?: 'innen' | 'aussen') => {\n    logger.info(`playCard START P${player} idx=${handIndex}`);\n    setGameState(prev => {\n      // Test-only baseline fix â€“ ensures AP=5 at game start inside test runner\n      ensureTestBaselineAP(prev);\n\n      // Validate input parameters\n      if (prev.current !== player) {\n        log(`âŒ ERROR: Not player turn - Current: ${prev.current}, Attempted: ${player}`);\n        logger.warn(`playCard abort: wrong turn`);\n        return prev;\n      }\n\n      const hand = prev.hands[player];\n      if (handIndex < 0 || handIndex >= hand.length) {\n        log(`âŒ ERROR: Invalid hand index - Index: ${handIndex}, Hand length: ${hand.length}`);\n        return prev;\n      }\n\n      // Debug: Log current hand contents with detailed tag info\n      log(`ğŸ” HAND DEBUG P${player}: ${hand.map((c, i) => `${i}:${c.name}${(c as any).tag ? `[${(c as any).tag}]` : ''}`).join(', ')}`);\n      const ngoCards = hand.filter(c => (c as any).tag === 'NGO');\n      const platformCards = hand.filter(c => (c as any).tag === 'Plattform');\n      if (ngoCards.length > 0) {\n        log(`ğŸŒ± NGO-Karten in Hand P${player}: ${ngoCards.map(c => c.name).join(', ')}`);\n      }\n      if (platformCards.length > 0) {\n        log(`ğŸ’» Plattform-Karten in Hand P${player}: ${platformCards.map(c => c.name).join(', ')}`);\n      }\n\n      const selectedCard = hand[handIndex];\n      if (!canPlayCard(prev, player, selectedCard)) {\n        log('ğŸš« Kann Karte nicht spielen (keine AP verfÃ¼gbar).');\n        return prev;\n      }\n\n      const { cost } = getNetApCost(prev, player, selectedCard);\n      const prevAp = prev.actionPoints[player];\n\n      const newState = { ...prev };\n\n      // Simplified AP system: All cards cost exactly 1 AP\n      newState.actionPoints[player] = Math.max(0, newState.actionPoints[player] - cost);\n      log(`ğŸ’³ Kosten verbucht: AP ${prevAp}â†’${newState.actionPoints[player]}`);\n\n      // Flags KONSUMIEREN (einheitlich, NUR HIER!)\n      ensureFlags(newState, player);\n      const ef = newState.effectFlags[player];\n\n      // Simplified AP system: No refunds or discounts\n      // All cards cost exactly 1 AP\n\n      // Remove card from hand\n      const newHand = [...newState.hands[player]];\n      const [playedCard] = newHand.splice(handIndex, 1);\n      newState.hands = { ...newState.hands, [player]: newHand };\n\n      // Prevent double-playing the same UID concurrently\n      if ((playedCard as any).uid) {\n        if (playingUidRef.current.has((playedCard as any).uid)) {\n          log(`âš ï¸ Duplicate play prevented for UID ${(playedCard as any).uid}`);\n          return prev;\n        }\n        playingUidRef.current.add((playedCard as any).uid);\n      }\n\n      // ğŸ”§ CLUSTER 3 DEBUG: Zeige jede gespielte Karte\n      log(`ğŸ”§ CLUSTER 3 GLOBAL DEBUG: P${player} spielt ${(playedCard as any).name} (${playedCard.kind}) - Type: ${(playedCard as any).type || 'KEIN TYPE'}`);\n\n      // ğŸ”§ CLUSTER 3 DEBUG: Zeige aktuelles Board\n      const currentBoard = newState.board[player];\n      const publicCardsOnBoard = currentBoard.innen.filter(card => card.kind === 'spec');\n      log(`ğŸ”§ CLUSTER 3 GLOBAL DEBUG: Ã–ffentlichkeitskarten auf dem Feld: ${publicCardsOnBoard.map(c => (c as any).name).join(', ')}`);\n\n      // Jennifer Doudna check removed - not needed for current game logic\n\n      // Handle different card types\n      if (playedCard.kind === 'pol') {\n        const polCard = playedCard as any;\n        const targetLane = lane || (polCard.tag === 'Staatsoberhaupt' || polCard.tag === 'Regierungschef' || polCard.tag === 'Diplomat' ? 'aussen' : 'innen');\n\n        if (newState.board[player][targetLane].length >= 5) {\n          log(`âŒ ERROR: Lane full - Lane: ${targetLane}, Current: ${newState.board[player][targetLane].length}/5`);\n          return prev;\n        }\n\n        // Add to board (immutable clone to avoid accidental double references)\n        const laneArray = [...newState.board[player][targetLane], playedCard];\n        const playerBoardCloned = { ...newState.board[player], [targetLane]: laneArray } as any;\n        newState.board = { ...newState.board, [player]: playerBoardCloned } as any;\n\n        // VISUAL: spawn GIF overlay centered over the government slot icon when placing a government card\n        try {\n          if (targetLane === 'aussen') {\n            const rects = getGovernmentRects(player === 1 ? 'player' : 'opponent');\n            const slotIndex = newState.board[player].aussen.length - 1;\n            const slotRect = rects[slotIndex] || rects[0] || { x: 960 - 128, y: 540 - 128, w: 256, h: 256 };\n            const cx = slotRect.x + slotRect.w / 2;\n            const cy = slotRect.y + slotRect.h / 2;\n\n            // particles/pop in canvas coords\n            try { visualEffects?.spawnParticles(cx, cy, 18); } catch (e) {}\n            try { visualEffects?.spawnPop(playedCard.uid ?? playedCard.id); } catch (e) {}\n\n            // compute screen coords and spawn 300x300 overlay\n            const canvas = document.querySelector('canvas');\n            if (canvas) {\n              // Prefer reliable canvas spritesheet animation directly on the target slot\n              try {\n                const key = `${player}.${'aussen'}.${slotIndex}`;\n                const trig = (window as any).__pc_triggerGovAnim || (window as any).pc_triggerGovAnim;\n                if (typeof trig === 'function') trig(key);\n              } catch (e) {}\n              // Only fade-in anim\n              try { visualEffects?.playAnimsRef?.current?.push({ uid: playedCard.uid ?? playedCard.id, started: performance.now(), duration: 420 }); } catch (e) {}\n            }\n          }\n        } catch (e) {\n          console.debug('[GameActions] GOV overlay failed', e);\n        }\n        log(`ğŸƒ Player ${player}: ${playedCard.name} gespielt in ${targetLane === 'aussen' ? 'Regierung' : 'Ã–ffentlichkeit'}`);\n\n        // 3) Nachdem die Karte gelegt wurde: gegnerische Traps prÃ¼fen\n        applyTrapsOnCardPlayed(\n          newState,\n          player,\n          playedCard,\n          (event) => {\n            if (!newState._effectQueue) newState._effectQueue = [];\n            newState._effectQueue.push(event);\n          },\n          log\n        );\n\n        // ğŸ‘‰ Erst JETZT Auren anwenden (damit +2 Basis erhalten bleibt)\n        applyAurasForPlayer(newState, player, log);\n\n        // 6) Karteneffekte enqueuen + Queue auflÃ¶sen\n        triggerCardEffects(newState, player, playedCard);\n        // UI visual: particle burst + pop scale for played card (prototype hook)\n        try { spawnCardVisual(playedCard, newState); } catch (e) {}\n        // Migration Helper verwenden\n        migrateLegacyQueue(newState);\n        // Nur noch _effectQueue verwenden\n        if (newState._effectQueue && newState._effectQueue.length > 0) {\n          try { log(`DEBUG: about to resolve queue (pol play) -> ${JSON.stringify((newState._effectQueue as any).map((e:any)=>({type:e.type, amount:e.amount, msg:e.msg})).slice(0,50))}`); } catch(e) {}\n          log(`DEBUG AP before resolve (pol play): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n          resolveQueue(newState, newState._effectQueue);\n          newState._effectQueue = [];\n          // Nach Queue-AuflÃ¶sung: Hand-Arrays immutabel neu zuweisen\n          afterQueueResolved?.();\n          log(`DEBUG AP after resolve (pol play): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n        }\n\n        // Release playing UID after queue resolved\n        if ((playedCard as any).uid) playingUidRef.current.delete((playedCard as any).uid);\n\n        // Check for trap triggers\n        applyTrapsOnCardPlayed(\n          newState,\n          player,\n          playedCard,\n          (e) => (newState._effectQueue ??= []).push(e),\n          (m) => (newState._effectQueue ??= []).push({ type: 'LOG', msg: m })\n        );\n\n        // ğŸ”¥ ROMAN ABRAMOVICH EFFEKT: Wenn Regierungskarte mit Einfluss â‰¤5 gespielt wird\n        if (playedCard.kind === 'pol' && (playedCard as any).influence <= 5) {\n          const opponent = player === 1 ? 2 : 1;\n          const opponentBoard = newState.board[opponent];\n          const romanAbramovich = opponentBoard.innen.find(card =>\n            card.kind === 'spec' && (card as any).name === 'Roman Abramovich'\n          );\n\n          if (romanAbramovich) {\n            // Ziehe eine Karte fÃ¼r den Gegner\n            if (newState.decks[opponent].length > 0) {\n              const drawnCard = newState.decks[opponent].shift();\n              if (drawnCard) {\n                newState.hands[opponent].push(drawnCard);\n                log(`ğŸ”¥ ROMAN ABRAMOVICH EFFEKT: P${opponent} zieht 1 Karte (${drawnCard.name}) - Regierungskarte mit Einfluss â‰¤5 gespielt`);\n              }\n            }\n          }\n        }\n\n\n\n\n\n\n\n        // ğŸ” BOARD DEBUG: Zeige aktuelles Board nach dem Spielen\n        const currentBoard = newState.board[player];\n        const regierungKarten = currentBoard.aussen.map(c => `${c.name}[${c.kind === 'pol' ? (c as any).influence + 'I' : 'S'}]`);\n        const Ã¶ffentlichkeitKarten = currentBoard.innen.map(c => `${c.name}[${c.kind === 'spec' ? (c as any).tag || 'S' : 'P'}]`);\n        log(`ğŸ“‹ P${player} BOARD: Regierung=[${regierungKarten.join(', ')}] | Ã–ffentlichkeit=[${Ã¶ffentlichkeitKarten.join(', ')}]`);\n\n                // ğŸ”¥ JOSCHKA FISCHER NGO-EFFEKT: Jetzt als kontinuierlicher Aura-Effekt in sumRowWithAuras implementiert\n        log(`ğŸ” DEBUG: Karte gespielt - Name: ${playedCard.name}, Tag: ${(playedCard as any).tag || 'Kein Tag'}, Lane: ${targetLane}, Kind: ${playedCard.kind}`);\n\n        if ((playedCard as any).tag === 'NGO') {\n          log(`ğŸ” NGO-Karte gespielt: ${playedCard.name} [NGO] - Kontinuierliche Aura-Effekte werden bei Rundenauswertung berechnet`);\n\n          // ğŸ¯ SOFORTIGE SYNERGIE-PRÃœFUNG: Joschka Fischer + NGO\n          const joschaFischer = currentBoard.aussen.find(card =>\n            card.kind === 'pol' && (card as any).effect === 'ngo_boost'\n          );\n\n          if (joschaFischer) {\n            log(`ğŸ”¥ğŸ”¥ğŸ”¥ SYNERGIE AKTIVIERT! ğŸ”¥ğŸ”¥ğŸ”¥ Joschka Fischer + ${playedCard.name}[NGO] â†’ +1 Einfluss bei Rundenauswertung`);\n          }\n        }\n\n      } else if (playedCard.kind === 'spec') {\n        const specCard = playedCard as any;\n        const typeStr = String(specCard.type || '').toLowerCase();\n        const isInitiative = /initiative/.test(typeStr); // matcht \"Initiative\", \"Sofort-Initiative\", etc.\n\n                  // 1) Falls es eine \"Systemrelevant\" ist (sofortiger Buff auf letzte eigene Regierungskarte)\n        if (playedCard.kind === 'spec' && (playedCard as any).type?.toLowerCase().includes('systemrelevant')) {\n          const ownBoard = newState.board[player];\n          const candidates = [...ownBoard.aussen, ...ownBoard.innen].filter(c => c.kind === 'pol') as PoliticianCard[];\n          const target = candidates[candidates.length - 1]; // letzte eigene Regierungskarte\n          if (target) {\n            (target as any).protected = true;\n            log(`ğŸ›¡ï¸ ${target.name} erhÃ¤lt einmaligen Schutz.`);\n          } else {\n            log('ğŸ›ˆ Systemrelevant: Keine eigene Regierungskarte im Spiel â€“ Effekt verpufft.');\n          }\n          // danach die Spezialkarte normal entsorgen\n          newState.discard.push(playedCard);\n          return newState;\n        }\n\n        // 1) Dauerhaft-Initiative (Ongoing)\n        if (typeStr.includes('dauerhaft')) {\n          // Slot-Mapping: Dauerhaft-Initiativen â†’ map to permanentSlots.government or .public\n          // Prefer explicit metadata on the card, fallback to tag-based heuristic, default to 'government'\n          const preferredSlot: 'government' | 'public' = (specCard.permanentSlot as 'government' | 'public') || ((specCard.tags || []).includes('Public') ? 'public' : 'government');\n          if (!newState.permanentSlots[player][preferredSlot]) {\n            // ensure card is stored as a shallow clone to avoid accidental shared references\n            newState.permanentSlots[player] = { ...newState.permanentSlots[player], [preferredSlot]: { ...playedCard } } as any;\n            log(`P${player} spielt ${playedCard.name} als Dauerhafte Initiative (Slot: ${preferredSlot})`);\n          } else {\n            log(`âš ï¸ WARN: Slot occupied - Slot ${preferredSlot} already has ${newState.permanentSlots[player][preferredSlot]?.name}`);\n            // Return the card to hand and refund AP as graceful fallback\n            newState.hands[player] = [...newState.hands[player], playedCard];\n            newState.actionPoints[player] += cost;\n            return newState;\n          }\n\n          // 6) Karteneffekte enqueuen + Queue auflÃ¶sen\n          triggerCardEffects(newState, player, playedCard);\n          // Migration Helper verwenden\n          migrateLegacyQueue(newState);\n          // Nur noch _effectQueue verwenden\n          if (newState._effectQueue && newState._effectQueue.length > 0) {\n            try { log(`DEBUG: about to resolve queue (spec ongoing) -> ${JSON.stringify((newState._effectQueue as any).map((e:any)=>({type:e.type, amount:e.amount, msg:e.msg})).slice(0,50))}`); } catch(e) {}\n            log(`DEBUG AP before resolve (spec ongoing): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n            resolveQueue(newState, newState._effectQueue);\n            newState._effectQueue = [];\n            // Nach Queue-AuflÃ¶sung: Hand-Arrays immutabel neu zuweisen\n            afterQueueResolved?.();\n            log(`DEBUG AP after resolve (spec ongoing): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n          }\n\n          // Check for trap triggers\n          applyTrapsOnCardPlayed(\n            newState,\n            player,\n            playedCard,\n            (e) => (newState._effectQueue ??= []).push(e),\n            (m) => (newState._effectQueue ??= []).push({ type: 'LOG', msg: m })\n          );\n\n          return newState;\n        }\n\n        // 2) Sofort-/Sofort-Initiativen (Instant)\n        if (isInitiative) {\n          if (!specCard.effectKey) {\n            log(`âŒ Initiative ohne effectKey: ${specCard.name}`);\n          } else {\n            log(`ğŸ§© INIT: ${specCard.name} [${String(specCard.effectKey)}] gespielt`);\n          }\n\n          // ğŸ”§ NEU: Sofort-Initiativen werden in das sofort Array gelegt statt sofort aktiviert\n          if (typeStr.includes('sofort')) {\n            // PrÃ¼fe ob bereits eine Sofort-Initiative im Slot liegt\n            if (newState.board[player].sofort.length > 0) {\n              log(`âŒ ERROR: Sofort-Initiative-Slot bereits besetzt - ${newState.board[player].sofort[0]?.name} muss erst aktiviert werden`);\n              // Karte zurÃ¼ck in die Hand\n              newState.hands[player] = [...newState.hands[player], playedCard];\n              // AP zurÃ¼ckgeben\n              newState.actionPoints[player] += cost;\n              // AP zurÃ¼ckgegeben, keine Aktion rÃ¼ckgÃ¤ngig zu machen\n              return newState;\n            }\n\n            // Sofort-Initiative in das sofort Array legen\n            newState.board[player].sofort = [playedCard];\n            log(`ğŸ¯ P${player} legt ${playedCard.name} in Sofort-Initiative-Slot (kann spÃ¤ter aktiviert werden)`);\n\n            // Sofort-Initiativen: auf Board.sofort legen (nicht direkt entsorgen)\n            if (!newState._effectQueue) newState._effectQueue = [];\n            newState._effectQueue.push({ type: 'LOG', msg: `ğŸ”” Sofort-Initiative bereit: ${playedCard.name} (zum Aktivieren anklicken oder Taste 'A')` });\n            return newState;\n          }\n\n          // Dauerhaft-Initiativen werden weiterhin sofort aktiviert\n          // Initiative in den Ablagestapel\n          newState.discard = [...newState.discard, playedCard];\n          log(`P${player} spielt Initiative: ${playedCard.name}`);\n\n                     // 6) Karteneffekte enqueuen + Queue auflÃ¶sen\n          console.log('ğŸ”¥ ABOUT TO TRIGGER CARD EFFECTS (INITIATIVE):', playedCard.name, 'effectKey:', (playedCard as any).effectKey);\n           triggerCardEffects(newState, player, playedCard);\n           // Migration Helper verwenden\n           migrateLegacyQueue(newState);\n           // Nur noch _effectQueue verwenden\n         if (newState._effectQueue && newState._effectQueue.length > 0) {\n           resolveQueue(newState, newState._effectQueue);\n           newState._effectQueue = [];\n           // Nach Queue-AuflÃ¶sung: Hand-Arrays immutabel neu zuweisen\n           afterQueueResolved?.();\n         }\n\n           // Check for trap triggers\n           applyTrapsOnCardPlayed(\n             newState,\n             player,\n             playedCard,\n             (e) => (newState._effectQueue ??= []).push(e),\n             (m) => (newState._effectQueue ??= []).push({ type: 'LOG', msg: m })\n           );\n\n           // ğŸ”¥ CLUSTER 3: Auren-Flags neu berechnen (nach Kartenspielen)\n          recomputeAuraFlags(newState);\n\n          // ğŸ”¥ CLUSTER 3: Ai Weiwei Bonus wird bei Aktivierung angewendet (nicht beim Spielen)\n\n          // ğŸ”¥ PASSIVE EFFEKTE NACH INITIATIVE: Mark Zuckerberg & Sam Altman\n          // Diese Effekte werden jetzt Ã¼ber INITIATIVE_ACTIVATED Event + Board-Check gehandhabt\n          // Keine direkten Flag-Mutationen mehr - alles Ã¼ber Events\n\n\n          return newState;\n        }\n\n        // 3) Ã–ffentlichkeit (Public)\n        if (\n          typeStr === 'Ã¶ffentlichkeitskarte' ||\n          typeStr === 'oeffentlichkeitskarte' ||\n          typeStr === 'Ã¶ffentlichkeit' ||\n          typeStr === 'public'\n        ) {\n          if (newState.board[player].innen.length < 5) {\n            const innenArray = [...newState.board[player].innen, playedCard];\n            const playerBoardCloned = { ...newState.board[player], innen: innenArray } as any;\n            newState.board = { ...newState.board, [player]: playerBoardCloned } as any;\n            log(`P${player} spielt ${playedCard.name} in Ã–ffentlichkeit`);\n\n            // Sofort Auren prÃ¼fen (z.B. JF +1, wenn JF schon liegt)\n            applyAurasForPlayer(newState, player, log);\n\n                         // 6) Karteneffekte enqueuen + Queue auflÃ¶sen\n             triggerCardEffects(newState, player, playedCard);\n             // Migration Helper verwenden\n             migrateLegacyQueue(newState);\n         if (newState._effectQueue && newState._effectQueue.length > 0) {\n           resolveQueue(newState, newState._effectQueue);\n           newState._effectQueue = [];\n           // Nach Queue-AuflÃ¶sung: Hand-Arrays immutabel neu zuweisen\n           afterQueueResolved?.();\n         }\n\n             // Check for trap triggers\n             applyTrapsOnCardPlayed(\n               newState,\n               player,\n               playedCard,\n               (e) => (newState._effectQueue ??= []).push(e),\n               (m) => (newState._effectQueue ??= []).push({ type: 'LOG', msg: m })\n             );\n\n\n\n            // ğŸ”¥ PUBLIC CARD EFFECTS - Passive effects when played\n\n            // Helper function to draw a card for the player\n            const drawCardForPlayer = (cardName: string) => {\n              if (newState.decks[player].length > 0) {\n                const drawnCard = newState.decks[player].shift();\n                if (drawnCard) {\n                  newState.hands[player].push(drawnCard);\n                  log(`ğŸ”¥ ${cardName.toUpperCase()} EFFEKT: +1 Karte gezogen (${drawnCard.name})`);\n                  return true;\n                }\n              }\n              return false;\n            };\n\n            if (specCard.name === 'Elon Musk') {\n              // Effect: \"Ziehe 1 Karte. Deine erste Initiative pro Runde kostet 1 Aktionspunkt weniger.\"\n              drawCardForPlayer('Elon Musk');\n              // ğŸ”¥ QUEUE-SYSTEM: Erste Initiative pro Runde â†’ Refund wird Ã¼ber triggerCardEffects gehandhabt\n\n            } else if (specCard.name === 'Bill Gates') {\n              // Effect: \"Ziehe 1 Karte. Deine nÃ¤chste Initiative kostet 1 Aktionspunkt weniger.\"\n              drawCardForPlayer('Bill Gates');\n              // ğŸ”¥ QUEUE-SYSTEM: NÃ¤chste Initiative â†’ Refund wird Ã¼ber triggerCardEffects gehandhabt\n\n            } else if (specCard.name === 'Jeff Bezos') {\n              // Effect: \"Ziehe 1 Karte beim Ausspielen. Wenn eine Plattform liegt: +1 Aktionspunkt.\"\n              drawCardForPlayer('Jeff Bezos');\n              const hasPlatform = newState.board[player].innen.some(c =>\n                c.kind === 'spec' && (c as any).tag === 'Plattform'\n              );\n              if (hasPlatform) {\n                newState.actionPoints[player] += 1;\n                log(`ğŸ”¥ JEFF BEZOS: +1 AP durch Plattform-Synergie! (${newState.actionPoints[player] - 1} â†’ ${newState.actionPoints[player]})`);\n              }\n\n            } else if (specCard.name === 'Warren Buffett') {\n              // Effect: \"Ziehe 1 Karte. Bei einer Wirtschafts-Initiative: +1 Effekt.\"\n              drawCardForPlayer('Warren Buffett');\n              // TODO: Implement \"Wirtschafts-Initiative +1 Effect\" logic\n              log(`ğŸ“Š WARREN BUFFETT: Bei Wirtschafts-Initiativen +1 Effekt! (TODO: Implementierung)`);\n\n            } else if (specCard.name === 'Gautam Adani') {\n              // Effect: \"Ziehe 1 Karte. Bei einer Infrastruktur-Initiative: +1 Effekt.\"\n              drawCardForPlayer('Gautam Adani');\n              // TODO: Implement \"Infrastruktur-Initiative +1 Effect\" logic\n              log(`ğŸ“Š GAUTAM ADANI: Bei Infrastruktur-Initiativen +1 Effekt! (TODO: Implementierung)`);\n\n            } else if (specCard.name === 'Zhang Yiming') {\n              // Effect: \"Ziehe 1 Karte. Bei Medien auf dem Feld: -1 Aktionspunkt auf deine nÃ¤chste Initiative.\"\n              drawCardForPlayer('Zhang Yiming');\n              const hasMedia = newState.board[player].innen.some(c =>\n                c.kind === 'spec' && (c as any).tag === 'Medien'\n              );\n              if (hasMedia) {\n                // TODO: Implement \"nÃ¤chste Initiative -1 AP\" logic\n                log(`ğŸ”¥ ZHANG YIMING: NÃ¤chste Initiative kostet 1 AP weniger durch Medien-Synergie! (TODO: Implementierung)`);\n              }\n\n            } else if (specCard.name === 'George Soros') {\n              // Effect: \"+1 Aktionspunkt wenn der Gegner eine autoritÃ¤re Regierungskarte hat.\"\n              const opponent = player === 1 ? 2 : 1;\n              const hasAuthoritarianCard = newState.board[opponent].aussen.some(card => {\n                const polCard = card as any;\n                return polCard.tag === 'Staatsoberhaupt' && polCard.influence >= 8; // High influence leaders\n              });\n\n              if (hasAuthoritarianCard) {\n                newState.actionPoints[player] += 1;\n                log(`ğŸ”¥ GEORGE SOROS EFFEKT: +1 AP durch autoritÃ¤re Regierung des Gegners!`);\n                log(`ğŸ“Š SOROS: Aktionspunkte ${newState.actionPoints[player] - 1} â†’ ${newState.actionPoints[player]}`);\n              } else {\n                log(`ğŸ’­ George Soros: Keine autoritÃ¤ren Karten beim Gegner - Effekt nicht ausgelÃ¶st`);\n              }\n            }\n\n            // ğŸ”— NGO-Synergie: Wenn eine NGO gelegt wird und Joschka Fischer liegt, erhÃ¤lt P${player} +1 Einfluss (Rundenauswertung)\n            if ((specCard as any).tag === 'NGO') {\n              const hasJoschka = newState.board[player].aussen.some(c => c.kind === 'pol' && (c as any).name === 'Joschka Fischer' && !(c as any).deactivated);\n              if (hasJoschka) {\n                log(`ğŸ”¥ğŸ”¥ğŸ”¥ SYNERGIE AKTIVIERT! ğŸ”¥ğŸ”¥ğŸ”¥ Joschka Fischer + ${playedCard.name}[NGO] â†’ +1 Einfluss bei Rundenauswertung`);\n              }\n            }\n          } else {\n            log(`âŒ ERROR: Lane full - Ã–ffentlichkeit ist voll (5/5)`);\n          }\n\n          // Simplified AP system: No refunds\n          return newState;\n        }\n\n                  // 4) Default: Traps/Interventions\n                  // Falls Trap-Karte gelegt wird\n          if (playedCard.kind === 'spec' && (playedCard as any).type?.toLowerCase().includes('trap')) {\n            registerTrap(newState, player, playedCard.key || playedCard.name.toLowerCase().replace(/[- ]/g, '_'));\n            // NICHT sofort checken â€“ sie wartet auf den Gegner\n            return newState;\n          }\n\n        newState.traps[player] = [...newState.traps[player], playedCard];\n        log(`P${player} spielt ${playedCard.name} als ${specCard.type}`);\n\n        // 6) Karteneffekte enqueuen + Queue auflÃ¶sen\n        console.log('ğŸ”¥ ABOUT TO TRIGGER CARD EFFECTS:', playedCard.name, 'effectKey:', (playedCard as any).effectKey);\n        triggerCardEffects(newState, player, playedCard);\n        // Migration Helper verwenden\n        migrateLegacyQueue(newState);\n        // Nur noch _effectQueue verwenden\n        if (newState._effectQueue && newState._effectQueue.length > 0) {\n          try { log(`DEBUG: about to resolve queue (spec instant) -> ${JSON.stringify((newState._effectQueue as any).map((e:any)=>({type:e.type, amount:e.amount, msg:e.msg})).slice(0,50))}`); } catch(e) {}\n          log(`DEBUG AP before resolve (spec instant): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n          resolveQueue(newState, newState._effectQueue);\n          newState._effectQueue = [];\n          // Nach Queue-AuflÃ¶sung: Hand-Arrays immutabel neu zuweisen\n          afterQueueResolved?.();\n          log(`DEBUG AP after resolve (spec instant): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n        }\n\n        // Check for trap triggers\n        applyTrapsOnCardPlayed(\n          newState,\n          player,\n          playedCard,\n          (e) => (newState._effectQueue ??= []).push(e),\n          (m) => (newState._effectQueue ??= []).push({ type: 'LOG', msg: m })\n        );\n\n        // Simplified AP system: No refunds\n        return newState;\n      }\n\n      // 6) Karteneffekte enqueuen + Queue auflÃ¶sen (fallback fÃ¼r unbekannte Kartentypen)\n      triggerCardEffects(newState, player, selectedCard);\n      // Migration Helper verwenden\n      migrateLegacyQueue(newState);\n      // Nur noch _effectQueue verwenden\n        if (newState._effectQueue && newState._effectQueue.length > 0) {\n          try { log(`DEBUG: about to resolve queue (spec public/default) -> ${JSON.stringify((newState._effectQueue as any).map((e:any)=>({type:e.type, amount:e.amount, msg:e.msg})).slice(0,50))}`); } catch(e) {}\n          log(`DEBUG AP before resolve (spec public/default): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n          resolveQueue(newState, newState._effectQueue);\n          newState._effectQueue = [];\n          // Nach Queue-AuflÃ¶sung: Hand-Arrays immutabel neu zuweisen\n          afterQueueResolved?.();\n          log(`DEBUG AP after resolve (spec public/default): P1=${newState.actionPoints[1]} P2=${newState.actionPoints[2]}`);\n        }\n\n      // Check for trap triggers\n      applyTrapsOnCardPlayed(\n        newState,\n        player,\n        selectedCard,\n        (e) => (newState._effectQueue ??= []).push(e),\n        (m) => (newState._effectQueue ??= []).push({ type: 'LOG', msg: m })\n      );\n\n      // Simplified AP system: No refunds\n\n      // Kein Aktionenlimit mehr â†’ automatischer Turnwechsel entfÃ¤llt\n\n\n      return newState;\n    });\n  }, [setGameState, log]);\n\n  const activateInstantInitiative = useCallback((player: Player) => {\n    logger.info(`activateInstantInitiative START P${player}`);\n    setGameState(prev => {\n      if (prev.current !== player) {\n        log(`âŒ ERROR: Not player turn - Current: ${prev.current}, Attempted: ${player}`);\n        return prev;\n      }\n\n      const instantCard = prev.board[player].sofort[0];\n      if (!instantCard) {\n        log(`âŒ ERROR: No Sofort-Initiative in slot for player ${player}`);\n        return prev;\n      }\n\n      const newState = { ...prev };\n\n      // 1) Normale Karten-Effekte der Sofort-Karte feuern\n      triggerCardEffects(newState, player, instantCard);\n\n      // UI visual: initiative ripple + AP pop (prototype hook)\n      try {\n        const zones = (window as any).__politicardDebug?.clickZones || [];\n        const boardZone = zones.find((z: any) => z.data && z.data.type === 'row_slot');\n        const cx = boardZone ? boardZone.x + (boardZone.w || 256) / 2 : 960;\n        const cy = boardZone ? boardZone.y + (boardZone.h || 256) / 2 : 300;\n        if (visualEffects) {\n          visualEffects.spawnRipple(cx, cy, { radius: 640, showAp: true, apX: cx, apY: cy + 40 });\n          try {\n            const trigI = (window as any).__pc_triggerInstantAnim || (window as any).pc_triggerInstantAnim;\n            if (typeof trigI === 'function') trigI('1.instant.0');\n          } catch (e) {}\n        } else {\n          (window as any).__pc_ripples = (window as any).__pc_ripples || [];\n          (window as any).__pc_ripples.push({ cx, cy, started: performance.now(), duration: 700, radius: 640, showAp: true, apX: cx, apY: cy + 40 });\n        }\n      } catch (e) {}\n\n      // Check for trap triggers\n      applyTrapsOnCardPlayed(\n        newState,\n        player,\n        instantCard,\n        (e) => (newState._effectQueue ??= []).push(e),\n        (m) => (newState._effectQueue ??= []).push({ type: 'LOG', msg: m })\n      );\n\n      // 2) Queue auflÃ¶sen (BEVOR die Karte entfernt wird)\n      if (newState._effectQueue && newState._effectQueue.length > 0) {\n        resolveQueue(newState, [...newState._effectQueue]);\n        newState._effectQueue = [];\n        // Nach Queue-AuflÃ¶sung: Hand-Arrays immutabel neu zuweisen\n        afterQueueResolved?.();\n      }\n\n      // 3) Karte NACH Queue-AuflÃ¶sung in den Ablagestapel\n      const [played] = newState.board[player].sofort.splice(0, 1);\n      newState.discard.push(played);\n\n      // Visual: listen for dice roll event to animate & bind to SKANDALSPIRALE_TRIGGER if present\n      try {\n        const diceHandler = (ev: any) => {\n          try {\n            const face = ev.detail?.face;\n            if (face == null) return;\n            // If last enqueued event was SKANDALSPIRALE_TRIGGER, attach a LOG with the face\n            const last = (newState._effectQueue ?? []).slice(-1)[0];\n            // Emit a LOG event for visibility\n            if (!newState._effectQueue) newState._effectQueue = [];\n            newState._effectQueue.push({ type: 'LOG', msg: `WÃ¼rfel: ${face}` } as any);\n          } catch (e) {}\n        };\n        window.addEventListener('pc:dice_roll', diceHandler as EventListener);\n        // remove after short timeout to avoid leaking listeners\n        setTimeout(() => window.removeEventListener('pc:dice_roll', diceHandler as EventListener), 2000);\n      } catch (e) {}\n\n      return newState;\n    });\n  }, [setGameState, log]);\n\n  const endTurn = useCallback((reason: 'button_end_turn' | 'auto' = 'button_end_turn') => {\n    logger.info(`endTurn START reason=${reason}`);\n    setGameState((prev): GameState => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const current = prev.current;\n\n      // 1) Schon im Abschluss? -> Nichts tun (Idempotenz)\n      if (prev.isEndingTurn) {\n        log('ğŸ” Zugabschluss lÃ¤uft bereits â€“ warte auf Queue.');\n        return prev;\n      }\n\n      const newState = { ...prev, isEndingTurn: true };\n\n      // 2) HÃ¤ngen noch Effekte in der Queue? -> AuflÃ¶sen lassen\n      if (newState._effectQueue && newState._effectQueue.length > 0) {\n        log('â³ Effekte werden noch aufgelÃ¶st â€“ Zugwechsel folgt automatisch.');\n        resolveQueue(newState, [...newState._effectQueue]);\n        newState._effectQueue = [];\n        // Nach Queue-AuflÃ¶sung: Wenn Flag noch gesetzt, Zug beenden\n        if (newState.isEndingTurn) {\n          return reallyEndTurn(newState, log);\n        }\n        return newState;\n      }\n\n      // 3) Keine Effekte mehr -> sofort beenden\n      return reallyEndTurn(newState, log);\n    });\n  }, [setGameState, log]);\n\n  // Legacy: nextTurn als Alias fÃ¼r endTurn fÃ¼r KompatibilitÃ¤t\n  const nextTurn = useCallback(() => {\n    logger.info('nextTurn alias called');\n    endTurn('auto');\n  }, [endTurn]);\n\n  // Global listener: handle visual dice results and apply Skandalspirale effects automatically\n  useEffect(() => {\n    const handler = (ev: any) => {\n      const face = ev?.detail?.face;\n      if (typeof face !== 'number') return;\n      setGameState(prev => {\n        try {\n          const pending = (prev as any)._pendingSkandal as { player: Player; ts: number } | undefined;\n          if (!pending) return prev;\n          // only accept recent pending requests (avoid stale triggers)\n          if (Date.now() - (pending.ts || 0) > 8000) {\n            const n = { ...prev } as GameState & any;\n            delete n._pendingSkandal;\n            return n;\n          }\n\n          const newState = { ...prev } as GameState & any;\n          // clear pending marker\n          delete newState._pendingSkandal;\n\n          // Prepare events based on face\n          newState._effectQueue = newState._effectQueue || [];\n          if (face >= 1 && face <= 3) {\n            const loss = face;\n            // enqueue negative buff (debuff) on disadvantaged player's strongest gov\n            newState._effectQueue.push({ type: 'BUFF_STRONGEST_GOV', player: pending.player, amount: -loss } as any);\n            newState._effectQueue.push({ type: 'LOG', msg: `Skandalspirale: Spieler ${pending.player} wÃ¼rfelt ${face} â†’ stÃ¤rkste Regierung -${loss}.` } as any);\n          } else {\n            newState._effectQueue.push({ type: 'LOG', msg: `Skandalspirale: Spieler ${pending.player} wÃ¼rfelt ${face} â†’ Keine Auswirkung.` } as any);\n          }\n\n          // Resolve immediately so effect is visible without waiting\n          if (newState._effectQueue && newState._effectQueue.length > 0) {\n            try { resolveQueue(newState, [...newState._effectQueue]); } catch (e) { logger.dbg('resolveQueue failed on dice handler', e); }\n            newState._effectQueue = [];\n          }\n\n          // Ensure React sees shallow-copied hands for UI update\n          try {\n            newState.hands = { 1: [...newState.hands[1]], 2: [...newState.hands[2]] };\n          } catch (e) {}\n\n          // run after-queue hook if provided (best-effort)\n          try { if ((window as any).__afterQueueResolved) (window as any).__afterQueueResolved(); } catch (e) {}\n\n          return newState;\n        } catch (err) {\n          logger.dbg('dice handler setGameState error', err);\n          return prev;\n        }\n      });\n    };\n\n    window.addEventListener('pc:dice_roll', handler as EventListener);\n    return () => window.removeEventListener('pc:dice_roll', handler as EventListener);\n  }, [setGameState]);\n\n    const passTurn = useCallback((player: Player) => {\n    logger.info(`passTurn START P${player}`);\n\n    setGameState(prev => {\n      logger.dbg(`passTurn setState current=${prev.current} player=${player}`);\n\n      if (prev.current !== player) {\n        logger.dbg(`passTurn wrong turn current=${prev.current} attempted=${player}`);\n        return prev;\n      }\n\n      const newState = { ...prev, passed: { ...prev.passed, [player]: true } };\n      logger.dbg(`Pass status updated P1=${newState.passed[1]} P2=${newState.passed[2]}`);\n      log(`ğŸš« Spieler ${player} passt.`);\n\n      // â— Kein Nachziehen bei Pass:\n      // Der passierende Spieler kommt in dieser Runde nicht mehr dran.\n      // Die nÃ¤chste Runde startet ohnehin mit 5 neuen Handkarten.\n\n      // Check if round should end (both players passed)\n      const shouldEndRound = checkRoundEnd(newState);\n      logger.dbg(`Should end round? ${shouldEndRound}`);\n\n      if (shouldEndRound) {\n        log(`ğŸ Runde ${newState.round} wird beendet und ausgewertet.`);\n        return resolveRound(newState, log);\n      } else {\n        // Switch turn to other player for their final chance\n        const otherPlayer: Player = player === 1 ? 2 : 1;\n        logger.dbg(`Switching to other player ${otherPlayer} hasPassed=${newState.passed[otherPlayer]}`);\n\n        // Only switch if other player hasn't passed yet\n        if (!newState.passed[otherPlayer]) {\n                     newState.current = otherPlayer;\n           newState.actionPoints = { ...newState.actionPoints, [otherPlayer]: 2 };\n\n          // Apply new start-of-turn hooks\n          applyStartOfTurnFlags(newState, otherPlayer, log);\n\n        // ğŸ”¥ CLUSTER 3: Auren-Flags beim Zugstart neu berechnen\n        recomputeAuraFlags(newState);\n\n          log(`â­ï¸ Spieler ${otherPlayer} hat noch einen letzten Zug.`);\n          logger.dbg(`Turn switched to player ${otherPlayer}`);\n        } else {\n          // Both players have passed now, end round\n          log(`ğŸ Runde ${newState.round} wird beendet (beide Spieler haben gepasst).`);\n          return resolveRound(newState, log);\n        }\n      }\n\n      return newState;\n    });\n  }, [setGameState, log]);\n\n  return {\n    startMatchWithDecks,\n    startMatchVsAI,\n    playCard,\n    activateInstantInitiative,\n    passTurn,\n    nextTurn,\n    endTurn,\n  };\n  }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}