{"ast":null,"code":"// src/qte/atlasLoader.ts - simple runtime loader for TexturePacker JSON (ARRAY) format\n// The JSON layout we expect (TexturePacker \"JSON (Hash)\" or \"JSON (Array)\" works):\n// {\n//   \"frames\": {\n//      \"idle_0\": { \"frame\": {\"x\":0,\"y\":0,\"w\":256,\"h\":256}, ... },\n//      \"idle_1\": {...},\n//      \"walk_0\": {...}\n//   },\n//   \"meta\": { \"image\": \"atlas.png\" }\n// }\n// Each frame key is expected to be <state>_<index> (index starting at 0).\n// We group them into an array per state and keep the order of index.\n\nexport async function loadAtlas(basePath) {\n  // basePath may be a directory or a path to a JSON file (e.g. \"/qte/ninja\" or \"/qte/ninja/atlas2.json\")\n  const cacheBuster = Date.now();\n  const candidates = [];\n  if (basePath.match(/\\.json$/i)) {\n    candidates.push(basePath);\n  } else {\n    candidates.push(`${basePath}/atlas.json`);\n    candidates.push(`${basePath}.json`);\n    // allow explicit atlas2 naming (common in this project)\n    candidates.push(`${basePath}/atlas2.json`);\n    candidates.push(`${basePath}/atlas2`);\n  }\n  let text = null;\n  let usedJsonUrl = null;\n  const tried = [];\n  for (const cand of candidates) {\n    const url = `${cand}?v=${cacheBuster}`;\n    tried.push(url);\n    console.log(`[atlas] Trying ${url}`);\n    try {\n      const res = await fetch(url);\n      if (!res.ok) {\n        console.log(`[atlas] ${url} responded ${res.status}`);\n        continue;\n      }\n      const contentType = res.headers.get('content-type') || '';\n      const body = await res.text();\n      // If server returned HTML (e.g. index.html), skip and try next candidate\n      if (contentType.includes('text/html') || body.trim().startsWith('<!DOCTYPE')) {\n        console.warn(`[atlas] ${url} looks like HTML (skipping)`);\n        continue;\n      }\n      text = body;\n      usedJsonUrl = url.replace(/\\?v=\\d+$/, '');\n      console.log(`[atlas] Loaded JSON from ${url} (len=${text.length})`);\n      break;\n    } catch (e) {\n      console.warn(`[atlas] fetch failed for ${url}`, e);\n      continue;\n    }\n  }\n  if (!text || !usedJsonUrl) {\n    throw new Error(`Atlas JSON not found. Tried: ${tried.join(', ')}`);\n  }\n  console.log(`[atlas] JSON response length: ${text.length}, starts with: ${text.substring(0, 100)}`);\n  let data;\n  try {\n    data = JSON.parse(text);\n  } catch (e) {\n    console.error(`[atlas] JSON parse error:`, e);\n    console.error(`[atlas] Invalid JSON text:`, text.substring(0, 200));\n    throw e;\n  }\n  const framesData = data.frames;\n  const meta = data.meta || {};\n  // compute base directory from usedJsonUrl\n  const baseDir = usedJsonUrl.replace(/\\/[^\\/]*$/, '');\n  const imgPath = `${baseDir}/${meta.image || 'atlas.png'}?v=${cacheBuster}`;\n  console.log(`[atlas] Loading image ${imgPath}`);\n  const image = await loadImage(imgPath);\n  const stateMap = {};\n  for (const key in framesData) {\n    const state = key.replace(/_\\d+$/, \"\");\n    const idxMatch = /_(\\d+)$/.exec(key);\n    const idx = idxMatch ? parseInt(idxMatch[1], 10) : 0;\n    if (!stateMap[state]) stateMap[state] = [];\n    const f = framesData[key].frame;\n    stateMap[state][idx] = {\n      x: f.x,\n      y: f.y,\n      w: f.w,\n      h: f.h\n    };\n  }\n\n  // Determine frame size from first frame\n  const firstState = Object.keys(stateMap)[0];\n  const firstFrame = firstState ? stateMap[firstState][0] : {\n    w: 64,\n    h: 64\n  };\n  const animations = {};\n  for (const s of Object.keys(stateMap)) {\n    animations[s] = {\n      frames: stateMap[s],\n      fps: 12,\n      loop: s !== 'attack' && s !== 'parry'\n    };\n  }\n  return {\n    image,\n    animations,\n    frameW: firstFrame.w,\n    frameH: firstFrame.h\n  };\n}\nfunction loadImage(src) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n}","map":{"version":3,"names":["loadAtlas","basePath","cacheBuster","Date","now","candidates","match","push","text","usedJsonUrl","tried","cand","url","console","log","res","fetch","ok","status","contentType","headers","get","body","includes","trim","startsWith","warn","replace","length","e","Error","join","substring","data","JSON","parse","error","framesData","frames","meta","baseDir","imgPath","image","loadImage","stateMap","key","state","idxMatch","exec","idx","parseInt","f","frame","x","y","w","h","firstState","Object","keys","firstFrame","animations","s","fps","loop","frameW","frameH","src","Promise","resolve","reject","img","Image","onload","onerror"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/qte/atlasLoader.ts"],"sourcesContent":["// src/qte/atlasLoader.ts - simple runtime loader for TexturePacker JSON (ARRAY) format\n// The JSON layout we expect (TexturePacker \"JSON (Hash)\" or \"JSON (Array)\" works):\n// {\n//   \"frames\": {\n//      \"idle_0\": { \"frame\": {\"x\":0,\"y\":0,\"w\":256,\"h\":256}, ... },\n//      \"idle_1\": {...},\n//      \"walk_0\": {...}\n//   },\n//   \"meta\": { \"image\": \"atlas.png\" }\n// }\n// Each frame key is expected to be <state>_<index> (index starting at 0).\n// We group them into an array per state and keep the order of index.\n\nexport interface Rect { x: number; y: number; w: number; h: number }\nexport interface AtlasAnimation {\n  frames: Rect[];\n  fps: number;\n  loop: boolean;\n}\n\nexport interface LoadedAtlas {\n  image: HTMLImageElement;\n  animations: Record<string, AtlasAnimation>;\n  frameW: number;\n  frameH: number;\n}\n\nexport async function loadAtlas(basePath: string): Promise<LoadedAtlas> {\n  // basePath may be a directory or a path to a JSON file (e.g. \"/qte/ninja\" or \"/qte/ninja/atlas2.json\")\n  const cacheBuster = Date.now();\n\n  const candidates: string[] = [];\n  if (basePath.match(/\\.json$/i)) {\n    candidates.push(basePath);\n  } else {\n    candidates.push(`${basePath}/atlas.json`);\n    candidates.push(`${basePath}.json`);\n    // allow explicit atlas2 naming (common in this project)\n    candidates.push(`${basePath}/atlas2.json`);\n    candidates.push(`${basePath}/atlas2`);\n  }\n\n  let text: string | null = null;\n  let usedJsonUrl: string | null = null;\n  const tried: string[] = [];\n\n  for (const cand of candidates) {\n    const url = `${cand}?v=${cacheBuster}`;\n    tried.push(url);\n    console.log(`[atlas] Trying ${url}`);\n    try {\n      const res = await fetch(url);\n      if (!res.ok) {\n        console.log(`[atlas] ${url} responded ${res.status}`);\n        continue;\n      }\n\n      const contentType = res.headers.get('content-type') || '';\n      const body = await res.text();\n      // If server returned HTML (e.g. index.html), skip and try next candidate\n      if (contentType.includes('text/html') || body.trim().startsWith('<!DOCTYPE')) {\n        console.warn(`[atlas] ${url} looks like HTML (skipping)`);\n        continue;\n      }\n\n      text = body;\n      usedJsonUrl = url.replace(/\\?v=\\d+$/, '');\n      console.log(`[atlas] Loaded JSON from ${url} (len=${text.length})`);\n      break;\n    } catch (e) {\n      console.warn(`[atlas] fetch failed for ${url}`, e);\n      continue;\n    }\n  }\n\n  if (!text || !usedJsonUrl) {\n    throw new Error(`Atlas JSON not found. Tried: ${tried.join(', ')}`);\n  }\n\n  console.log(`[atlas] JSON response length: ${text.length}, starts with: ${text.substring(0, 100)}`);\n\n  let data: any;\n  try {\n    data = JSON.parse(text);\n  } catch (e) {\n    console.error(`[atlas] JSON parse error:`, e);\n    console.error(`[atlas] Invalid JSON text:`, text.substring(0, 200));\n    throw e;\n  }\n\n  const framesData = data.frames;\n  const meta = data.meta || {};\n  // compute base directory from usedJsonUrl\n  const baseDir = usedJsonUrl.replace(/\\/[^\\/]*$/, '');\n  const imgPath = `${baseDir}/${meta.image || 'atlas.png'}?v=${cacheBuster}`;\n  console.log(`[atlas] Loading image ${imgPath}`);\n  const image = await loadImage(imgPath);\n\n  const stateMap: Record<string, Rect[]> = {};\n  for (const key in framesData) {\n    const state = key.replace(/_\\d+$/, \"\");\n    const idxMatch = /_(\\d+)$/.exec(key);\n    const idx = idxMatch ? parseInt(idxMatch[1], 10) : 0;\n    if (!stateMap[state]) stateMap[state] = [];\n    const f = framesData[key].frame as { x: number; y: number; w: number; h: number };\n    stateMap[state][idx] = { x: f.x, y: f.y, w: f.w, h: f.h };\n  }\n\n  // Determine frame size from first frame\n  const firstState = Object.keys(stateMap)[0];\n  const firstFrame = firstState ? stateMap[firstState][0] : { w: 64, h: 64 };\n\n  const animations: Record<string, AtlasAnimation> = {};\n  for (const s of Object.keys(stateMap)) {\n    animations[s] = { frames: stateMap[s], fps: 12, loop: s !== 'attack' && s !== 'parry' };\n  }\n\n  return { image, animations, frameW: firstFrame.w, frameH: firstFrame.h };\n}\n\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}