{"ast":null,"code":"// src/qte/atlasLoader.ts - simple runtime loader for TexturePacker JSON (ARRAY) format\n// The JSON layout we expect (TexturePacker \"JSON (Hash)\" or \"JSON (Array)\" works):\n// {\n//   \"frames\": {\n//      \"idle_0\": { \"frame\": {\"x\":0,\"y\":0,\"w\":256,\"h\":256}, ... },\n//      \"idle_1\": {...},\n//      \"walk_0\": {...}\n//   },\n//   \"meta\": { \"image\": \"atlas.png\" }\n// }\n// Each frame key is expected to be <state>_<index> (index starting at 0).\n// We group them into an array per state and keep the order of index.\nexport async function loadAtlas(basePath){// Expects `${basePath}/atlas.json` and `${basePath}/atlas.png`\nconst jsonUrl=\"\".concat(basePath,\"/atlas.json\");const res=await fetch(jsonUrl);if(!res.ok)throw new Error(\"Atlas JSON not found \".concat(jsonUrl));const data=await res.json();const framesData=data.frames;const meta=data.meta||{};const imgPath=\"\".concat(basePath,\"/\").concat(meta.image||'atlas.png');const image=await loadImage(imgPath);const stateMap={};for(const key in framesData){const state=key.replace(/_\\d+$/,\"\");const idxMatch=/_(\\d+)$/.exec(key);const idx=idxMatch?parseInt(idxMatch[1],10):0;if(!stateMap[state])stateMap[state]=[];const f=framesData[key].frame;stateMap[state][idx]={x:f.x,y:f.y,w:f.w,h:f.h};}// Determine frame size from first frame\nconst firstState=Object.keys(stateMap)[0];const firstFrame=firstState?stateMap[firstState][0]:{w:64,h:64};const animations={};for(const s of Object.keys(stateMap)){animations[s]={frames:stateMap[s],fps:12,loop:s!=='attack'&&s!=='parry'};}return{image,animations,frameW:firstFrame.w,frameH:firstFrame.h};}function loadImage(src){return new Promise((resolve,reject)=>{const img=new Image();img.onload=()=>resolve(img);img.onerror=reject;img.src=src;});}","map":{"version":3,"names":["loadAtlas","basePath","jsonUrl","concat","res","fetch","ok","Error","data","json","framesData","frames","meta","imgPath","image","loadImage","stateMap","key","state","replace","idxMatch","exec","idx","parseInt","f","frame","x","y","w","h","firstState","Object","keys","firstFrame","animations","s","fps","loop","frameW","frameH","src","Promise","resolve","reject","img","Image","onload","onerror"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/qte/atlasLoader.ts"],"sourcesContent":["// src/qte/atlasLoader.ts - simple runtime loader for TexturePacker JSON (ARRAY) format\r\n// The JSON layout we expect (TexturePacker \"JSON (Hash)\" or \"JSON (Array)\" works):\r\n// {\r\n//   \"frames\": {\r\n//      \"idle_0\": { \"frame\": {\"x\":0,\"y\":0,\"w\":256,\"h\":256}, ... },\r\n//      \"idle_1\": {...},\r\n//      \"walk_0\": {...}\r\n//   },\r\n//   \"meta\": { \"image\": \"atlas.png\" }\r\n// }\r\n// Each frame key is expected to be <state>_<index> (index starting at 0).\r\n// We group them into an array per state and keep the order of index.\r\n\r\nexport interface Rect { x: number; y: number; w: number; h: number }\r\nexport interface AtlasAnimation {\r\n  frames: Rect[];\r\n  fps: number;\r\n  loop: boolean;\r\n}\r\n\r\nexport interface LoadedAtlas {\r\n  image: HTMLImageElement;\r\n  animations: Record<string, AtlasAnimation>;\r\n  frameW: number;\r\n  frameH: number;\r\n}\r\n\r\nexport async function loadAtlas(basePath: string): Promise<LoadedAtlas> {\r\n  // Expects `${basePath}/atlas.json` and `${basePath}/atlas.png`\r\n  const jsonUrl = `${basePath}/atlas.json`;\r\n  const res = await fetch(jsonUrl);\r\n  if (!res.ok) throw new Error(`Atlas JSON not found ${jsonUrl}`);\r\n  const data = await res.json();\r\n  const framesData = data.frames;\r\n  const meta = data.meta || {};\r\n  const imgPath = `${basePath}/${meta.image || 'atlas.png'}`;\r\n  const image = await loadImage(imgPath);\r\n\r\n  const stateMap: Record<string, Rect[]> = {};\r\n  for (const key in framesData) {\r\n    const state = key.replace(/_\\d+$/, \"\");\r\n    const idxMatch = /_(\\d+)$/.exec(key);\r\n    const idx = idxMatch ? parseInt(idxMatch[1], 10) : 0;\r\n    if (!stateMap[state]) stateMap[state] = [];\r\n    const f = framesData[key].frame as { x: number; y: number; w: number; h: number };\r\n    stateMap[state][idx] = { x: f.x, y: f.y, w: f.w, h: f.h };\r\n  }\r\n\r\n  // Determine frame size from first frame\r\n  const firstState = Object.keys(stateMap)[0];\r\n  const firstFrame = firstState ? stateMap[firstState][0] : { w: 64, h: 64 };\r\n\r\n  const animations: Record<string, AtlasAnimation> = {};\r\n  for (const s of Object.keys(stateMap)) {\r\n    animations[s] = { frames: stateMap[s], fps: 12, loop: s !== 'attack' && s !== 'parry' };\r\n  }\r\n\r\n  return { image, animations, frameW: firstFrame.w, frameH: firstFrame.h };\r\n}\r\n\r\nfunction loadImage(src: string): Promise<HTMLImageElement> {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.onload = () => resolve(img);\r\n    img.onerror = reject;\r\n    img.src = src;\r\n  });\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}