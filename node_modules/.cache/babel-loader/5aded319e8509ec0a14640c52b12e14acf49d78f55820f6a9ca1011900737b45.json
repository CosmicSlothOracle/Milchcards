{"ast":null,"code":"import { getCardImagePath, Pols, Specials } from '../data/gameData';\nimport { makePolInstance, makeSpecInstance } from './cardUtils';\nimport { makeUid } from './id';\nimport { getLaneCapacity } from '../ui/layout';\n\n// Re-export helpers from effectUtils\nexport { EffectQueueManager, ActiveAbilitiesManager, tryApplyNegativeEffect } from './effectUtils';\n\n// Re-export helpers from cardUtils\nexport { makePolInstance, makeSpecInstance, sortHandCards, adjustInfluence, findCardLocation, getAllowedLaneForCard, isLaneAllowedForCard, getCardActionPointCost } from './cardUtils';\n\n// Helper functions\nexport function ceil(x) {\n  return Math.ceil(x);\n}\nexport function pow(a, b) {\n  return Math.pow(a, b);\n}\nexport function calcBP(influence, T) {\n  return ceil(pow(influence, 1.4) + 2 * T);\n}\nexport function shuffle(a) {\n  for (let i = a.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [a[i], a[j]] = [a[j], a[i]];\n  }\n  return a;\n}\n\n// Game logic helpers\nexport function sumRow(arr) {\n  return arr.reduce((a, c) => {\n    if (c.kind === 'pol') {\n      return a + c.influence; // üî• VEREINFACHT: Nur noch influence\n    }\n    return a; // Special cards don't contribute to influence\n  }, 0);\n}\n\n// Unified scoring: Government influence including permanent auras and Joschka+NGO synergy\nexport function sumGovernmentInfluenceWithAuras(state, player) {\n  const govCards = state.board[player].aussen.filter(c => c.kind === 'pol');\n  // Opponent reference kept for completeness of future aura checks\n\n  let total = 0;\n  const govSlot = state.permanentSlots[player].government;\n  const pubSlot = state.permanentSlots[player].public;\n  govCards.forEach(card => {\n    let influence = card.influence;\n\n    // Koalitionszwang: Tier 2 Regierungskarten +1 Einfluss\n    if ((govSlot === null || govSlot === void 0 ? void 0 : govSlot.kind) === 'spec' && govSlot.name === 'Koalitionszwang') {\n      if (card.T === 2) influence += 1;\n    }\n\n    // Napoleon Komplex: Tier 1 Regierungskarten +1 Einfluss\n    if ((govSlot === null || govSlot === void 0 ? void 0 : govSlot.kind) === 'spec' && govSlot.name === 'Napoleon Komplex') {\n      if (card.T === 1) influence += 1;\n    }\n\n    // Zivilgesellschaft: Bewegung-Karten +1 Einfluss (wenn eine Bewegung in √ñffentlichkeit liegt)\n    if ((pubSlot === null || pubSlot === void 0 ? void 0 : pubSlot.kind) === 'spec' && pubSlot.name === 'Zivilgesellschaft') {\n      const bewegungNames = ['Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'];\n      const hasBewegung = state.board[player].innen.some(c => c.kind === 'spec' && c.type === '√ñffentlichkeitskarte' && bewegungNames.includes(c.name));\n      if (hasBewegung) influence += 1;\n    }\n\n    // Joschka Fischer NGO-Boost: +1 Einfluss, wenn eine NGO-√ñffentlichkeitskarte liegt\n    if (card.name === 'Joschka Fischer' && card.effect === 'ngo_boost') {\n      const hasNgoCard = state.board[player].innen.some(c => c.kind === 'spec' && c.type === '√ñffentlichkeitskarte' && c.tag === 'NGO');\n      if (hasNgoCard) influence += 1;\n    }\n\n    // Milchglas Transparenz: +1 Einfluss wenn keine NGO/Bewegung liegt\n    if ((govSlot === null || govSlot === void 0 ? void 0 : govSlot.kind) === 'spec' && govSlot.name === 'Milchglas Transparenz') {\n      const ngoMovementNames = ['Jennifer Doudna', 'Noam Chomsky', 'Bill Gates', 'Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'];\n      const hasNgoMovement = state.board[player].innen.some(c => c.kind === 'spec' && c.type === '√ñffentlichkeitskarte' && ngoMovementNames.includes(c.name));\n      if (!hasNgoMovement) influence += 1;\n    }\n\n    // üî• CLUSTER 3: Aura-Effekte (on-demand Board-Check)\n    // Legacy flag-based aura checks removed - auras are now calculated on-demand\n\n    // Aura effects are now handled via Board-Check in the respective resolvers\n    // No more flag-based aura calculations - everything is event-driven\n\n    // Alternative Fakten is applied within interventions; no direct change here\n\n    total += influence;\n  });\n  return total;\n}\nexport function drawCards(player, count, state, log) {\n  const deck = [...state.decks[player]];\n  const hand = [...state.hands[player]];\n  const drawn = deck.splice(0, Math.min(count, deck.length));\n  hand.push(...drawn);\n  if (drawn.length > 0) {\n    log(`P${player} zieht ${drawn.length} Karte(n)`);\n  }\n  return {\n    newHands: {\n      ...state.hands,\n      [player]: hand\n    },\n    newDecks: {\n      ...state.decks,\n      [player]: deck\n    }\n  };\n}\nexport function drawCardsAtRoundEnd(state, log) {\n  let newHands = {\n    ...state.hands\n  };\n  let newDecks = {\n    ...state.decks\n  };\n  [1, 2].forEach(player => {\n    const targetHandSize = 5;\n    const currentHandSize = newHands[player].length;\n    let drawCount = Math.max(0, targetHandSize - currentHandSize);\n\n    // üî• MUKESH AMBANI EFFEKT: Gegner darf 1 Karte weniger nachziehen\n    const opponent = player === 1 ? 2 : 1;\n    const opponentBoard = state.board[opponent];\n    const mukeshAmbani = opponentBoard.innen.find(card => card.kind === 'spec' && card.name === 'Mukesh Ambani');\n    if (mukeshAmbani && drawCount > 0) {\n      drawCount = Math.max(0, drawCount - 1);\n      log(`üî• MUKESH AMBANI EFFEKT: P${player} zieht 1 Karte weniger (${drawCount} statt ${drawCount + 1})`);\n    }\n    if (drawCount > 0) {\n      const result = drawCards(player, drawCount, {\n        ...state,\n        hands: newHands,\n        decks: newDecks\n      }, log);\n      newHands = result.newHands;\n      newDecks = result.newDecks;\n    }\n  });\n  return {\n    newHands,\n    newDecks\n  };\n}\n\n// Deck building utilities\nexport function currentBuilderBudget(deck) {\n  return deck.reduce((sum, entry) => {\n    if (entry.kind === 'pol') {\n      const pol = entry.base;\n      return sum + ((pol === null || pol === void 0 ? void 0 : pol.BP) || 0) * entry.count;\n    } else {\n      const spec = entry.base;\n      return sum + ((spec === null || spec === void 0 ? void 0 : spec.bp) || 0) * entry.count;\n    }\n  }, 0);\n}\nexport function currentBuilderCount(deck) {\n  return deck.reduce((sum, entry) => sum + entry.count, 0);\n}\nexport function buildDeckFromEntries(entries) {\n  const deck = [];\n  entries.forEach(entry => {\n    for (let i = 0; i < entry.count; i++) {\n      if (entry.kind === 'pol') {\n        // Support both base object (deckbuilder) and baseId (presets)\n        const base = entry.base || (entry.baseId ? Pols.find(p => p.id === entry.baseId) : null);\n        if (base) deck.push(makePolInstance(base));\n      } else {\n        // Support both base object (deckbuilder) and baseId (presets)\n        const base = entry.base || (entry.baseId ? Specials.find(s => s.id === entry.baseId) : null);\n        if (base) deck.push(makeSpecInstance(base));\n      }\n    }\n  });\n\n  // Stelle sicher, dass jede Karte eine uid besitzt\n  const deckWithUids = deck.map(c => c && c.uid ? c : {\n    ...c,\n    uid: makeUid('card')\n  });\n  return shuffle(deckWithUids);\n}\n\n// Image loading utilities (Legacy function for backwards compatibility)\nexport function drawCardImage(ctx, card, dx, dy, size, imageSize = 'ui') {\n  const img = new Image();\n  img.onload = () => {\n    ctx.drawImage(img, dx, dy, size, size);\n  };\n  img.src = getCardImagePath(card, imageSize);\n}\n\n// Kapazit√§tspr√ºfung f√ºr Reihen (verhindert zu viele Karten in kleinen Rows)\nexport function canPlayToLane(state, player, lane) {\n  var _state$board$player$i, _state$board$player, _state$board$player$a, _state$board$player2;\n  const cap = getLaneCapacity(lane);\n  const row = lane === 'public' ? (_state$board$player$i = (_state$board$player = state.board[player]) === null || _state$board$player === void 0 ? void 0 : _state$board$player.innen) !== null && _state$board$player$i !== void 0 ? _state$board$player$i : [] : (_state$board$player$a = (_state$board$player2 = state.board[player]) === null || _state$board$player2 === void 0 ? void 0 : _state$board$player2.aussen) !== null && _state$board$player$a !== void 0 ? _state$board$player$a : [];\n  return row.length < cap;\n}","map":{"version":3,"names":["getCardImagePath","Pols","Specials","makePolInstance","makeSpecInstance","makeUid","getLaneCapacity","EffectQueueManager","ActiveAbilitiesManager","tryApplyNegativeEffect","sortHandCards","adjustInfluence","findCardLocation","getAllowedLaneForCard","isLaneAllowedForCard","getCardActionPointCost","ceil","x","Math","pow","a","b","calcBP","influence","T","shuffle","i","length","j","floor","random","sumRow","arr","reduce","c","kind","sumGovernmentInfluenceWithAuras","state","player","govCards","board","aussen","filter","total","govSlot","permanentSlots","government","pubSlot","public","forEach","card","name","bewegungNames","hasBewegung","innen","some","type","includes","effect","hasNgoCard","tag","ngoMovementNames","hasNgoMovement","drawCards","count","log","deck","decks","hand","hands","drawn","splice","min","push","newHands","newDecks","drawCardsAtRoundEnd","targetHandSize","currentHandSize","drawCount","max","opponent","opponentBoard","mukeshAmbani","find","result","currentBuilderBudget","sum","entry","pol","base","BP","spec","bp","currentBuilderCount","buildDeckFromEntries","entries","baseId","p","id","s","deckWithUids","map","uid","drawCardImage","ctx","dx","dy","size","imageSize","img","Image","onload","drawImage","src","canPlayToLane","lane","_state$board$player$i","_state$board$player","_state$board$player$a","_state$board$player2","cap","row"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/utils/gameUtils.ts"],"sourcesContent":["import { Card, PoliticianCard, SpecialCard, GameState, Player } from '../types/game';\r\nimport { getCardImagePath, Pols, Specials } from '../data/gameData';\r\nimport { makePolInstance, makeSpecInstance } from './cardUtils';\r\nimport { makeUid } from './id';\r\nimport { getLaneCapacity } from '../ui/layout';\r\n\r\n// Re-export helpers from effectUtils\r\nexport { EffectQueueManager, ActiveAbilitiesManager, tryApplyNegativeEffect } from './effectUtils';\r\n\r\n// Re-export helpers from cardUtils\r\nexport {\r\n  makePolInstance,\r\n  makeSpecInstance,\r\n  sortHandCards,\r\n  adjustInfluence,\r\n  findCardLocation,\r\n  getAllowedLaneForCard,\r\n  isLaneAllowedForCard,\r\n  getCardActionPointCost\r\n} from './cardUtils';\r\n\r\n// Helper functions\r\nexport function ceil(x: number): number {\r\n  return Math.ceil(x);\r\n}\r\n\r\nexport function pow(a: number, b: number): number {\r\n  return Math.pow(a, b);\r\n}\r\n\r\nexport function calcBP(influence: number, T: number): number {\r\n  return ceil(pow(influence, 1.4) + 2 * T);\r\n}\r\n\r\nexport function shuffle<T>(a: T[]): T[] {\r\n  for (let i = a.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [a[i], a[j]] = [a[j], a[i]];\r\n  }\r\n  return a;\r\n}\r\n\r\n// Game logic helpers\r\nexport function sumRow(arr: Card[]): number {\r\n  return arr.reduce((a, c) => {\r\n    if (c.kind === 'pol') {\r\n      return a + (c as PoliticianCard).influence; // üî• VEREINFACHT: Nur noch influence\r\n    }\r\n    return a; // Special cards don't contribute to influence\r\n  }, 0);\r\n}\r\n\r\n// Unified scoring: Government influence including permanent auras and Joschka+NGO synergy\r\nexport function sumGovernmentInfluenceWithAuras(state: GameState, player: Player): number {\r\n  const govCards = state.board[player].aussen.filter(c => c.kind === 'pol') as PoliticianCard[];\r\n  // Opponent reference kept for completeness of future aura checks\r\n\r\n  let total = 0;\r\n\r\n  const govSlot = state.permanentSlots[player].government;\r\n  const pubSlot = state.permanentSlots[player].public;\r\n\r\n  govCards.forEach(card => {\r\n    let influence = card.influence;\r\n\r\n    // Koalitionszwang: Tier 2 Regierungskarten +1 Einfluss\r\n    if (govSlot?.kind === 'spec' && (govSlot as SpecialCard).name === 'Koalitionszwang') {\r\n      if (card.T === 2) influence += 1;\r\n    }\r\n\r\n    // Napoleon Komplex: Tier 1 Regierungskarten +1 Einfluss\r\n    if (govSlot?.kind === 'spec' && (govSlot as SpecialCard).name === 'Napoleon Komplex') {\r\n      if (card.T === 1) influence += 1;\r\n    }\r\n\r\n    // Zivilgesellschaft: Bewegung-Karten +1 Einfluss (wenn eine Bewegung in √ñffentlichkeit liegt)\r\n    if (pubSlot?.kind === 'spec' && (pubSlot as SpecialCard).name === 'Zivilgesellschaft') {\r\n      const bewegungNames = ['Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'];\r\n      const hasBewegung = state.board[player].innen.some(c => c.kind === 'spec' && (c as SpecialCard).type === '√ñffentlichkeitskarte' && bewegungNames.includes(c.name));\r\n      if (hasBewegung) influence += 1;\r\n    }\r\n\r\n    // Joschka Fischer NGO-Boost: +1 Einfluss, wenn eine NGO-√ñffentlichkeitskarte liegt\r\n    if (card.name === 'Joschka Fischer' && (card as any).effect === 'ngo_boost') {\r\n      const hasNgoCard = state.board[player].innen.some(c => c.kind === 'spec' && (c as SpecialCard).type === '√ñffentlichkeitskarte' && (c as any).tag === 'NGO');\r\n      if (hasNgoCard) influence += 1;\r\n    }\r\n\r\n    // Milchglas Transparenz: +1 Einfluss wenn keine NGO/Bewegung liegt\r\n    if (govSlot?.kind === 'spec' && (govSlot as SpecialCard).name === 'Milchglas Transparenz') {\r\n      const ngoMovementNames = ['Jennifer Doudna', 'Noam Chomsky', 'Bill Gates', 'Greta Thunberg', 'Malala Yousafzai', 'Ai Weiwei', 'Alexei Navalny'];\r\n      const hasNgoMovement = state.board[player].innen.some(c => c.kind === 'spec' && (c as SpecialCard).type === '√ñffentlichkeitskarte' && ngoMovementNames.includes(c.name));\r\n      if (!hasNgoMovement) influence += 1;\r\n    }\r\n\r\n        // üî• CLUSTER 3: Aura-Effekte (on-demand Board-Check)\r\n        // Legacy flag-based aura checks removed - auras are now calculated on-demand\r\n        \r\n        // Aura effects are now handled via Board-Check in the respective resolvers\r\n        // No more flag-based aura calculations - everything is event-driven\r\n\r\n    // Alternative Fakten is applied within interventions; no direct change here\r\n\r\n    total += influence;\r\n  });\r\n\r\n  return total;\r\n}\r\n\r\nexport function drawCards(\r\n  player: Player,\r\n  count: number,\r\n  state: GameState,\r\n  log: (msg: string) => void\r\n): { newHands: GameState['hands']; newDecks: GameState['decks'] } {\r\n  const deck = [...state.decks[player]];\r\n  const hand = [...state.hands[player]];\r\n\r\n  const drawn = deck.splice(0, Math.min(count, deck.length));\r\n  hand.push(...drawn);\r\n\r\n  if (drawn.length > 0) {\r\n    log(`P${player} zieht ${drawn.length} Karte(n)`);\r\n  }\r\n\r\n  return {\r\n    newHands: { ...state.hands, [player]: hand },\r\n    newDecks: { ...state.decks, [player]: deck }\r\n  };\r\n}\r\n\r\nexport function drawCardsAtRoundEnd(\r\n  state: GameState,\r\n  log: (msg: string) => void\r\n): { newHands: GameState['hands']; newDecks: GameState['decks'] } {\r\n  let newHands = { ...state.hands };\r\n  let newDecks = { ...state.decks };\r\n\r\n  [1, 2].forEach(player => {\r\n    const targetHandSize = 5;\r\n    const currentHandSize = newHands[player as Player].length;\r\n    let drawCount = Math.max(0, targetHandSize - currentHandSize);\r\n\r\n    // üî• MUKESH AMBANI EFFEKT: Gegner darf 1 Karte weniger nachziehen\r\n    const opponent = player === 1 ? 2 : 1;\r\n    const opponentBoard = state.board[opponent];\r\n    const mukeshAmbani = opponentBoard.innen.find(card =>\r\n      card.kind === 'spec' && (card as any).name === 'Mukesh Ambani'\r\n    );\r\n\r\n    if (mukeshAmbani && drawCount > 0) {\r\n      drawCount = Math.max(0, drawCount - 1);\r\n      log(`üî• MUKESH AMBANI EFFEKT: P${player} zieht 1 Karte weniger (${drawCount} statt ${drawCount + 1})`);\r\n    }\r\n\r\n    if (drawCount > 0) {\r\n      const result = drawCards(player as Player, drawCount,\r\n        { ...state, hands: newHands, decks: newDecks }, log);\r\n      newHands = result.newHands;\r\n      newDecks = result.newDecks;\r\n    }\r\n  });\r\n\r\n  return { newHands, newDecks };\r\n}\r\n\r\n// Deck building utilities\r\nexport function currentBuilderBudget(deck: any[]): number {\r\n  return deck.reduce((sum, entry) => {\r\n    if (entry.kind === 'pol') {\r\n      const pol = entry.base;\r\n      return sum + (pol?.BP || 0) * entry.count;\r\n  } else {\r\n      const spec = entry.base;\r\n      return sum + (spec?.bp || 0) * entry.count;\r\n    }\r\n  }, 0);\r\n}\r\n\r\nexport function currentBuilderCount(deck: any[]): number {\r\n  return deck.reduce((sum, entry) => sum + entry.count, 0);\r\n}\r\n\r\nexport function buildDeckFromEntries(entries: any[]): Card[] {\r\n  const deck: Card[] = [];\r\n\r\n  entries.forEach(entry => {\r\n    for (let i = 0; i < entry.count; i++) {\r\n      if (entry.kind === 'pol') {\r\n        // Support both base object (deckbuilder) and baseId (presets)\r\n        const base = entry.base || (entry.baseId ? Pols.find(p => p.id === entry.baseId) : null);\r\n        if (base) deck.push(makePolInstance(base));\r\n      } else {\r\n        // Support both base object (deckbuilder) and baseId (presets)\r\n        const base = entry.base || (entry.baseId ? Specials.find(s => s.id === entry.baseId) : null);\r\n        if (base) deck.push(makeSpecInstance(base));\r\n      }\r\n    }\r\n  });\r\n\r\n  // Stelle sicher, dass jede Karte eine uid besitzt\r\n  const deckWithUids = deck.map((c: any) => (c && c.uid) ? c : { ...c, uid: makeUid('card') });\r\n  return shuffle(deckWithUids);\r\n}\r\n\r\n// Image loading utilities (Legacy function for backwards compatibility)\r\nexport function drawCardImage(\r\n  ctx: CanvasRenderingContext2D,\r\n  card: Card,\r\n  dx: number,\r\n  dy: number,\r\n  size: number,\r\n  imageSize: 'ui' | 'modal' = 'ui'\r\n): void {\r\n  const img = new Image();\r\n  img.onload = () => {\r\n    ctx.drawImage(img, dx, dy, size, size);\r\n  };\r\n  img.src = getCardImagePath(card, imageSize);\r\n}\r\n\r\n// Kapazit√§tspr√ºfung f√ºr Reihen (verhindert zu viele Karten in kleinen Rows)\r\nexport function canPlayToLane(state: GameState, player: Player, lane: 'public' | 'government'): boolean {\r\n  const cap = getLaneCapacity(lane);\r\n  const row = lane === 'public'\r\n    ? state.board[player]?.innen ?? []\r\n    : state.board[player]?.aussen ?? [];\r\n  return row.length < cap;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}