{"ast":null,"code":"import { CARD_BY_ID } from '../data/cards';\nexport function registerTrap(state, player, key) {\n  if (!state.traps) state.traps = {\n    1: [],\n    2: []\n  };\n  const list = state.traps[player];\n  if (!Array.isArray(list)) state.traps[player] = [];\n  state.traps[player].push({\n    owner: player,\n    key\n  });\n}\nexport function applyTrapsOnCardPlayed(state, playedBy, card, enqueue, log) {\n  var _state$traps, _state$effectFlags$pl, _cardDef$tags, _cardDef$tags2;\n  const opp = playedBy === 1 ? 2 : 1;\n  const traps = (_state$traps = state.traps) === null || _state$traps === void 0 ? void 0 : _state$traps[opp];\n  if (!traps || traps.length === 0) return;\n\n  // Diagnostics: log existing traps for opponent when a card is played\n  try {\n    const keys = traps.map(t => t.key).join(', ');\n    enqueue({\n      type: 'LOG',\n      msg: `DEBUG: applyTrapsOnCardPlayed opp=${opp} traps=[${keys}] playedCard=${card.name || card.key || 'unknown'}`\n    });\n  } catch (e) {}\n\n  // Hard rule: Opposition Blockade â€“ if current player is locked, cancel initiative card immediately\n  if ((card === null || card === void 0 ? void 0 : card.type) === 'initiative' && (_state$effectFlags$pl = state.effectFlags[playedBy]) !== null && _state$effectFlags$pl !== void 0 && _state$effectFlags$pl.initiativesLocked) {\n    if (card.uid != null) {\n      enqueue({\n        type: 'CANCEL_CARD',\n        player: playedBy,\n        targetUid: card.uid\n      });\n    }\n    enqueue({\n      type: 'LOG',\n      msg: 'Blocked: initiatives are locked (Opposition Blockade).'\n    });\n    return; // skip further trap processing\n  }\n\n  // Get card definition to access type and tags\n  const cardDef = CARD_BY_ID[card.key];\n  const isInitiative = (cardDef === null || cardDef === void 0 ? void 0 : cardDef.type) === 'initiative';\n  const isPublic = (cardDef === null || cardDef === void 0 ? void 0 : cardDef.type) === 'public';\n  const isGovernment = (cardDef === null || cardDef === void 0 ? void 0 : cardDef.type) === 'government';\n  const isMediaLike = (cardDef === null || cardDef === void 0 ? void 0 : (_cardDef$tags = cardDef.tags) === null || _cardDef$tags === void 0 ? void 0 : _cardDef$tags.includes('Media')) || (cardDef === null || cardDef === void 0 ? void 0 : (_cardDef$tags2 = cardDef.tags) === null || _cardDef$tags2 === void 0 ? void 0 : _cardDef$tags2.includes('Platform')) || (card === null || card === void 0 ? void 0 : card.tag) === 'Media'; // Fallback fÃ¼r Legacy-Karten\n\n  const consumed = [];\n  traps.forEach(t => {\n    switch (t.key) {\n      // bereits live benutzt\n      case 'trap.fake_news.deactivate_media':\n        if (isMediaLike && card.uid != null) {\n          enqueue({\n            type: 'DEACTIVATE_CARD',\n            player: opp,\n            targetUid: card.uid\n          });\n          log('Trap: Fake News â€“ deactivated media/platform card.');\n          consumed.push(t);\n        }\n        break;\n\n      // neu: Initiative canceln (sofort beim Ausspielen der Initiative)\n      case 'trap.legal_injunction.cancel_next_initiative':\n        if (isInitiative && card.uid != null) {\n          enqueue({\n            type: 'CANCEL_CARD',\n            player: opp,\n            targetUid: card.uid\n          });\n          log('Trap: Legal Injunction â€“ cancelled initiative.');\n          consumed.push(t);\n        }\n        break;\n\n      // neu: Karte zurÃ¼ck auf Hand (egal welcher Typ)\n      case 'trap.whistleblower.return_last_played':\n        if (card.uid != null) {\n          enqueue({\n            type: 'RETURN_TO_HAND',\n            player: playedBy,\n            targetUid: card.uid\n          });\n          log('Trap: Whistleblower â€“ returned played card to hand.');\n          consumed.push(t);\n        }\n        break;\n\n      // neu: Gegner discards 2 bei nÃ¤chstem Play\n      case 'trap.data_breach.opp_discard2':\n        enqueue({\n          type: 'DISCARD_RANDOM_FROM_HAND',\n          player: playedBy === 1 ? 2 : 1,\n          amount: 2\n        });\n        log('Trap: Data Breach â€“ opponent discards 2.');\n        consumed.push(t);\n        break;\n\n      // neu: Public deaktivieren\n      case 'trap.media_blackout.deactivate_public':\n        if (isPublic && card.uid != null) {\n          enqueue({\n            type: 'DEACTIVATE_CARD',\n            player: opp,\n            targetUid: card.uid\n          });\n          log('Trap: Media Blackout â€“ deactivated public card.');\n          consumed.push(t);\n        }\n        break;\n\n      // neu: AP -2 fÃ¼r Gegner beim nÃ¤chsten Play\n      case 'trap.budget_freeze.opp_ap_minus2':\n        enqueue({\n          type: 'ADD_AP',\n          player: playedBy,\n          amount: -2\n        });\n        log('Trap: Budget Freeze â€“ opponent AP -2.');\n        consumed.push(t);\n        break;\n\n      // neu: Government deaktivieren\n      case 'trap.sabotage.deactivate_gov':\n        if (isGovernment && card.uid != null) {\n          enqueue({\n            type: 'DEACTIVATE_CARD',\n            player: opp,\n            targetUid: card.uid\n          });\n          log('Trap: Sabotage â€“ deactivated government card.');\n          consumed.push(t);\n        }\n        break;\n\n      // Strategic Disclosure: Government-Karte zurÃ¼ckgeben\n      case 'trap.strategic_disclosure.return_gov':\n        if (isGovernment && card.uid != null) {\n          enqueue({\n            type: 'RETURN_TO_HAND',\n            player: playedBy,\n            targetUid: card.uid\n          });\n          log('Trap: Strategic Disclosure â€“ returned government card to hand.');\n          consumed.push(t);\n        }\n        break;\n      case 'trap.whistleblower.debuff_next_gov_minus2':\n        // Robust trigger: treat any played politician (pol) as government trigger\n        const playedIsPol = (card === null || card === void 0 ? void 0 : card.kind) === 'pol' || isGovernment;\n        if (!playedIsPol) {\n          // not a government/pol card â€” skip\n          enqueue({\n            type: 'LOG',\n            msg: `DEBUG: Whistleblower present but played card is not government/pol (${card.name || card.key})`\n          });\n          break;\n        }\n        if (card.uid == null) {\n          enqueue({\n            type: 'LOG',\n            msg: `DEBUG: Whistleblower cannot apply - target missing uid for ${card.name || card.key}`\n          });\n          break;\n        }\n\n        // Compute number of Activist cards on both players' boards (innen + aussen)\n        const cd = require('../data/cardDetails');\n        let activistCount = 0;\n        for (const p of [1, 2]) {\n          var _state$board$p, _state$board$p2;\n          const innen = ((_state$board$p = state.board[p]) === null || _state$board$p === void 0 ? void 0 : _state$board$p.innen) || [];\n          const aussen = ((_state$board$p2 = state.board[p]) === null || _state$board$p2 === void 0 ? void 0 : _state$board$p2.aussen) || [];\n          const all = [...innen, ...aussen];\n          for (const c of all) {\n            var _cd$getCardDetails, _cd$getCardDetails$ca;\n            if (!c) continue;\n            const subcats = (_cd$getCardDetails = cd.getCardDetails) === null || _cd$getCardDetails === void 0 ? void 0 : (_cd$getCardDetails$ca = _cd$getCardDetails.call(cd, c.name)) === null || _cd$getCardDetails$ca === void 0 ? void 0 : _cd$getCardDetails$ca.subcategories;\n            const legacyTag = c.tag === 'Activist' || c.tag === 'Aktivist' || c.tag === 'Activists' || c.tag === 'Movement';\n            const hasActivistSubcat = Array.isArray(subcats) && (subcats.includes('Activist') || subcats.includes('Aktivist'));\n            if (hasActivistSubcat || legacyTag) {\n              // ignore deactivated public/pol cards\n              if (!c.deactivated) activistCount++;\n            }\n          }\n        }\n\n        // Base debuff -2 plus -1 per Activist (both boards), capped at -6 total\n        const totalDebuffMagnitude = Math.min(6, 2 + activistCount);\n        const amount = -totalDebuffMagnitude;\n        enqueue({\n          type: 'DEBUFF_CARD',\n          player: opp,\n          targetUid: card.uid,\n          amount\n        });\n        const debuffMsg = `Trap: Whistleblower â€“ government card gets ${amount} Influence (base -2 + activists ${activistCount}, capped at -6).`;\n        enqueue({\n          type: 'LOG',\n          msg: debuffMsg\n        });\n        // Immediate console log for better chronological trace before warnings\n        log(debuffMsg);\n        log(`ðŸŸ¢ trap.whistleblower triggered: applied ${amount} to uid ${card.uid} (activists=${activistCount})`);\n        consumed.push(t);\n        break;\n      default:\n        break;\n    }\n  });\n  if (consumed.length) {\n    // Build consumption indexes for robust removal\n    const consumedKeys = new Set(consumed.map(c => c.key).filter(Boolean));\n    // Also include base card keys (namespace + card) to catch visual trap card objects\n    // Example: 'trap.whistleblower.return_last_played' -> add 'trap.whistleblower'\n    for (const k of Array.from(consumedKeys)) {\n      if (typeof k === 'string') {\n        const parts = k.split('.');\n        if (parts.length >= 3) {\n          const baseKey = parts.slice(0, 2).join('.');\n          consumedKeys.add(baseKey);\n        }\n      }\n    }\n    const consumedUids = new Set(consumed.map(c => c.uid).filter(Boolean));\n    const consumedNames = new Set(consumed.map(c => c.name).filter(Boolean));\n    const consumedRefs = new Set(consumed);\n\n    // Debug logging for trap removal\n    enqueue({\n      type: 'LOG',\n      msg: `DEBUG: Trap removal - consumedKeys=[${Array.from(consumedKeys).join(', ')}] consumedNames=[${Array.from(consumedNames).join(', ')}]`\n    });\n\n    // Remove consumed trap registrations and any visual trap card objects from both players' trap lists\n    for (const p of [1, 2]) {\n      const list = state.traps[p] || [];\n      state.traps[p] = list.filter(entry => {\n        if (!entry) return false;\n        // Direct reference match\n        if (consumedRefs.has(entry)) return false;\n        // registration object with key\n        if (entry.key && consumedKeys.has(entry.key)) return false;\n        // match by uid\n        if (entry.uid && consumedUids.has(entry.uid)) return false;\n        // match by name\n        if (entry.name && consumedNames.has(entry.name)) return false;\n\n        // If entry looks like a card object, also remove if its type explicitly indicates a trap\n        if (entry && entry.kind === 'spec') {\n          const typeStr = String(entry.type || '').toLowerCase();\n          if (typeStr.includes('trap')) return false;\n        }\n        return true;\n      });\n    }\n\n    // Ensure the visual trap card is removed from any board lanes if it was added there\n    try {\n      const removeIfTrapOnBoard = arr => {\n        return arr.filter(c => {\n          if (!c) return true;\n          const key = c.key;\n          const name = c.name;\n          const typeStr = String(c.type || '').toLowerCase();\n          const effectKey = c.effectKey;\n\n          // Check if this is a trap card\n          const isTrapByType = typeStr.includes('trap');\n          const isTrapByKey = key && (key.startsWith('trap.') || consumedKeys.has(key));\n          const isTrapByEffectKey = effectKey && (effectKey.startsWith('trap.') || consumedKeys.has(effectKey));\n          const isTrapByName = name && (consumedNames.has(name) || name === 'Whistleblower');\n          if (isTrapByType || isTrapByKey || isTrapByEffectKey || isTrapByName) {\n            enqueue({\n              type: 'LOG',\n              msg: `DEBUG: Removing trap card from board - name=\"${name}\" key=\"${key}\" effectKey=\"${effectKey}\" type=\"${typeStr}\"`\n            });\n            return false;\n          }\n          return true;\n        });\n      };\n\n      // Remove from all board lanes (both players) to be safe\n      for (const p of [1, 2]) {\n        var _state$board;\n        if ((_state$board = state.board) !== null && _state$board !== void 0 && _state$board[p]) {\n          const beforeInnen = state.board[p].innen.length;\n          const beforeAussen = state.board[p].aussen.length;\n          const beforeSofort = state.board[p].sofort.length;\n          state.board[p].innen = removeIfTrapOnBoard(state.board[p].innen || []);\n          state.board[p].aussen = removeIfTrapOnBoard(state.board[p].aussen || []);\n          state.board[p].sofort = removeIfTrapOnBoard(state.board[p].sofort || []);\n          const afterInnen = state.board[p].innen.length;\n          const afterAussen = state.board[p].aussen.length;\n          const afterSofort = state.board[p].sofort.length;\n          if (beforeInnen !== afterInnen || beforeAussen !== afterAussen || beforeSofort !== afterSofort) {\n            enqueue({\n              type: 'LOG',\n              msg: `DEBUG: Board cleanup P${p} - innen:${beforeInnen}â†’${afterInnen}, aussen:${beforeAussen}â†’${afterAussen}, sofort:${beforeSofort}â†’${afterSofort}`\n            });\n          }\n        }\n      }\n      // Additionally, remove any consumed trap card objects from all board lanes and move them to discard\n      try {\n        for (const c of consumed) {\n          const cUid = c.uid;\n          const cKey = c.key || c.name;\n          for (const p of [1, 2]) {\n            for (const lane of ['innen', 'aussen', 'sofort']) {\n              const arr = state.board[p][lane];\n              const idx = arr.findIndex(card => card && (card.uid && cUid && card.uid === cUid || card.key && cKey && card.key === cKey || card.name && cKey && card.name === cKey));\n              if (idx !== -1) {\n                const [removed] = arr.splice(idx, 1);\n                state.discard = state.discard || [];\n                state.discard.push(removed);\n                enqueue({\n                  type: 'LOG',\n                  msg: `Trap consumed: removed ${removed && removed.name || cKey} from board and moved to discard.`\n                });\n              }\n            }\n          }\n        }\n      } catch (e) {}\n    } catch (e) {}\n  }\n\n  // Forced removal fallback: if a consumed trap wasn't removed by the above\n  // logic, attempt a more permissive board scan to remove any visual objects\n  // that look like trap cards. This covers cases where visual card objects use\n  // a simplified key or have no effectKey attached.\n  try {\n    const fallbackKeys = Array.from(consumedKeys);\n    const fallbackNames = Array.from(consumedNames);\n    // add generic base for whistleblower\n    if (!fallbackKeys.some(k => k.startsWith('trap.whistleblower'))) fallbackKeys.push('trap.whistleblower');\n    const removePermissive = arr => {\n      let removedAny = false;\n      for (let i = arr.length - 1; i >= 0; i--) {\n        const c = arr[i];\n        if (!c) continue;\n        const key = c.key;\n        const effectKey = c.effectKey;\n        const name = c.name;\n        const typeStr = String(c.type || '').toLowerCase();\n        const matchesKey = key && fallbackKeys.some(fk => key === fk || key.startsWith(fk));\n        const matchesEffect = effectKey && fallbackKeys.some(fk => effectKey === fk || effectKey.startsWith(fk));\n        const matchesName = name && fallbackNames.includes(name);\n        const looksLikeTrap = typeStr.includes('trap') || key && String(key).startsWith('trap.');\n        if (matchesKey || matchesEffect || matchesName || looksLikeTrap || name === 'Whistleblower') {\n          const [removed] = arr.splice(i, 1);\n          state.discard = state.discard || [];\n          state.discard.push(removed);\n          removedAny = true;\n          enqueue({\n            type: 'LOG',\n            msg: `FORCED-REMOVE: removed ${removed && removed.name || key || name} from board (permissive match)`\n          });\n        }\n      }\n      return removedAny;\n    };\n    for (const p of [1, 2]) {\n      var _state$board2;\n      if (!((_state$board2 = state.board) !== null && _state$board2 !== void 0 && _state$board2[p])) continue;\n      const lanes = ['innen', 'aussen', 'sofort'];\n      for (const lane of lanes) {\n        try {\n          const removed = removePermissive(state.board[p][lane]);\n          if (removed) enqueue({\n            type: 'LOG',\n            msg: `FORCED-REMOVE: cleaned up P${p}.${lane}`\n          });\n        } catch (e) {}\n      }\n    }\n  } catch (e) {}\n}","map":{"version":3,"names":["CARD_BY_ID","registerTrap","state","player","key","traps","list","Array","isArray","push","owner","applyTrapsOnCardPlayed","playedBy","card","enqueue","log","_state$traps","_state$effectFlags$pl","_cardDef$tags","_cardDef$tags2","opp","length","keys","map","t","join","type","msg","name","e","effectFlags","initiativesLocked","uid","targetUid","cardDef","isInitiative","isPublic","isGovernment","isMediaLike","tags","includes","tag","consumed","forEach","amount","playedIsPol","kind","cd","require","activistCount","p","_state$board$p","_state$board$p2","innen","board","aussen","all","c","_cd$getCardDetails","_cd$getCardDetails$ca","subcats","getCardDetails","call","subcategories","legacyTag","hasActivistSubcat","deactivated","totalDebuffMagnitude","Math","min","debuffMsg","consumedKeys","Set","filter","Boolean","k","from","parts","split","baseKey","slice","add","consumedUids","consumedNames","consumedRefs","entry","has","typeStr","String","toLowerCase","removeIfTrapOnBoard","arr","effectKey","isTrapByType","isTrapByKey","startsWith","isTrapByEffectKey","isTrapByName","_state$board","beforeInnen","beforeAussen","beforeSofort","sofort","afterInnen","afterAussen","afterSofort","cUid","cKey","lane","idx","findIndex","removed","splice","discard","fallbackKeys","fallbackNames","some","removePermissive","removedAny","i","matchesKey","fk","matchesEffect","matchesName","looksLikeTrap","_state$board2","lanes"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/utils/traps.ts"],"sourcesContent":["import type { GameState, Player, Card } from '../types/game';\r\nimport type { EffectEvent } from '../types/effects';\r\nimport { CARD_BY_ID } from '../data/cards';\r\n\r\nexport function registerTrap(state: GameState, player: Player, key: string) {\r\n  if (!state.traps) state.traps = { 1: [], 2: [] } as any;\r\n  const list = (state.traps as any)[player] as Array<{ owner: Player; key: string }>;\r\n  if (!Array.isArray(list)) (state.traps as any)[player] = [];\r\n  (state.traps as any)[player].push({ owner: player, key });\r\n}\r\n\r\nexport function applyTrapsOnCardPlayed(\r\n  state: GameState,\r\n  playedBy: Player,\r\n  card: Card,\r\n  enqueue: (e: EffectEvent) => void,\r\n  log: (m: string) => void\r\n) {\r\n  const opp: Player = playedBy === 1 ? 2 : 1;\r\n  const traps = (state.traps as any)?.[opp] as Array<{ owner: Player; key: string }> | undefined;\r\n  if (!traps || traps.length === 0) return;\r\n\r\n  // Diagnostics: log existing traps for opponent when a card is played\r\n  try {\r\n    const keys = traps.map(t => t.key).join(', ');\r\n    enqueue({ type: 'LOG', msg: `DEBUG: applyTrapsOnCardPlayed opp=${opp} traps=[${keys}] playedCard=${(card as any).name || (card as any).key || 'unknown'}` });\r\n  } catch (e) {}\r\n\r\n  // Hard rule: Opposition Blockade â€“ if current player is locked, cancel initiative card immediately\r\n  if ((card as any)?.type === 'initiative' && state.effectFlags[playedBy]?.initiativesLocked) {\r\n    if ((card as any).uid != null) {\r\n      enqueue({ type: 'CANCEL_CARD', player: playedBy, targetUid: (card as any).uid } as any);\r\n    }\r\n    enqueue({ type: 'LOG', msg: 'Blocked: initiatives are locked (Opposition Blockade).' });\r\n    return; // skip further trap processing\r\n  }\r\n\r\n  // Get card definition to access type and tags\r\n  const cardDef = CARD_BY_ID[card.key];\r\n  const isInitiative = cardDef?.type === 'initiative';\r\n  const isPublic = cardDef?.type === 'public';\r\n  const isGovernment = cardDef?.type === 'government';\r\n  const isMediaLike = cardDef?.tags?.includes('Media') ||\r\n                     cardDef?.tags?.includes('Platform') ||\r\n                     (card as any)?.tag === 'Media'; // Fallback fÃ¼r Legacy-Karten\r\n\r\n  const consumed: Array<{ key: string }> = [];\r\n  traps.forEach(t => {\r\n    switch (t.key) {\r\n      // bereits live benutzt\r\n      case 'trap.fake_news.deactivate_media':\r\n        if (isMediaLike && (card as any).uid != null) {\r\n          enqueue({ type: 'DEACTIVATE_CARD', player: opp, targetUid: (card as any).uid });\r\n          log('Trap: Fake News â€“ deactivated media/platform card.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // neu: Initiative canceln (sofort beim Ausspielen der Initiative)\r\n      case 'trap.legal_injunction.cancel_next_initiative':\r\n        if (isInitiative && (card as any).uid != null) {\r\n          enqueue({ type: 'CANCEL_CARD', player: opp, targetUid: (card as any).uid });\r\n          log('Trap: Legal Injunction â€“ cancelled initiative.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // neu: Karte zurÃ¼ck auf Hand (egal welcher Typ)\r\n      case 'trap.whistleblower.return_last_played':\r\n        if ((card as any).uid != null) {\r\n          enqueue({ type: 'RETURN_TO_HAND', player: playedBy, targetUid: (card as any).uid });\r\n          log('Trap: Whistleblower â€“ returned played card to hand.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // neu: Gegner discards 2 bei nÃ¤chstem Play\r\n      case 'trap.data_breach.opp_discard2':\r\n        enqueue({ type: 'DISCARD_RANDOM_FROM_HAND', player: playedBy === 1 ? 2 : 1, amount: 2 });\r\n        log('Trap: Data Breach â€“ opponent discards 2.');\r\n        consumed.push(t);\r\n        break;\r\n\r\n      // neu: Public deaktivieren\r\n      case 'trap.media_blackout.deactivate_public':\r\n        if (isPublic && (card as any).uid != null) {\r\n          enqueue({ type: 'DEACTIVATE_CARD', player: opp, targetUid: (card as any).uid });\r\n          log('Trap: Media Blackout â€“ deactivated public card.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // neu: AP -2 fÃ¼r Gegner beim nÃ¤chsten Play\r\n      case 'trap.budget_freeze.opp_ap_minus2':\r\n        enqueue({ type: 'ADD_AP', player: playedBy, amount: -2 });\r\n        log('Trap: Budget Freeze â€“ opponent AP -2.');\r\n        consumed.push(t);\r\n        break;\r\n\r\n      // neu: Government deaktivieren\r\n      case 'trap.sabotage.deactivate_gov':\r\n        if (isGovernment && (card as any).uid != null) {\r\n          enqueue({ type: 'DEACTIVATE_CARD', player: opp, targetUid: (card as any).uid });\r\n          log('Trap: Sabotage â€“ deactivated government card.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      // Strategic Disclosure: Government-Karte zurÃ¼ckgeben\r\n      case 'trap.strategic_disclosure.return_gov':\r\n        if (isGovernment && (card as any).uid != null) {\r\n          enqueue({ type: 'RETURN_TO_HAND', player: playedBy, targetUid: (card as any).uid });\r\n          log('Trap: Strategic Disclosure â€“ returned government card to hand.');\r\n          consumed.push(t);\r\n        }\r\n        break;\r\n\r\n      case 'trap.whistleblower.debuff_next_gov_minus2':\r\n        // Robust trigger: treat any played politician (pol) as government trigger\r\n        const playedIsPol = (card as any)?.kind === 'pol' || isGovernment;\r\n        if (!playedIsPol) {\r\n          // not a government/pol card â€” skip\r\n          enqueue({ type: 'LOG', msg: `DEBUG: Whistleblower present but played card is not government/pol (${(card as any).name || (card as any).key})` });\r\n          break;\r\n        }\r\n        if ((card as any).uid == null) {\r\n          enqueue({ type: 'LOG', msg: `DEBUG: Whistleblower cannot apply - target missing uid for ${(card as any).name || (card as any).key}` });\r\n          break;\r\n        }\r\n\r\n        // Compute number of Activist cards on both players' boards (innen + aussen)\r\n        const cd = require('../data/cardDetails') as any;\r\n        let activistCount = 0;\r\n        for (const p of [1, 2] as const) {\r\n          const innen = state.board[p]?.innen || [];\r\n          const aussen = state.board[p]?.aussen || [];\r\n          const all = [...innen, ...aussen];\r\n          for (const c of all) {\r\n            if (!c) continue;\r\n            const subcats = cd.getCardDetails?.((c as any).name)?.subcategories as string[] | undefined;\r\n            const legacyTag = (c as any).tag === 'Activist' || (c as any).tag === 'Aktivist' || (c as any).tag === 'Activists' || (c as any).tag === 'Movement';\r\n            const hasActivistSubcat = Array.isArray(subcats) && (subcats.includes('Activist') || subcats.includes('Aktivist'));\r\n            if (hasActivistSubcat || legacyTag) {\r\n              // ignore deactivated public/pol cards\r\n              if (!(c as any).deactivated) activistCount++;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Base debuff -2 plus -1 per Activist (both boards), capped at -6 total\r\n        const totalDebuffMagnitude = Math.min(6, 2 + activistCount);\r\n        const amount = -totalDebuffMagnitude;\r\n\r\n        enqueue({ type: 'DEBUFF_CARD', player: opp, targetUid: (card as any).uid, amount } as any);\r\n        const debuffMsg = `Trap: Whistleblower â€“ government card gets ${amount} Influence (base -2 + activists ${activistCount}, capped at -6).`;\r\n        enqueue({ type: 'LOG', msg: debuffMsg });\r\n        // Immediate console log for better chronological trace before warnings\r\n        log(debuffMsg);\r\n        log(`ðŸŸ¢ trap.whistleblower triggered: applied ${amount} to uid ${(card as any).uid} (activists=${activistCount})`);\r\n        consumed.push(t);\r\n        break;\r\n\r\n      default:\r\n        break;\r\n    }\r\n  });\r\n\r\n  if (consumed.length) {\r\n    // Build consumption indexes for robust removal\r\n    const consumedKeys = new Set(consumed.map(c => (c as any).key).filter(Boolean));\r\n    // Also include base card keys (namespace + card) to catch visual trap card objects\r\n    // Example: 'trap.whistleblower.return_last_played' -> add 'trap.whistleblower'\r\n    for (const k of Array.from(consumedKeys)) {\r\n      if (typeof k === 'string') {\r\n        const parts = k.split('.');\r\n        if (parts.length >= 3) {\r\n          const baseKey = parts.slice(0, 2).join('.');\r\n          consumedKeys.add(baseKey);\r\n        }\r\n      }\r\n    }\r\n    const consumedUids = new Set(consumed.map(c => (c as any).uid).filter(Boolean));\r\n    const consumedNames = new Set(consumed.map(c => (c as any).name).filter(Boolean));\r\n    const consumedRefs = new Set(consumed);\r\n\r\n    // Debug logging for trap removal\r\n    enqueue({ type: 'LOG', msg: `DEBUG: Trap removal - consumedKeys=[${Array.from(consumedKeys).join(', ')}] consumedNames=[${Array.from(consumedNames).join(', ')}]` });\r\n\r\n    // Remove consumed trap registrations and any visual trap card objects from both players' trap lists\r\n    for (const p of [1, 2] as const) {\r\n      const list = (state.traps as any)[p] || [];\r\n      (state.traps as any)[p] = list.filter((entry: any) => {\r\n        if (!entry) return false;\r\n        // Direct reference match\r\n        if (consumedRefs.has(entry)) return false;\r\n        // registration object with key\r\n        if (entry.key && consumedKeys.has(entry.key)) return false;\r\n        // match by uid\r\n        if ((entry as any).uid && consumedUids.has((entry as any).uid)) return false;\r\n        // match by name\r\n        if ((entry as any).name && consumedNames.has((entry as any).name)) return false;\r\n\r\n        // If entry looks like a card object, also remove if its type explicitly indicates a trap\r\n        if (entry && entry.kind === 'spec') {\r\n          const typeStr = String((entry as any).type || '').toLowerCase();\r\n          if (typeStr.includes('trap')) return false;\r\n        }\r\n\r\n        return true;\r\n      });\r\n    }\r\n\r\n    // Ensure the visual trap card is removed from any board lanes if it was added there\r\n    try {\r\n      const removeIfTrapOnBoard = (arr: any[]) => {\r\n        return arr.filter(c => {\r\n          if (!c) return true;\r\n          const key = (c as any).key;\r\n          const name = (c as any).name;\r\n          const typeStr = String((c as any).type || '').toLowerCase();\r\n          const effectKey = (c as any).effectKey;\r\n\r\n          // Check if this is a trap card\r\n          const isTrapByType = typeStr.includes('trap');\r\n          const isTrapByKey = key && (key.startsWith('trap.') || consumedKeys.has(key));\r\n          const isTrapByEffectKey = effectKey && (effectKey.startsWith('trap.') || consumedKeys.has(effectKey));\r\n          const isTrapByName = name && (consumedNames.has(name) || name === 'Whistleblower');\r\n\r\n          if (isTrapByType || isTrapByKey || isTrapByEffectKey || isTrapByName) {\r\n            enqueue({ type: 'LOG', msg: `DEBUG: Removing trap card from board - name=\"${name}\" key=\"${key}\" effectKey=\"${effectKey}\" type=\"${typeStr}\"` });\r\n            return false;\r\n          }\r\n          return true;\r\n        });\r\n      };\r\n\r\n      // Remove from all board lanes (both players) to be safe\r\n      for (const p of [1, 2] as const) {\r\n        if (state.board?.[p]) {\r\n          const beforeInnen = state.board[p].innen.length;\r\n          const beforeAussen = state.board[p].aussen.length;\r\n          const beforeSofort = state.board[p].sofort.length;\r\n\r\n          state.board[p].innen = removeIfTrapOnBoard(state.board[p].innen || []);\r\n          state.board[p].aussen = removeIfTrapOnBoard(state.board[p].aussen || []);\r\n          state.board[p].sofort = removeIfTrapOnBoard(state.board[p].sofort || []);\r\n\r\n          const afterInnen = state.board[p].innen.length;\r\n          const afterAussen = state.board[p].aussen.length;\r\n          const afterSofort = state.board[p].sofort.length;\r\n\r\n          if (beforeInnen !== afterInnen || beforeAussen !== afterAussen || beforeSofort !== afterSofort) {\r\n            enqueue({ type: 'LOG', msg: `DEBUG: Board cleanup P${p} - innen:${beforeInnen}â†’${afterInnen}, aussen:${beforeAussen}â†’${afterAussen}, sofort:${beforeSofort}â†’${afterSofort}` });\r\n          }\r\n        }\r\n      }\r\n      // Additionally, remove any consumed trap card objects from all board lanes and move them to discard\r\n      try {\r\n        for (const c of consumed) {\r\n          const cUid = (c as any).uid;\r\n          const cKey = (c as any).key || (c as any).name;\r\n          for (const p of [1, 2] as const) {\r\n            for (const lane of ['innen', 'aussen', 'sofort'] as const) {\r\n              const arr = state.board[p][lane] as any[];\r\n              const idx = arr.findIndex(card => (card && ((card.uid && cUid && card.uid === cUid) || (card.key && cKey && card.key === cKey) || (card.name && cKey && card.name === cKey))));\r\n              if (idx !== -1) {\r\n                const [removed] = arr.splice(idx, 1);\r\n                state.discard = state.discard || [];\r\n                state.discard.push(removed);\r\n                enqueue({ type: 'LOG', msg: `Trap consumed: removed ${(removed && removed.name) || cKey} from board and moved to discard.` });\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } catch (e) {}\r\n    } catch (e) {}\r\n  }\r\n\r\n  // Forced removal fallback: if a consumed trap wasn't removed by the above\r\n  // logic, attempt a more permissive board scan to remove any visual objects\r\n  // that look like trap cards. This covers cases where visual card objects use\r\n  // a simplified key or have no effectKey attached.\r\n  try {\r\n    const fallbackKeys = Array.from(consumedKeys);\r\n    const fallbackNames = Array.from(consumedNames);\r\n    // add generic base for whistleblower\r\n    if (!fallbackKeys.some(k => k.startsWith('trap.whistleblower'))) fallbackKeys.push('trap.whistleblower');\r\n\r\n    const removePermissive = (arr: any[]) => {\r\n      let removedAny = false;\r\n      for (let i = arr.length - 1; i >= 0; i--) {\r\n        const c = arr[i];\r\n        if (!c) continue;\r\n        const key = c.key;\r\n        const effectKey = c.effectKey;\r\n        const name = c.name;\r\n        const typeStr = String((c as any).type || '').toLowerCase();\r\n\r\n        const matchesKey = key && fallbackKeys.some(fk => key === fk || key.startsWith(fk));\r\n        const matchesEffect = effectKey && fallbackKeys.some(fk => effectKey === fk || effectKey.startsWith(fk));\r\n        const matchesName = name && fallbackNames.includes(name);\r\n        const looksLikeTrap = typeStr.includes('trap') || (key && String(key).startsWith('trap.'));\r\n\r\n        if (matchesKey || matchesEffect || matchesName || looksLikeTrap || name === 'Whistleblower') {\r\n          const [removed] = arr.splice(i, 1);\r\n          state.discard = state.discard || [];\r\n          state.discard.push(removed);\r\n          removedAny = true;\r\n          enqueue({ type: 'LOG', msg: `FORCED-REMOVE: removed ${(removed && removed.name) || key || name} from board (permissive match)` });\r\n        }\r\n      }\r\n      return removedAny;\r\n    };\r\n\r\n    for (const p of [1, 2] as const) {\r\n      if (!state.board?.[p]) continue;\r\n      const lanes = ['innen', 'aussen', 'sofort'] as const;\r\n      for (const lane of lanes) {\r\n        try {\r\n          const removed = removePermissive(state.board[p][lane]);\r\n          if (removed) enqueue({ type: 'LOG', msg: `FORCED-REMOVE: cleaned up P${p}.${lane}` });\r\n        } catch (e) {}\r\n      }\r\n    }\r\n  } catch (e) {}\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}