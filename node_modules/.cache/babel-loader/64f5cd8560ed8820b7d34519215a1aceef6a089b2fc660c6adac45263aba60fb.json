{"ast":null,"code":"// src/qte/atlasLoader.ts - simple runtime loader for TexturePacker JSON (ARRAY) format\n// The JSON layout we expect (TexturePacker \"JSON (Hash)\" or \"JSON (Array)\" works):\n// {\n//   \"frames\": {\n//      \"idle_0\": { \"frame\": {\"x\":0,\"y\":0,\"w\":256,\"h\":256}, ... },\n//      \"idle_1\": {...},\n//      \"walk_0\": {...}\n//   },\n//   \"meta\": { \"image\": \"atlas.png\" }\n// }\n// Each frame key is expected to be <state>_<index> (index starting at 0).\n// We group them into an array per state and keep the order of index.\nexport async function loadAtlas(basePath){// basePath may be a directory or a path to a JSON file (e.g. \"/qte/ninja\" or \"/qte/ninja/atlas2.json\")\nconst cacheBuster=Date.now();const candidates=[];if(basePath.match(/\\.json$/i)){candidates.push(basePath);}else{candidates.push(\"\".concat(basePath,\"/atlas.json\"));candidates.push(\"\".concat(basePath,\".json\"));// allow explicit atlas2 naming (common in this project)\ncandidates.push(\"\".concat(basePath,\"/atlas2.json\"));candidates.push(\"\".concat(basePath,\"/atlas2\"));}let text=null;let usedJsonUrl=null;const tried=[];for(const cand of candidates){const url=\"\".concat(cand,\"?v=\").concat(cacheBuster);tried.push(url);console.log(\"[atlas] Trying \".concat(url));try{const res=await fetch(url);if(!res.ok){console.log(\"[atlas] \".concat(url,\" responded \").concat(res.status));continue;}const contentType=res.headers.get('content-type')||'';const body=await res.text();// If server returned HTML (e.g. index.html), skip and try next candidate\nif(contentType.includes('text/html')||body.trim().startsWith('<!DOCTYPE')){console.warn(\"[atlas] \".concat(url,\" looks like HTML (skipping)\"));continue;}text=body;usedJsonUrl=url.replace(/\\?v=\\d+$/,'');console.log(\"[atlas] Loaded JSON from \".concat(url,\" (len=\").concat(text.length,\")\"));break;}catch(e){console.warn(\"[atlas] fetch failed for \".concat(url),e);continue;}}if(!text||!usedJsonUrl){throw new Error(\"Atlas JSON not found. Tried: \".concat(tried.join(', ')));}console.log(\"[atlas] JSON response length: \".concat(text.length,\", starts with: \").concat(text.substring(0,100)));let data;try{data=JSON.parse(text);}catch(e){console.error(\"[atlas] JSON parse error:\",e);console.error(\"[atlas] Invalid JSON text:\",text.substring(0,200));throw e;}const framesData=data.frames;const meta=data.meta||{};// compute base directory from usedJsonUrl\nconst baseDir=usedJsonUrl.replace(/\\/[^/]*$/,'');const imgPath=\"\".concat(baseDir,\"/\").concat(meta.image||'atlas.png',\"?v=\").concat(cacheBuster);console.log(\"[atlas] Loading image \".concat(imgPath));const image=await loadImage(imgPath);const stateMap={};for(const key in framesData){const state=key.replace(/_\\d+$/,\"\");const idxMatch=/_(\\d+)$/.exec(key);const idx=idxMatch?parseInt(idxMatch[1],10):0;if(!stateMap[state])stateMap[state]=[];const f=framesData[key].frame;stateMap[state][idx]={x:f.x,y:f.y,w:f.w,h:f.h};}// Sort frames by index to ensure correct order\nfor(const state in stateMap){stateMap[state].sort((a,b)=>{// Find the original indices for sorting\nconst aIdx=Object.keys(framesData).find(k=>k.startsWith(\"\".concat(state,\"_\"))&&framesData[k].frame.x===a.x&&framesData[k].frame.y===a.y);const bIdx=Object.keys(framesData).find(k=>k.startsWith(\"\".concat(state,\"_\"))&&framesData[k].frame.x===b.x&&framesData[k].frame.y===b.y);if(aIdx&&bIdx){const aNum=parseInt(aIdx.split('_')[1],10);const bNum=parseInt(bIdx.split('_')[1],10);return aNum-bNum;}return 0;});}// Determine frame size: prefer meta.tileSize if provided\nconst firstState=Object.keys(stateMap)[0];const firstFrame=firstState?stateMap[firstState][0]:{w:64,h:64};const tileSize=meta.tileSize&&Array.isArray(meta.tileSize)&&meta.tileSize.length>=2?meta.tileSize:[firstFrame.w,firstFrame.h];const frameW=tileSize[0];const frameH=tileSize[1];// Build animations; prefer loop/fps from data.animations if present\nconst providedAnims=data.animations||{};const animations={};for(const s of Object.keys(stateMap)){const provided=providedAnims[s]||providedAnims[s+''];const fps=provided&&provided.fps?provided.fps:meta.fps||12;const loop=provided&&typeof provided.loop==='boolean'?provided.loop:true;animations[s]={frames:stateMap[s],fps,loop};}return{image,animations,frameW,frameH,frames:framesData};}function loadImage(src){return new Promise((resolve,reject)=>{const img=new Image();img.onload=()=>resolve(img);img.onerror=reject;img.src=src;});}","map":{"version":3,"names":["loadAtlas","basePath","cacheBuster","Date","now","candidates","match","push","concat","text","usedJsonUrl","tried","cand","url","console","log","res","fetch","ok","status","contentType","headers","get","body","includes","trim","startsWith","warn","replace","length","e","Error","join","substring","data","JSON","parse","error","framesData","frames","meta","baseDir","imgPath","image","loadImage","stateMap","key","state","idxMatch","exec","idx","parseInt","f","frame","x","y","w","h","sort","a","b","aIdx","Object","keys","find","k","bIdx","aNum","split","bNum","firstState","firstFrame","tileSize","Array","isArray","frameW","frameH","providedAnims","animations","s","provided","fps","loop","src","Promise","resolve","reject","img","Image","onload","onerror"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/qte/atlasLoader.ts"],"sourcesContent":["// src/qte/atlasLoader.ts - simple runtime loader for TexturePacker JSON (ARRAY) format\n// The JSON layout we expect (TexturePacker \"JSON (Hash)\" or \"JSON (Array)\" works):\n// {\n//   \"frames\": {\n//      \"idle_0\": { \"frame\": {\"x\":0,\"y\":0,\"w\":256,\"h\":256}, ... },\n//      \"idle_1\": {...},\n//      \"walk_0\": {...}\n//   },\n//   \"meta\": { \"image\": \"atlas.png\" }\n// }\n// Each frame key is expected to be <state>_<index> (index starting at 0).\n// We group them into an array per state and keep the order of index.\n\nexport interface Rect { x: number; y: number; w: number; h: number }\nexport interface AtlasAnimation {\n  frames: Rect[];\n  fps: number;\n  loop: boolean;\n}\n\nexport interface LoadedAtlas {\n  image: HTMLImageElement;\n  animations: Record<string, AtlasAnimation>;\n  frameW: number;\n  frameH: number;\n  frames?: Record<string, any>; // Raw frames data for fallback frame counting\n}\n\nexport async function loadAtlas(basePath: string): Promise<LoadedAtlas> {\n  // basePath may be a directory or a path to a JSON file (e.g. \"/qte/ninja\" or \"/qte/ninja/atlas2.json\")\n  const cacheBuster = Date.now();\n\n  const candidates: string[] = [];\n  if (basePath.match(/\\.json$/i)) {\n    candidates.push(basePath);\n  } else {\n    candidates.push(`${basePath}/atlas.json`);\n    candidates.push(`${basePath}.json`);\n    // allow explicit atlas2 naming (common in this project)\n    candidates.push(`${basePath}/atlas2.json`);\n    candidates.push(`${basePath}/atlas2`);\n  }\n\n  let text: string | null = null;\n  let usedJsonUrl: string | null = null;\n  const tried: string[] = [];\n\n  for (const cand of candidates) {\n    const url = `${cand}?v=${cacheBuster}`;\n    tried.push(url);\n    console.log(`[atlas] Trying ${url}`);\n    try {\n      const res = await fetch(url);\n      if (!res.ok) {\n        console.log(`[atlas] ${url} responded ${res.status}`);\n        continue;\n      }\n\n      const contentType = res.headers.get('content-type') || '';\n      const body = await res.text();\n      // If server returned HTML (e.g. index.html), skip and try next candidate\n      if (contentType.includes('text/html') || body.trim().startsWith('<!DOCTYPE')) {\n        console.warn(`[atlas] ${url} looks like HTML (skipping)`);\n        continue;\n      }\n\n      text = body;\n      usedJsonUrl = url.replace(/\\?v=\\d+$/, '');\n      console.log(`[atlas] Loaded JSON from ${url} (len=${text.length})`);\n      break;\n    } catch (e) {\n      console.warn(`[atlas] fetch failed for ${url}`, e);\n      continue;\n    }\n  }\n\n  if (!text || !usedJsonUrl) {\n    throw new Error(`Atlas JSON not found. Tried: ${tried.join(', ')}`);\n  }\n\n  console.log(`[atlas] JSON response length: ${text.length}, starts with: ${text.substring(0, 100)}`);\n\n  let data: any;\n  try {\n    data = JSON.parse(text);\n  } catch (e) {\n    console.error(`[atlas] JSON parse error:`, e);\n    console.error(`[atlas] Invalid JSON text:`, text.substring(0, 200));\n    throw e;\n  }\n\n  const framesData = data.frames;\n  const meta = data.meta || {};\n  // compute base directory from usedJsonUrl\n  const baseDir = usedJsonUrl.replace(/\\/[^/]*$/, '');\n  const imgPath = `${baseDir}/${meta.image || 'atlas.png'}?v=${cacheBuster}`;\n  console.log(`[atlas] Loading image ${imgPath}`);\n  const image = await loadImage(imgPath);\n\n  const stateMap: Record<string, Rect[]> = {};\n  for (const key in framesData) {\n    const state = key.replace(/_\\d+$/, \"\");\n    const idxMatch = /_(\\d+)$/.exec(key);\n    const idx = idxMatch ? parseInt(idxMatch[1], 10) : 0;\n    if (!stateMap[state]) stateMap[state] = [];\n    const f = framesData[key].frame as { x: number; y: number; w: number; h: number };\n    stateMap[state][idx] = { x: f.x, y: f.y, w: f.w, h: f.h };\n  }\n\n  // Sort frames by index to ensure correct order\n  for (const state in stateMap) {\n    stateMap[state].sort((a, b) => {\n      // Find the original indices for sorting\n      const aIdx = Object.keys(framesData).find(k => k.startsWith(`${state}_`) && framesData[k].frame.x === a.x && framesData[k].frame.y === a.y);\n      const bIdx = Object.keys(framesData).find(k => k.startsWith(`${state}_`) && framesData[k].frame.x === b.x && framesData[k].frame.y === b.y);\n      if (aIdx && bIdx) {\n        const aNum = parseInt(aIdx.split('_')[1], 10);\n        const bNum = parseInt(bIdx.split('_')[1], 10);\n        return aNum - bNum;\n      }\n      return 0;\n    });\n  }\n\n  // Determine frame size: prefer meta.tileSize if provided\n  const firstState = Object.keys(stateMap)[0];\n  const firstFrame = firstState ? stateMap[firstState][0] : { w: 64, h: 64 };\n  const tileSize = (meta.tileSize && Array.isArray(meta.tileSize) && meta.tileSize.length >= 2) ? meta.tileSize : [firstFrame.w, firstFrame.h];\n  const frameW = tileSize[0];\n  const frameH = tileSize[1];\n\n  // Build animations; prefer loop/fps from data.animations if present\n  const providedAnims = data.animations || {};\n  const animations: Record<string, AtlasAnimation> = {};\n  for (const s of Object.keys(stateMap)) {\n    const provided = providedAnims[s] || providedAnims[s + ''];\n    const fps = provided && provided.fps ? provided.fps : (meta.fps || 12);\n    const loop = provided && typeof provided.loop === 'boolean' ? provided.loop : true;\n    animations[s] = { frames: stateMap[s], fps, loop };\n  }\n\n  return { image, animations, frameW, frameH, frames: framesData };\n}\n\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}