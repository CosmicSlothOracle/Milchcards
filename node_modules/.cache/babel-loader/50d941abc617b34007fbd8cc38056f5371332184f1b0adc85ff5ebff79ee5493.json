{"ast":null,"code":"import { getStrongestGovernment } from './targets';\nimport { registerTrap } from './traps';\nimport { logAP, logDraw, logDiscardRandom, logDeactivateRandom, logBuffStrongest, logShield, logDeactivateCard, logOpportunist } from './logs';\nimport { getGlobalRNG } from '../services/rng';\nimport { logger } from '../debug/logger';\n// Helper to find strongest government uid for new intents\nfunction strongestGovernmentUid(state, p) {\n  var _state$board$p;\n  const govRow = (_state$board$p = state.board[p]) === null || _state$board$p === void 0 ? void 0 : _state$board$p.aussen;\n  if (!govRow || govRow.length === 0) return null;\n  const alive = govRow.filter(g => !g.deactivated);\n  if (!alive.length) return null;\n  const sorted = alive.slice().sort((a, b) => b.influence + (b.tempBuffs || 0) - (b.tempDebuffs || 0) - (a.influence + (a.tempBuffs || 0) - (a.tempDebuffs || 0)));\n  return sorted[0].uid;\n}\nfunction other(p) {\n  return p === 1 ? 2 : 1;\n}\nfunction logPush(state, msg) {\n  state.log.push(msg);\n}\nfunction strongestGov(state, p) {\n  const row = state.board[p].aussen;\n  if (!row.length) return null;\n  const alive = row.filter(c => !c.deactivated);\n  if (alive.length === 0) return null;\n  return alive.slice().sort((a, b) => b.influence + (b.tempBuffs || 0) - (b.tempDebuffs || 0) - (a.influence + (a.tempBuffs || 0) - (a.tempDebuffs || 0)))[0];\n}\nfunction publicNames(state, p) {\n  return state.board[p].innen.map(c => c.name);\n}\nfunction hasPublic(state, p, name) {\n  return publicNames(state, p).includes(name);\n}\nfunction findCardByUidOnBoard(state, uid) {\n  for (const p of [1, 2]) {\n    for (const lane of ['innen', 'aussen', 'sofort']) {\n      const arr = state.board[p][lane];\n      const hit = arr.find(c => c.uid === uid);\n      if (hit) return hit;\n    }\n  }\n  return null;\n}\n\n// Find the slot location for a card uid on the board\nfunction findCardSlotByUid(state, uid) {\n  for (const p of [1, 2]) {\n    for (const lane of ['innen', 'aussen', 'sofort']) {\n      const arr = state.board[p][lane];\n      const idx = arr.findIndex(c => c.uid === uid);\n      if (idx !== -1) return {\n        player: p,\n        lane,\n        index: idx\n      };\n    }\n  }\n  // check permanent slots\n  const permGov = state.permanentSlots[1].government;\n  if (permGov && permGov.uid === uid) return {\n    player: 1,\n    lane: 'permanent.government',\n    index: 0\n  };\n  const permPub = state.permanentSlots[1].public;\n  if (permPub && permPub.uid === uid) return {\n    player: 1,\n    lane: 'permanent.public',\n    index: 0\n  };\n  const permGov2 = state.permanentSlots[2].government;\n  if (permGov2 && permGov2.uid === uid) return {\n    player: 2,\n    lane: 'permanent.government',\n    index: 0\n  };\n  const permPub2 = state.permanentSlots[2].public;\n  if (permPub2 && permPub2.uid === uid) return {\n    player: 2,\n    lane: 'permanent.public',\n    index: 0\n  };\n  return null;\n}\nexport function resolveQueue(state, events) {\n  const rng = getGlobalRNG();\n\n  // Single pass FIFO\n  while (events.length) {\n    const ev = events.shift();\n    logger.dbg(`DQ ${ev.type}`, ev);\n    // Capture small snapshot for delta calc\n    const beforeAP = {\n      ...state.actionPoints\n    };\n    switch (ev.type) {\n      case 'LOG':\n        {\n          logPush(state, ev.msg);\n          break;\n        }\n      case 'ADD_AP':\n        {\n          var _state$effectFlags$ot;\n          const cur = state.actionPoints[ev.player];\n          const next = Math.max(0, cur + ev.amount);\n          state.actionPoints[ev.player] = next;\n          logger.dbg(`ADD_AP before=${cur} amount=${ev.amount} after=${state.actionPoints[ev.player]}`);\n\n          // Opportunist AP-Spiegelung (falls aktiv beim Gegner)\n          if ((_state$effectFlags$ot = state.effectFlags[other(ev.player)]) !== null && _state$effectFlags$ot !== void 0 && _state$effectFlags$ot.opportunistActive && ev.amount > 0) {\n            const mirror = {\n              type: 'ADD_AP',\n              player: other(ev.player),\n              amount: ev.amount\n            };\n            events.unshift(mirror);\n            logPush(state, `Opportunist: AP +${ev.amount} gespiegelt.`);\n          }\n          logPush(state, logAP(ev.player, cur, next));\n          break;\n        }\n      case 'DRAW_CARDS':\n        {\n          const handBefore = state.hands[ev.player].length;\n          for (let i = 0; i < ev.amount; i++) {\n            const top = state.decks[ev.player].shift();\n            if (top) {\n              state.hands[ev.player].push(top);\n              logPush(state, logDraw(ev.player, top.name));\n            }\n          }\n          const handAfter = state.hands[ev.player].length;\n          logger.dbg(`DRAW_CARDS player=${ev.player} before=${handBefore} after=${handAfter}`);\n          break;\n        }\n      case 'DISCARD_RANDOM_FROM_HAND':\n        {\n          const hand = state.hands[ev.player];\n          for (let i = 0; i < ev.amount && hand.length > 0; i++) {\n            const idx = rng.randomInt(hand.length);\n            const [card] = hand.splice(idx, 1);\n            state.discard.push(card);\n            logPush(state, logDiscardRandom(ev.player, card.name));\n          }\n          break;\n        }\n      case 'DEACTIVATE_RANDOM_HAND':\n        {\n          // Deaktivieren von Handkarten (nicht entfernen)\n          const hand = state.hands[ev.player];\n          const activeCards = hand.filter(c => !c.deactivated);\n          logger.dbg(`DEACTIVATE_RANDOM_HAND: P${ev.player} handSize=${hand.length} activeCandidates=${activeCards.length}`);\n          if (activeCards.length === 0) {\n            logPush(state, `Oprah: no active hand cards to deactivate for P${ev.player}`);\n            break;\n          }\n          for (let i = 0; i < ev.amount && activeCards.length > 0; i++) {\n            const card = rng.pick(activeCards);\n            logger.dbg(`DEACTIVATE_RANDOM_HAND: picked=${card ? card.name : 'undefined'} for P${ev.player}`);\n            if (card) {\n              card.deactivated = true;\n              card._deactivatedBy = 'OPRAH';\n              logPush(state, logDeactivateRandom(ev.player, card.name));\n              // Entferne aus activeCards fÃ¼r nÃ¤chste Iteration\n              const idx = activeCards.indexOf(card);\n              if (idx > -1) activeCards.splice(idx, 1);\n            }\n          }\n          break;\n        }\n\n      // Legacy cases - removed\n      // SET_DISCOUNT and REFUND_NEXT_INITIATIVE are no longer supported\n      // Use ADD_AP instead\n\n      case 'GRANT_SHIELD':\n        {\n          if (!state.shields) state.shields = new Set();\n          // Wenn kein spezifischer targetUid angegeben ist, verwende Platzhalter pro Spieler (-1 oder -2)\n          const uid = ev.targetUid !== undefined ? ev.targetUid : ev.player === 1 ? -1 : -2;\n          state.shields.add(uid);\n          logPush(state, logShield(uid));\n          break;\n        }\n      case 'DEACTIVATE_CARD':\n        {\n          const card = findCardByUidOnBoard(state, ev.targetUid);\n          if (card) {\n            card.deactivated = true;\n            logPush(state, logDeactivateCard(card.name));\n\n            // Falls die Karte eine Shield-Aura ist, entferne Spielerschilde\n            if (card.effectKey === 'init.intelligence_liaison.shield_aura') {\n              if (state.shields) {\n                const placeholder = ev.player === 1 ? -1 : -2;\n                state.shields.delete(placeholder);\n              }\n            }\n          }\n          break;\n        }\n      case 'REACTIVATE_CARD':\n        {\n          const card = findCardByUidOnBoard(state, ev.targetUid);\n          if (card) {\n            card.deactivated = false;\n            logPush(state, `ðŸ”„ ${card.name} wurde reaktiviert`);\n          }\n          break;\n        }\n      case 'RETURN_TO_HAND':\n        {\n          const card = findCardByUidOnBoard(state, ev.targetUid);\n          if (card) {\n            // Remove from board\n            for (const p of [1, 2]) {\n              for (const lane of ['innen', 'aussen', 'sofort']) {\n                const idx = state.board[p][lane].findIndex(c => c.uid === ev.targetUid);\n                if (idx !== -1) {\n                  state.board[p][lane].splice(idx, 1);\n                  // Add to hand\n                  state.hands[ev.player].push(card);\n                  logPush(state, `ðŸ”„ ${card.name} wurde zur Hand zurÃ¼ckgegeben`);\n                  break;\n                }\n              }\n            }\n          }\n          break;\n        }\n      case 'CANCEL_CARD':\n        {\n          const card = findCardByUidOnBoard(state, ev.targetUid);\n          if (card) {\n            // Remove from board and add to discard\n            for (const p of [1, 2]) {\n              for (const lane of ['innen', 'aussen', 'sofort']) {\n                const idx = state.board[p][lane].findIndex(c => c.uid === ev.targetUid);\n                if (idx !== -1) {\n                  state.board[p][lane].splice(idx, 1);\n                  state.discard.push(card);\n                  logPush(state, `âŒ ${card.name} wurde annulliert`);\n                  break;\n                }\n              }\n            }\n          }\n          break;\n        }\n      case 'REGISTER_TRAP':\n        {\n          registerTrap(state, ev.player, ev.key);\n          logPush(state, `Trap registered: ${ev.key} (P${ev.player})`);\n          break;\n        }\n\n      // UI-only event: instruct frontend to play hit animation on a specific slot\n      case 'UI_TRIGGER_HIT_ANIM':\n        {\n          // UI signal: play hit animation on the given slot. Do not mutate game state.\n          // Preferred local handling: push into VisualEffectsContext.playAnimsRef so the canvas picks it up.\n          try {\n            const ply = ev.player;\n            const lane = ev.lane;\n            const index = ev.index;\n            const key = `hit:${ply}.${lane}.${index}`;\n            if (typeof window !== 'undefined' && window.__pc_visual_effects && window.__pc_visual_effects.playAnimsRef) {\n              const now = typeof performance !== 'undefined' ? performance.now() : Date.now();\n              try {\n                window.__pc_visual_effects.playAnimsRef.current.push({\n                  uid: key,\n                  started: now,\n                  duration: 25 * 30\n                });\n              } catch (e) {}\n            } else if (typeof window !== 'undefined' && window.dispatchEvent) {\n              // fallback: dispatch DOM event for legacy listeners\n              const detail = {\n                player: ply,\n                lane,\n                index\n              };\n              try {\n                window.dispatchEvent(new CustomEvent('pc:ui_trigger_hit_anim', {\n                  detail\n                }));\n              } catch (e) {}\n            }\n          } catch (e) {}\n          break;\n        }\n      case 'BUFF_STRONGEST_GOV':\n      case 'ADJUST_INFLUENCE':\n        {\n          // Alias auf BUFF_STRONGEST_GOV\n          const player = ev.player;\n          let amount = ev.amount;\n          const reason = ev.reason;\n\n          // Special intent: Oprah media buff - compute amount based on media cards on own board\n          if (reason === 'OPRAH_MEDIA_BUFF_INTENT') {\n            const ownBoard = [...state.board[player].innen, ...state.board[player].aussen];\n            const cd = require('../data/cardDetails');\n            const mediaNames = ['Oprah Winfrey', 'Mark Zuckerberg', 'Tim Cook', 'Sam Altman'];\n            const mediaCount = ownBoard.filter(c => {\n              var _cd$getCardDetails, _cd$getCardDetails$ca;\n              const sub = (_cd$getCardDetails = cd.getCardDetails) === null || _cd$getCardDetails === void 0 ? void 0 : (_cd$getCardDetails$ca = _cd$getCardDetails.call(cd, c.name)) === null || _cd$getCardDetails$ca === void 0 ? void 0 : _cd$getCardDetails$ca.subcategories;\n              const legacy = c.tag === 'Media' || c.tag === 'Medien';\n              return Array.isArray(sub) && sub.includes('Medien') || legacy || mediaNames.includes(c.name);\n            }).length;\n            amount = Math.min(mediaCount, 3);\n            if (amount > 0) {\n              events.unshift({\n                type: 'LOG',\n                msg: `Oprah Winfrey: Media buff calculated +${amount} (max 3).`\n              });\n            } else {\n              events.unshift({\n                type: 'LOG',\n                msg: `Oprah Winfrey: No media cards on board - no buff.`\n              });\n            }\n          }\n          const tgt = getStrongestGovernment(state, player);\n          if (tgt && amount !== 0) {\n            var _state$effectFlags$ot2;\n            if (amount >= 0) {\n              tgt.tempBuffs = (tgt.tempBuffs || 0) + amount;\n            } else {\n              tgt.tempDebuffs = (tgt.tempDebuffs || 0) + Math.abs(amount);\n            }\n            logPush(state, logBuffStrongest(player, tgt.name, amount));\n\n            // Opportunist-Spiegelung (falls aktiv beim Gegner)\n            if ((_state$effectFlags$ot2 = state.effectFlags[other(player)]) !== null && _state$effectFlags$ot2 !== void 0 && _state$effectFlags$ot2.opportunistActive && amount > 0) {\n              const mirror = {\n                type: 'BUFF_STRONGEST_GOV',\n                player: other(player),\n                amount\n              };\n              events.unshift(mirror);\n              logPush(state, logOpportunist(other(player), amount));\n            }\n          }\n          break;\n        }\n      case 'DEBUFF_CARD':\n        {\n          const card = findCardByUidOnBoard(state, ev.targetUid);\n          if (card && card.kind === 'pol') {\n            const tgt = card;\n            tgt.tempDebuffs = (tgt.tempDebuffs || 0) + Math.abs(ev.amount);\n            logPush(state, `ðŸ”» ${tgt.name}: -${Math.abs(ev.amount)} Influence`);\n          }\n          break;\n        }\n\n      // ===== New intent event handlers =====\n\n      case 'DEACTIVATE_STRONGEST_ENEMY_GOV':\n        {\n          const opp = ev.player === 1 ? 2 : 1;\n          const uid = strongestGovernmentUid(state, opp);\n          if (uid !== null) {\n            events.unshift({\n              type: 'DEACTIVATE_CARD',\n              player: opp,\n              targetUid: uid\n            });\n            events.unshift({\n              type: 'LOG',\n              msg: 'Party Offensive: strongest enemy Government deactivated.'\n            });\n          } else {\n            events.unshift({\n              type: 'LOG',\n              msg: 'Party Offensive: no enemy Government to deactivate.'\n            });\n          }\n          break;\n        }\n      case 'LOCK_OPPONENT_INITIATIVES_EOT':\n        {\n          const opp = ev.player === 1 ? 2 : 1;\n          state.effectFlags[opp].initiativesLocked = true;\n          events.unshift({\n            type: 'LOG',\n            msg: 'Opposition Blockade: opponent initiatives locked until end of turn.'\n          });\n          break;\n        }\n      case 'SET_DOUBLE_PUBLIC_AURA':\n        {\n          state.effectFlags[ev.player].doublePublicAura = true;\n          events.unshift({\n            type: 'LOG',\n            msg: 'Influencer Campaign: next Public aura will be doubled.'\n          });\n          break;\n        }\n      case 'SET_OPPORTUNIST_ACTIVE':\n        {\n          const {\n            player,\n            active\n          } = ev;\n          state.effectFlags[player].opportunistActive = active;\n          if (active) {\n            events.unshift({\n              type: 'LOG',\n              msg: 'Opportunist: AP effects will be mirrored until end of turn.'\n            });\n          }\n          break;\n        }\n\n      // === CORRUPTION: Bestechungsskandal 2.0 ===\n      case 'CORRUPTION_STEAL_GOV_START':\n        {\n          // Signal UI that player must select opponent government card & roll dice\n          state.pendingAbilitySelect = {\n            type: 'corruption_steal',\n            actorPlayer: ev.player\n          };\n          events.unshift({\n            type: 'LOG',\n            msg: 'Bribery Scandal 2.0: WÃ¤hle eine gegnerische Regierungskarte und wÃ¼rfle einen W6.'\n          });\n          // Trigger UI hook to highlight targets\n          if (typeof window !== 'undefined') {\n            try {\n              window.dispatchEvent(new CustomEvent('pc:corruption_select_target', {\n                detail: {\n                  player: ev.player\n                }\n              }));\n            } catch (e) {}\n          }\n          break;\n        }\n      case 'CORRUPTION_STEAL_GOV_RESOLVE':\n        {\n          const {\n            player: actor,\n            targetUid,\n            roll\n          } = ev;\n          const victim = actor === 1 ? 2 : 1;\n\n          // Locate target card\n          const targetIdx = state.board[victim].aussen.findIndex(c => c.uid === targetUid);\n          if (targetIdx === -1) {\n            events.unshift({\n              type: 'LOG',\n              msg: 'Bribery Scandal 2.0: Zielkarte nicht gefunden.'\n            });\n            break;\n          }\n          const target = state.board[victim].aussen[targetIdx];\n\n          // Oligarch bonus\n          const oligarchCount = state.board[actor].innen.filter(c => {\n            var _getCardDetails, _ref, _getCardDetails$call;\n            const sub = (_getCardDetails = (_ref = require('../data/cardDetails')).getCardDetails) === null || _getCardDetails === void 0 ? void 0 : (_getCardDetails$call = _getCardDetails.call(_ref, c.name)) === null || _getCardDetails$call === void 0 ? void 0 : _getCardDetails$call.subcategories;\n            const hasNewTag = Array.isArray(sub) && sub.includes('Oligarch');\n            const legacy = c.tag === 'Oligarch';\n            return hasNewTag || legacy;\n          }).length;\n          const total = roll + oligarchCount;\n          const targetInfluence = target.influence + (target.tempBuffs || 0) - (target.tempDebuffs || 0);\n          events.unshift({\n            type: 'LOG',\n            msg: `Bribery Scandal 2.0: Roll ${roll} +${oligarchCount} Bonus = ${total} vs ${targetInfluence} (${target.name}).`\n          });\n          if (total >= targetInfluence) {\n            const maxSlots = 3;\n            if (state.board[actor].aussen.length < maxSlots) {\n              // Transfer card\n              state.board[victim].aussen.splice(targetIdx, 1);\n              state.board[actor].aussen.push(target);\n              events.unshift({\n                type: 'LOG',\n                msg: `Bribery Scandal 2.0: Erfolg! ${target.name} Ã¼bernommen.`\n              });\n            } else {\n              state.board[victim].aussen.splice(targetIdx, 1);\n              state.discard.push(target);\n              events.unshift({\n                type: 'LOG',\n                msg: `Bribery Scandal 2.0: Erfolg, aber kein Slot frei â€“ ${target.name} entfernt.`\n              });\n            }\n          } else {\n            events.unshift({\n              type: 'LOG',\n              msg: 'Bribery Scandal 2.0: Wurf zu niedrig â€“ keine Ãœbernahme.'\n            });\n          }\n\n          // Clear pending selection\n          state.pendingAbilitySelect = undefined;\n          break;\n        }\n      case 'INITIATIVE_ACTIVATED':\n        {\n          var _state$board$ev$playe, _state$board$ev$playe2, _state$effectFlags$ev;\n          // Initiative activation event - trigger reactions from public cards\n          logPush(state, 'Initiative activated.');\n\n          // Check for public cards that react to initiative activation\n          const publicCards = ((_state$board$ev$playe = state.board[ev.player]) === null || _state$board$ev$playe === void 0 ? void 0 : _state$board$ev$playe.innen) || [];\n\n          // Shadow Lobbying: +1 influence per own Oligarch-tag on board (max +3)\n          // Detect if the activating initiative was Shadow Lobbying by checking the last played instant in slot\n          const instantSlot = ((_state$board$ev$playe2 = state.board[ev.player]) === null || _state$board$ev$playe2 === void 0 ? void 0 : _state$board$ev$playe2.sofort) || [];\n          const lastInstant = instantSlot[0];\n          if (lastInstant && (lastInstant.effectKey === 'init.shadow_lobbying.per_oligarch' || lastInstant.name === 'Shadow Lobbying')) {\n            const ownBoard = [...state.board[ev.player].innen, ...state.board[ev.player].aussen];\n            const oligarchCount = ownBoard.filter(c => {\n              var _getCardDetails2, _ref2, _getCardDetails2$call;\n              const details = c.name ? require('../data/cardDetails') : null;\n              // Fallback: try BaseSpecial tag if available\n              const sub = (_getCardDetails2 = (_ref2 = require('../data/cardDetails')).getCardDetails) === null || _getCardDetails2 === void 0 ? void 0 : (_getCardDetails2$call = _getCardDetails2.call(_ref2, c.name)) === null || _getCardDetails2$call === void 0 ? void 0 : _getCardDetails2$call.subcategories;\n              const hasNewTag = Array.isArray(sub) && sub.includes('Oligarch');\n              const legacyTag = c.tag === 'Oligarch';\n              return hasNewTag || legacyTag;\n            }).length;\n            const amt = Math.min(oligarchCount, 3);\n            if (amt > 0) {\n              events.unshift({\n                type: 'BUFF_STRONGEST_GOV',\n                player: ev.player,\n                amount: amt\n              });\n              events.unshift({\n                type: 'LOG',\n                msg: `Shadow Lobbying: stÃ¤rkste Regierung +${amt} Einfluss (pro Oligarch, max 3).`\n              });\n            } else {\n              events.unshift({\n                type: 'LOG',\n                msg: `Shadow Lobbying: Keine Oligarchen â€“ kein Einfluss-Buff.`\n              });\n            }\n          }\n\n          // Elon Musk: +1 AP on initiative activation\n          const elonMusk = publicCards.find(card => card.kind === 'spec' && card.name === 'Elon Musk');\n          if (elonMusk) {\n            events.unshift({\n              type: 'ADD_AP',\n              player: ev.player,\n              amount: 1\n            });\n            events.unshift({\n              type: 'LOG',\n              msg: 'Elon Musk: +1 AP on initiative activation.'\n            });\n          }\n\n          // Mark Zuckerberg: +1 AP on initiative activation (once per turn)\n          const markZuckerberg = publicCards.find(card => card.kind === 'spec' && card.name === 'Mark Zuckerberg');\n          if (markZuckerberg && !((_state$effectFlags$ev = state.effectFlags[ev.player]) !== null && _state$effectFlags$ev !== void 0 && _state$effectFlags$ev.markZuckerbergUsed)) {\n            events.unshift({\n              type: 'ADD_AP',\n              player: ev.player,\n              amount: 1\n            });\n            events.unshift({\n              type: 'LOG',\n              msg: 'Mark Zuckerberg: +1 AP on initiative activation.'\n            });\n            if (!state.effectFlags[ev.player]) {\n              state.effectFlags[ev.player] = {\n                markZuckerbergUsed: false\n              };\n            }\n            state.effectFlags[ev.player].markZuckerbergUsed = true;\n          }\n\n          // Ai Weiwei: +1 card +1 AP on initiative activation\n          const aiWeiwei = publicCards.find(card => card.kind === 'spec' && card.name === 'Ai Weiwei');\n          if (aiWeiwei) {\n            events.unshift({\n              type: 'DRAW_CARDS',\n              player: ev.player,\n              amount: 1\n            });\n            events.unshift({\n              type: 'ADD_AP',\n              player: ev.player,\n              amount: 1\n            });\n            events.unshift({\n              type: 'LOG',\n              msg: 'Ai Weiwei: +1 card +1 AP on initiative activation.'\n            });\n          }\n\n          // Sam Altman: +1 card +1 AP on AI-related initiative activation\n          const samAltman = publicCards.find(card => card.kind === 'spec' && card.name === 'Sam Altman');\n          if (samAltman) {\n            // Check if the activated initiative is AI-related (would need to be passed as context)\n            // For now, this is handled via the initiative card's tag check in the activation flow\n            events.unshift({\n              type: 'LOG',\n              msg: 'Sam Altman: AI initiative detected - bonus ready.'\n            });\n          }\n\n          // Digitaler Wahlkampf: draw 1 card per own Media-tag on board\n          if (lastInstant && (lastInstant.effectKey === 'init.digital_campaign.per_media' || lastInstant.name === 'Digitaler Wahlkampf')) {\n            const ownBoard = [...state.board[ev.player].innen, ...state.board[ev.player].aussen];\n            const mediaCount = ownBoard.filter(c => {\n              var _getCardDetails3, _ref3, _getCardDetails3$call;\n              const sub = (_getCardDetails3 = (_ref3 = require('../data/cardDetails')).getCardDetails) === null || _getCardDetails3 === void 0 ? void 0 : (_getCardDetails3$call = _getCardDetails3.call(_ref3, c.name)) === null || _getCardDetails3$call === void 0 ? void 0 : _getCardDetails3$call.subcategories;\n              const legacy = c.tag === 'Medien' || c.tag === 'Media';\n              return Array.isArray(sub) && sub.includes('Medien') || legacy || Array.isArray(sub) && sub.includes('Medien') || Array.isArray(sub) && sub.includes('Medien');\n            }).length;\n            if (mediaCount > 0) {\n              events.unshift({\n                type: 'DRAW_CARDS',\n                player: ev.player,\n                amount: mediaCount\n              });\n              events.unshift({\n                type: 'LOG',\n                msg: `Digitaler Wahlkampf: ziehe ${mediaCount} Karte(n) (pro Medien-Karte).`\n              });\n            } else {\n              events.unshift({\n                type: 'LOG',\n                msg: `Digitaler Wahlkampf: Keine Medien-Karten auf dem Feld.`\n              });\n            }\n          }\n\n          // After handling public reactions, enqueue a UI-only event to trigger hit animation on opponent's effected slots\n          // We'll compute effected slots conservatively: all opponent's government and public slots that are occupied.\n          try {\n            const opp = ev.player === 1 ? 2 : 1;\n            const effectedSlots = [];\n            (state.board[opp].aussen || []).forEach((c, idx) => {\n              if (c) effectedSlots.push({\n                player: opp,\n                lane: 'aussen',\n                index: idx\n              });\n            });\n            (state.board[opp].innen || []).forEach((c, idx) => {\n              if (c) effectedSlots.push({\n                player: opp,\n                lane: 'innen',\n                index: idx\n              });\n            });\n\n            // enqueue one LOG and one UI_TRIGGER per slot (UI_TRIGGER is handled by the frontend canvas to play hit animation)\n            effectedSlots.forEach(s => {\n              events.unshift({\n                type: 'UI_TRIGGER_HIT_ANIM',\n                player: s.player,\n                lane: s.lane,\n                index: s.index\n              });\n            });\n          } catch (e) {\n            // ignore UI enqueue failures\n          }\n          break;\n        }\n\n      // ONCE_AP_ON_ACTIVATION removed - use standard ADD_AP events instead\n\n      // ON_ACTIVATE_DRAW_AP removed - use standard ADD_AP and DRAW_CARDS events instead\n\n      // Simplified AP system: No initiative-specific bonuses\n      // All AP bonuses are now immediate ADD_AP events\n    }\n    // generic after snapshot diff for AP\n    if (state.actionPoints[1] !== beforeAP[1] || state.actionPoints[2] !== beforeAP[2]) {\n      logger.dbg(`AP delta P1 ${beforeAP[1]}->${state.actionPoints[1]} | P2 ${beforeAP[2]}->${state.actionPoints[2]}`);\n    }\n  }\n  // Ensure React viewers see mutated hand arrays by creating shallow copies\n  try {\n    state.hands = {\n      1: state.hands[1] ? [...state.hands[1]] : [],\n      2: state.hands[2] ? [...state.hands[2]] : []\n    };\n    logger.dbg('resolveQueue: hand arrays shallow-copied to trigger UI updates');\n  } catch (e) {\n    logger.dbg('resolveQueue: failed to shallow-copy hands', e);\n  }\n}","map":{"version":3,"names":["getStrongestGovernment","registerTrap","logAP","logDraw","logDiscardRandom","logDeactivateRandom","logBuffStrongest","logShield","logDeactivateCard","logOpportunist","getGlobalRNG","logger","strongestGovernmentUid","state","p","_state$board$p","govRow","board","aussen","length","alive","filter","g","deactivated","sorted","slice","sort","a","b","influence","tempBuffs","tempDebuffs","uid","other","logPush","msg","log","push","strongestGov","row","c","publicNames","innen","map","name","hasPublic","includes","findCardByUidOnBoard","lane","arr","hit","find","findCardSlotByUid","idx","findIndex","player","index","permGov","permanentSlots","government","permPub","public","permGov2","permPub2","resolveQueue","events","rng","ev","shift","dbg","type","beforeAP","actionPoints","_state$effectFlags$ot","cur","next","Math","max","amount","effectFlags","opportunistActive","mirror","unshift","handBefore","hands","i","top","decks","handAfter","hand","randomInt","card","splice","discard","activeCards","pick","_deactivatedBy","indexOf","shields","Set","targetUid","undefined","add","effectKey","placeholder","delete","key","ply","window","__pc_visual_effects","playAnimsRef","now","performance","Date","current","started","duration","e","dispatchEvent","detail","CustomEvent","reason","ownBoard","cd","require","mediaNames","mediaCount","_cd$getCardDetails","_cd$getCardDetails$ca","sub","getCardDetails","call","subcategories","legacy","tag","Array","isArray","min","tgt","_state$effectFlags$ot2","abs","kind","opp","initiativesLocked","doublePublicAura","active","pendingAbilitySelect","actorPlayer","actor","roll","victim","targetIdx","target","oligarchCount","_getCardDetails","_ref","_getCardDetails$call","hasNewTag","total","targetInfluence","maxSlots","_state$board$ev$playe","_state$board$ev$playe2","_state$effectFlags$ev","publicCards","instantSlot","sofort","lastInstant","_getCardDetails2","_ref2","_getCardDetails2$call","details","legacyTag","amt","elonMusk","markZuckerberg","markZuckerbergUsed","aiWeiwei","samAltman","_getCardDetails3","_ref3","_getCardDetails3$call","effectedSlots","forEach","s"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/utils/queue.ts"],"sourcesContent":["import { GameState, Player, PoliticianCard, Card } from '../types/game';\nimport { EffectEvent } from '../types/effects';\nimport { getStrongestGovernment } from './targets';\nimport { AP_CAP, MAX_DISCOUNT, MAX_REFUND } from '../config/gameConstants';\nimport { registerTrap } from './traps';\nimport {\n  logAP, logDiscount, logRefund, logDraw, logDiscardRandom,\n  logDeactivateRandom, logBuffStrongest, logShield, logDeactivateCard,\n  logInitiativeAura, logAiWeiwei, logPlattformBonus, logOpportunist\n} from './logs';\nimport { getGlobalRNG } from '../services/rng';\nimport { logger } from '../debug/logger';\n// Helper to find strongest government uid for new intents\nfunction strongestGovernmentUid(state: GameState, p: Player): number | null {\n  const govRow = state.board[p]?.aussen as PoliticianCard[];\n  if (!govRow || govRow.length === 0) return null;\n  const alive = govRow.filter(g => !(g as any).deactivated);\n  if (!alive.length) return null;\n  const sorted = alive.slice().sort((a,b) => (b.influence + (b.tempBuffs||0) - (b.tempDebuffs||0)) - (a.influence + (a.tempBuffs||0) - (a.tempDebuffs||0)));\n  return sorted[0].uid;\n}\n\nfunction other(p: Player): Player { return p === 1 ? 2 : 1; }\nfunction logPush(state: GameState, msg: string) { state.log.push(msg); }\n\nfunction strongestGov(state: GameState, p: Player): PoliticianCard | null {\n  const row = state.board[p].aussen as PoliticianCard[];\n  if (!row.length) return null;\n  const alive = row.filter(c => !c.deactivated);\n  if (alive.length === 0) return null;\n  return alive.slice().sort((a,b) => (b.influence + (b.tempBuffs||0) - (b.tempDebuffs||0)) - (a.influence + (a.tempBuffs||0) - (a.tempDebuffs||0)))[0];\n}\n\nfunction publicNames(state: GameState, p: Player): string[] {\n  return state.board[p].innen.map(c => c.name);\n}\n\nfunction hasPublic(state: GameState, p: Player, name: string): boolean {\n  return publicNames(state, p).includes(name);\n}\n\nfunction findCardByUidOnBoard(state: GameState, uid: number): Card | null {\n  for (const p of [1,2] as const) {\n    for (const lane of ['innen','aussen','sofort'] as const) {\n      const arr = state.board[p][lane];\n      const hit = arr.find(c => c.uid === uid);\n      if (hit) return hit;\n    }\n  }\n  return null;\n}\n\n// Find the slot location for a card uid on the board\nfunction findCardSlotByUid(state: GameState, uid: number): { player: Player; lane: string; index: number } | null {\n  for (const p of [1,2] as const) {\n    for (const lane of ['innen','aussen','sofort'] as const) {\n      const arr = state.board[p][lane];\n      const idx = arr.findIndex(c => c.uid === uid);\n      if (idx !== -1) return { player: p, lane, index: idx };\n    }\n  }\n  // check permanent slots\n  const permGov = state.permanentSlots[1].government as any;\n  if (permGov && permGov.uid === uid) return { player: 1, lane: 'permanent.government', index: 0 };\n  const permPub = state.permanentSlots[1].public as any;\n  if (permPub && permPub.uid === uid) return { player: 1, lane: 'permanent.public', index: 0 };\n  const permGov2 = state.permanentSlots[2].government as any;\n  if (permGov2 && permGov2.uid === uid) return { player: 2, lane: 'permanent.government', index: 0 };\n  const permPub2 = state.permanentSlots[2].public as any;\n  if (permPub2 && permPub2.uid === uid) return { player: 2, lane: 'permanent.public', index: 0 };\n  return null;\n}\n\nexport function resolveQueue(state: GameState, events: EffectEvent[]) {\n  const rng = getGlobalRNG();\n\n  // Single pass FIFO\n  while (events.length) {\n    const ev = events.shift()!;\n    logger.dbg(`DQ ${ev.type}`, ev);\n    // Capture small snapshot for delta calc\n    const beforeAP = { ...state.actionPoints };\n\n    switch (ev.type) {\n      case 'LOG': {\n        logPush(state, ev.msg);\n        break;\n      }\n\n      case 'ADD_AP': {\n        const cur = state.actionPoints[ev.player];\n        const next = Math.max(0, cur + ev.amount);\n        state.actionPoints[ev.player] = next;\n        logger.dbg(`ADD_AP before=${cur} amount=${ev.amount} after=${state.actionPoints[ev.player]}`);\n\n        // Opportunist AP-Spiegelung (falls aktiv beim Gegner)\n        if (state.effectFlags[other(ev.player)]?.opportunistActive && ev.amount > 0) {\n          const mirror = { type: 'ADD_AP', player: other(ev.player), amount: ev.amount } as EffectEvent;\n          events.unshift(mirror);\n          logPush(state, `Opportunist: AP +${ev.amount} gespiegelt.`);\n        }\n\n        logPush(state, logAP(ev.player, cur, next));\n        break;\n      }\n\n      case 'DRAW_CARDS': {\n        const handBefore = state.hands[ev.player].length;\n        for (let i = 0; i < ev.amount; i++) {\n          const top = state.decks[ev.player].shift();\n          if (top) {\n            state.hands[ev.player].push(top);\n            logPush(state, logDraw(ev.player, top.name));\n          }\n        }\n        const handAfter = state.hands[ev.player].length;\n        logger.dbg(`DRAW_CARDS player=${ev.player} before=${handBefore} after=${handAfter}`);\n        break;\n      }\n\n      case 'DISCARD_RANDOM_FROM_HAND': {\n        const hand = state.hands[ev.player];\n        for (let i = 0; i < ev.amount && hand.length > 0; i++) {\n          const idx = rng.randomInt(hand.length);\n          const [card] = hand.splice(idx, 1);\n          state.discard.push(card);\n          logPush(state, logDiscardRandom(ev.player, card.name));\n        }\n        break;\n      }\n\n      case 'DEACTIVATE_RANDOM_HAND': {\n        // Deaktivieren von Handkarten (nicht entfernen)\n        const hand = state.hands[ev.player];\n        const activeCards = hand.filter(c => !(c as any).deactivated);\n        logger.dbg(`DEACTIVATE_RANDOM_HAND: P${ev.player} handSize=${hand.length} activeCandidates=${activeCards.length}`);\n        if (activeCards.length === 0) {\n          logPush(state, `Oprah: no active hand cards to deactivate for P${ev.player}`);\n          break;\n        }\n        for (let i = 0; i < ev.amount && activeCards.length > 0; i++) {\n          const card = rng.pick(activeCards);\n          logger.dbg(`DEACTIVATE_RANDOM_HAND: picked=${card ? card.name : 'undefined'} for P${ev.player}`);\n          if (card) {\n            (card as any).deactivated = true;\n            (card as any)._deactivatedBy = 'OPRAH';\n            logPush(state, logDeactivateRandom(ev.player, card.name));\n            // Entferne aus activeCards fÃ¼r nÃ¤chste Iteration\n            const idx = activeCards.indexOf(card);\n            if (idx > -1) activeCards.splice(idx, 1);\n          }\n        }\n        break;\n      }\n\n      // Legacy cases - removed\n      // SET_DISCOUNT and REFUND_NEXT_INITIATIVE are no longer supported\n      // Use ADD_AP instead\n\n      case 'GRANT_SHIELD': {\n        if (!state.shields) state.shields = new Set();\n        // Wenn kein spezifischer targetUid angegeben ist, verwende Platzhalter pro Spieler (-1 oder -2)\n        const uid = ev.targetUid !== undefined ? ev.targetUid : (ev.player === 1 ? -1 : -2);\n        state.shields.add(uid);\n        logPush(state, logShield(uid));\n        break;\n      }\n\n      case 'DEACTIVATE_CARD': {\n        const card = findCardByUidOnBoard(state, ev.targetUid);\n        if (card) {\n          (card as any).deactivated = true;\n          logPush(state, logDeactivateCard(card.name));\n\n          // Falls die Karte eine Shield-Aura ist, entferne Spielerschilde\n          if ((card as any).effectKey === 'init.intelligence_liaison.shield_aura') {\n            if (state.shields) {\n              const placeholder = ev.player === 1 ? -1 : -2;\n              state.shields.delete(placeholder);\n            }\n          }\n        }\n        break;\n      }\n\n      case 'REACTIVATE_CARD': {\n        const card = findCardByUidOnBoard(state, ev.targetUid);\n        if (card) {\n          (card as any).deactivated = false;\n          logPush(state, `ðŸ”„ ${card.name} wurde reaktiviert`);\n        }\n        break;\n      }\n\n      case 'RETURN_TO_HAND': {\n        const card = findCardByUidOnBoard(state, ev.targetUid);\n        if (card) {\n          // Remove from board\n          for (const p of [1, 2] as const) {\n            for (const lane of ['innen', 'aussen', 'sofort'] as const) {\n              const idx = state.board[p][lane].findIndex(c => c.uid === ev.targetUid);\n              if (idx !== -1) {\n                state.board[p][lane].splice(idx, 1);\n                // Add to hand\n                state.hands[ev.player].push(card);\n                logPush(state, `ðŸ”„ ${card.name} wurde zur Hand zurÃ¼ckgegeben`);\n                break;\n              }\n            }\n          }\n        }\n        break;\n      }\n\n      case 'CANCEL_CARD': {\n        const card = findCardByUidOnBoard(state, ev.targetUid);\n        if (card) {\n          // Remove from board and add to discard\n          for (const p of [1, 2] as const) {\n            for (const lane of ['innen', 'aussen', 'sofort'] as const) {\n              const idx = state.board[p][lane].findIndex(c => c.uid === ev.targetUid);\n              if (idx !== -1) {\n                state.board[p][lane].splice(idx, 1);\n                state.discard.push(card);\n                logPush(state, `âŒ ${card.name} wurde annulliert`);\n                break;\n              }\n            }\n          }\n        }\n        break;\n      }\n\n      case 'REGISTER_TRAP': {\n        registerTrap(state, ev.player, (ev as any).key);\n        logPush(state, `Trap registered: ${(ev as any).key} (P${ev.player})`);\n        break;\n      }\n\n      // UI-only event: instruct frontend to play hit animation on a specific slot\n      case 'UI_TRIGGER_HIT_ANIM': {\n        // UI signal: play hit animation on the given slot. Do not mutate game state.\n        // Preferred local handling: push into VisualEffectsContext.playAnimsRef so the canvas picks it up.\n        try {\n          const ply = ev.player as Player;\n          const lane = (ev as any).lane as string;\n          const index = (ev as any).index as number;\n          const key = `hit:${ply}.${lane}.${index}`;\n          if (typeof window !== 'undefined' && (window as any).__pc_visual_effects && (window as any).__pc_visual_effects.playAnimsRef) {\n            const now = (typeof performance !== 'undefined') ? performance.now() : Date.now();\n            try { (window as any).__pc_visual_effects.playAnimsRef.current.push({ uid: key, started: now, duration: 25 * 30 }); } catch (e) {}\n          } else if (typeof window !== 'undefined' && (window as any).dispatchEvent) {\n            // fallback: dispatch DOM event for legacy listeners\n            const detail = { player: ply, lane, index };\n            try { window.dispatchEvent(new CustomEvent('pc:ui_trigger_hit_anim', { detail })); } catch (e) {}\n          }\n        } catch (e) {}\n        break;\n      }\n\n      case 'BUFF_STRONGEST_GOV':\n      case 'ADJUST_INFLUENCE': { // Alias auf BUFF_STRONGEST_GOV\n        const player = ev.player;\n        let amount = (ev as any).amount;\n        const reason = (ev as any).reason as string | undefined;\n\n        // Special intent: Oprah media buff - compute amount based on media cards on own board\n        if (reason === 'OPRAH_MEDIA_BUFF_INTENT') {\n          const ownBoard = [\n            ...state.board[player].innen,\n            ...state.board[player].aussen,\n          ];\n          const cd = require('../data/cardDetails') as any;\n          const mediaNames = ['Oprah Winfrey', 'Mark Zuckerberg', 'Tim Cook', 'Sam Altman'];\n          const mediaCount = ownBoard.filter(c => {\n            const sub = cd.getCardDetails?.(c.name)?.subcategories as string[] | undefined;\n            const legacy = (c as any).tag === 'Media' || (c as any).tag === 'Medien';\n            return (Array.isArray(sub) && sub.includes('Medien')) || legacy || mediaNames.includes(c.name);\n          }).length;\n          amount = Math.min(mediaCount, 3);\n          if (amount > 0) {\n            events.unshift({ type: 'LOG', msg: `Oprah Winfrey: Media buff calculated +${amount} (max 3).` });\n          } else {\n            events.unshift({ type: 'LOG', msg: `Oprah Winfrey: No media cards on board - no buff.` });\n          }\n        }\n\n        const tgt = getStrongestGovernment(state, player);\n        if (tgt && amount !== 0) {\n          if (amount >= 0) {\n            (tgt as PoliticianCard).tempBuffs = ((tgt as PoliticianCard).tempBuffs || 0) + amount;\n          } else {\n            (tgt as PoliticianCard).tempDebuffs = ((tgt as PoliticianCard).tempDebuffs || 0) + Math.abs(amount);\n          }\n          logPush(state, logBuffStrongest(player, tgt.name, amount));\n\n          // Opportunist-Spiegelung (falls aktiv beim Gegner)\n          if (state.effectFlags[other(player)]?.opportunistActive && amount > 0) {\n            const mirror = { type: 'BUFF_STRONGEST_GOV', player: other(player), amount } as EffectEvent;\n            events.unshift(mirror);\n            logPush(state, logOpportunist(other(player), amount));\n          }\n        }\n        break;\n      }\n\n      case 'DEBUFF_CARD': {\n        const card = findCardByUidOnBoard(state, ev.targetUid);\n        if (card && card.kind === 'pol') {\n          const tgt = card as any;\n          tgt.tempDebuffs = (tgt.tempDebuffs || 0) + Math.abs((ev as any).amount);\n          logPush(state, `ðŸ”» ${tgt.name}: -${Math.abs((ev as any).amount)} Influence`);\n        }\n        break;\n      }\n\n      // ===== New intent event handlers =====\n\n      case 'DEACTIVATE_STRONGEST_ENEMY_GOV': {\n        const opp: Player = ev.player === 1 ? 2 : 1;\n        const uid = strongestGovernmentUid(state, opp);\n        if (uid !== null) {\n          events.unshift({ type: 'DEACTIVATE_CARD', player: opp, targetUid: uid });\n          events.unshift({ type: 'LOG', msg: 'Party Offensive: strongest enemy Government deactivated.' });\n        } else {\n          events.unshift({ type: 'LOG', msg: 'Party Offensive: no enemy Government to deactivate.' });\n        }\n        break;\n      }\n\n      case 'LOCK_OPPONENT_INITIATIVES_EOT': {\n        const opp: Player = ev.player === 1 ? 2 : 1;\n        state.effectFlags[opp].initiativesLocked = true;\n        events.unshift({ type: 'LOG', msg: 'Opposition Blockade: opponent initiatives locked until end of turn.' });\n        break;\n      }\n\n      case 'SET_DOUBLE_PUBLIC_AURA': {\n        state.effectFlags[ev.player].doublePublicAura = true;\n        events.unshift({ type: 'LOG', msg: 'Influencer Campaign: next Public aura will be doubled.' });\n        break;\n      }\n\n      case 'SET_OPPORTUNIST_ACTIVE': {\n        const { player, active } = ev as { type: 'SET_OPPORTUNIST_ACTIVE'; player: Player; active: boolean };\n        state.effectFlags[player].opportunistActive = active;\n        if (active) {\n          events.unshift({ type: 'LOG', msg: 'Opportunist: AP effects will be mirrored until end of turn.' });\n        }\n        break;\n      }\n\n      // === CORRUPTION: Bestechungsskandal 2.0 ===\n      case 'CORRUPTION_STEAL_GOV_START': {\n        // Signal UI that player must select opponent government card & roll dice\n        (state as any).pendingAbilitySelect = {\n          type: 'corruption_steal',\n          actorPlayer: ev.player\n        } as any;\n\n        events.unshift({ type: 'LOG', msg: 'Bribery Scandal 2.0: WÃ¤hle eine gegnerische Regierungskarte und wÃ¼rfle einen W6.' });\n        // Trigger UI hook to highlight targets\n        if (typeof window !== 'undefined') {\n          try {\n            window.dispatchEvent(new CustomEvent('pc:corruption_select_target', { detail: { player: ev.player } }));\n          } catch(e) {}\n        }\n        break;\n      }\n\n      case 'CORRUPTION_STEAL_GOV_RESOLVE': {\n        const { player: actor, targetUid, roll } = ev as any;\n        const victim: Player = actor === 1 ? 2 : 1;\n\n        // Locate target card\n        const targetIdx = state.board[victim].aussen.findIndex(c => c.uid === targetUid);\n        if (targetIdx === -1) {\n          events.unshift({ type: 'LOG', msg: 'Bribery Scandal 2.0: Zielkarte nicht gefunden.' });\n          break;\n        }\n        const target = state.board[victim].aussen[targetIdx] as any;\n\n        // Oligarch bonus\n        const oligarchCount = state.board[actor].innen.filter(c => {\n          const sub = (require('../data/cardDetails') as any).getCardDetails?.(c.name)?.subcategories as string[] | undefined;\n          const hasNewTag = Array.isArray(sub) && sub.includes('Oligarch');\n          const legacy = (c as any).tag === 'Oligarch';\n          return hasNewTag || legacy;\n        }).length;\n\n        const total = roll + oligarchCount;\n        const targetInfluence = target.influence + (target.tempBuffs||0) - (target.tempDebuffs||0);\n\n        events.unshift({ type: 'LOG', msg: `Bribery Scandal 2.0: Roll ${roll} +${oligarchCount} Bonus = ${total} vs ${targetInfluence} (${target.name}).` });\n\n        if (total >= targetInfluence) {\n          const maxSlots = 3;\n          if (state.board[actor].aussen.length < maxSlots) {\n            // Transfer card\n            state.board[victim].aussen.splice(targetIdx,1);\n            state.board[actor].aussen.push(target);\n            events.unshift({ type: 'LOG', msg: `Bribery Scandal 2.0: Erfolg! ${target.name} Ã¼bernommen.` });\n          } else {\n            state.board[victim].aussen.splice(targetIdx,1);\n            state.discard.push(target);\n            events.unshift({ type: 'LOG', msg: `Bribery Scandal 2.0: Erfolg, aber kein Slot frei â€“ ${target.name} entfernt.` });\n          }\n        } else {\n          events.unshift({ type: 'LOG', msg: 'Bribery Scandal 2.0: Wurf zu niedrig â€“ keine Ãœbernahme.' });\n        }\n\n        // Clear pending selection\n        (state as any).pendingAbilitySelect = undefined;\n        break;\n      }\n\n      case 'INITIATIVE_ACTIVATED': {\n        // Initiative activation event - trigger reactions from public cards\n        logPush(state, 'Initiative activated.');\n\n        // Check for public cards that react to initiative activation\n        const publicCards = state.board[ev.player]?.innen || [];\n\n        // Shadow Lobbying: +1 influence per own Oligarch-tag on board (max +3)\n        // Detect if the activating initiative was Shadow Lobbying by checking the last played instant in slot\n        const instantSlot = state.board[ev.player]?.sofort || [];\n        const lastInstant = instantSlot[0] as any;\n        if (lastInstant && (lastInstant.effectKey === 'init.shadow_lobbying.per_oligarch' || lastInstant.name === 'Shadow Lobbying')) {\n          const ownBoard = [\n            ...state.board[ev.player].innen,\n            ...state.board[ev.player].aussen,\n          ];\n          const oligarchCount = ownBoard.filter(c => {\n            const details = (c as any).name ? require('../data/cardDetails') as any : null;\n            // Fallback: try BaseSpecial tag if available\n            const sub = (require('../data/cardDetails') as any).getCardDetails?.((c as any).name)?.subcategories as string[] | undefined;\n            const hasNewTag = Array.isArray(sub) && sub.includes('Oligarch');\n            const legacyTag = (c as any).tag === 'Oligarch';\n            return hasNewTag || legacyTag;\n          }).length;\n          const amt = Math.min(oligarchCount, 3);\n          if (amt > 0) {\n            events.unshift({ type: 'BUFF_STRONGEST_GOV', player: ev.player, amount: amt });\n            events.unshift({ type: 'LOG', msg: `Shadow Lobbying: stÃ¤rkste Regierung +${amt} Einfluss (pro Oligarch, max 3).` });\n          } else {\n            events.unshift({ type: 'LOG', msg: `Shadow Lobbying: Keine Oligarchen â€“ kein Einfluss-Buff.` });\n          }\n        }\n\n        // Elon Musk: +1 AP on initiative activation\n        const elonMusk = publicCards.find(card =>\n          card.kind === 'spec' && (card as any).name === 'Elon Musk'\n        );\n        if (elonMusk) {\n          events.unshift({ type: 'ADD_AP', player: ev.player, amount: 1 });\n          events.unshift({ type: 'LOG', msg: 'Elon Musk: +1 AP on initiative activation.' });\n        }\n\n        // Mark Zuckerberg: +1 AP on initiative activation (once per turn)\n        const markZuckerberg = publicCards.find(card =>\n          card.kind === 'spec' && (card as any).name === 'Mark Zuckerberg'\n        );\n        if (markZuckerberg && !state.effectFlags[ev.player]?.markZuckerbergUsed) {\n          events.unshift({ type: 'ADD_AP', player: ev.player, amount: 1 });\n          events.unshift({ type: 'LOG', msg: 'Mark Zuckerberg: +1 AP on initiative activation.' });\n          if (!state.effectFlags[ev.player]) {\n            state.effectFlags[ev.player] = { markZuckerbergUsed: false };\n          }\n          state.effectFlags[ev.player].markZuckerbergUsed = true;\n        }\n\n        // Ai Weiwei: +1 card +1 AP on initiative activation\n        const aiWeiwei = publicCards.find(card =>\n          card.kind === 'spec' && (card as any).name === 'Ai Weiwei'\n        );\n        if (aiWeiwei) {\n          events.unshift({ type: 'DRAW_CARDS', player: ev.player, amount: 1 });\n          events.unshift({ type: 'ADD_AP', player: ev.player, amount: 1 });\n          events.unshift({ type: 'LOG', msg: 'Ai Weiwei: +1 card +1 AP on initiative activation.' });\n        }\n\n        // Sam Altman: +1 card +1 AP on AI-related initiative activation\n        const samAltman = publicCards.find(card =>\n          card.kind === 'spec' && (card as any).name === 'Sam Altman'\n        );\n        if (samAltman) {\n          // Check if the activated initiative is AI-related (would need to be passed as context)\n          // For now, this is handled via the initiative card's tag check in the activation flow\n          events.unshift({ type: 'LOG', msg: 'Sam Altman: AI initiative detected - bonus ready.' });\n        }\n\n        // Digitaler Wahlkampf: draw 1 card per own Media-tag on board\n        if (lastInstant && (lastInstant.effectKey === 'init.digital_campaign.per_media' || lastInstant.name === 'Digitaler Wahlkampf')) {\n          const ownBoard = [\n            ...state.board[ev.player].innen,\n            ...state.board[ev.player].aussen,\n          ];\n          const mediaCount = ownBoard.filter(c => {\n            const sub = (require('../data/cardDetails') as any).getCardDetails?.((c as any).name)?.subcategories as string[] | undefined;\n            const legacy = (c as any).tag === 'Medien' || (c as any).tag === 'Media';\n            return (Array.isArray(sub) && sub.includes('Medien')) || legacy || (Array.isArray(sub) && sub.includes('Medien')) || (Array.isArray(sub) && sub.includes('Medien'));\n          }).length;\n          if (mediaCount > 0) {\n            events.unshift({ type: 'DRAW_CARDS', player: ev.player, amount: mediaCount });\n            events.unshift({ type: 'LOG', msg: `Digitaler Wahlkampf: ziehe ${mediaCount} Karte(n) (pro Medien-Karte).` });\n          } else {\n            events.unshift({ type: 'LOG', msg: `Digitaler Wahlkampf: Keine Medien-Karten auf dem Feld.` });\n          }\n        }\n\n        // After handling public reactions, enqueue a UI-only event to trigger hit animation on opponent's effected slots\n        // We'll compute effected slots conservatively: all opponent's government and public slots that are occupied.\n        try {\n          const opp: Player = ev.player === 1 ? 2 : 1;\n          const effectedSlots: Array<{ player: Player; lane: string; index: number } > = [];\n          (state.board[opp].aussen || []).forEach((c, idx) => { if (c) effectedSlots.push({ player: opp, lane: 'aussen', index: idx }); });\n          (state.board[opp].innen || []).forEach((c, idx) => { if (c) effectedSlots.push({ player: opp, lane: 'innen', index: idx }); });\n\n          // enqueue one LOG and one UI_TRIGGER per slot (UI_TRIGGER is handled by the frontend canvas to play hit animation)\n          effectedSlots.forEach(s => {\n            events.unshift({ type: 'UI_TRIGGER_HIT_ANIM', player: s.player, lane: s.lane, index: s.index } as any);\n          });\n        } catch (e) {\n          // ignore UI enqueue failures\n        }\n\n        break;\n      }\n\n      // ONCE_AP_ON_ACTIVATION removed - use standard ADD_AP events instead\n\n      // ON_ACTIVATE_DRAW_AP removed - use standard ADD_AP and DRAW_CARDS events instead\n\n      // Simplified AP system: No initiative-specific bonuses\n      // All AP bonuses are now immediate ADD_AP events\n\n\n    }\n    // generic after snapshot diff for AP\n    if (state.actionPoints[1] !== beforeAP[1] || state.actionPoints[2] !== beforeAP[2]) {\n      logger.dbg(`AP delta P1 ${beforeAP[1]}->${state.actionPoints[1]} | P2 ${beforeAP[2]}->${state.actionPoints[2]}`);\n    }\n  }\n  // Ensure React viewers see mutated hand arrays by creating shallow copies\n  try {\n    state.hands = {\n      1: state.hands[1] ? [...state.hands[1]] : [],\n      2: state.hands[2] ? [...state.hands[2]] : []\n    } as any;\n    logger.dbg('resolveQueue: hand arrays shallow-copied to trigger UI updates');\n  } catch (e) {\n    logger.dbg('resolveQueue: failed to shallow-copy hands', e);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}