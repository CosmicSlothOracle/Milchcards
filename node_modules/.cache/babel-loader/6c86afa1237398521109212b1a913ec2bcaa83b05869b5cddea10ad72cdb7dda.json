{"ast":null,"code":"import _objectSpread from\"C:/Users/skank/Videos/Cards/Milchcards/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// Animation Engine - Fixed-Timestep Event-basiertes System\n// Integriert mit bestehender Game-Engine Event-Queue\nimport{ANIMATION_REGISTRY,ANIMATION_CONFIG,getFrameEvents,getCharacterDefinition}from'../data/animationRegistry';export class AnimationEngine{constructor(){this.state=void 0;this.eventQueue=[];this.lastUpdateTime=0;this.isRunning=false;this.state={characters:new Map(),projectiles:new Map(),effects:new Map(),globalTime:0,lastUpdate:0};}// === CORE UPDATE LOOP ===\nupdate(currentTime){// Auto-start if not running\nif(!this.isRunning){this.start();}// Fixed-Timestep Update\nconst deltaTime=currentTime-this.lastUpdateTime;if(deltaTime>=ANIMATION_CONFIG.fixedTimestep){this.fixedUpdate();this.lastUpdateTime=currentTime;}}// Alternative update method for testing\nupdateDirect(deltaTime){// Simulate multiple fixed timesteps\nconst steps=Math.floor(deltaTime/ANIMATION_CONFIG.fixedTimestep);for(let i=0;i<steps;i++){this.fixedUpdate();}}fixedUpdate(){this.state.globalTime+=ANIMATION_CONFIG.fixedTimestep;// Update Characters\nthis.updateCharacters();// Update Projectiles\nthis.updateProjectiles();// Update Effects\nthis.updateEffects();// Process Animation Events\nthis.processAnimationEvents();}// === CHARACTER MANAGEMENT ===\ncreateCharacter(id,position){let facing=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;const character={id,position:_objectSpread({},position),facing,currentAnimation:'idle',animationFrame:0,animationTime:0};this.state.characters.set(id,character);}playAnimation(characterId,animationName){const character=this.state.characters.get(characterId);if(!character)return false;const animationData=ANIMATION_REGISTRY[animationName];if(!animationData)return false;// Reset animation state\ncharacter.currentAnimation=animationName;character.animationFrame=0;character.animationTime=0;return true;}updateCharacters(){this.state.characters.forEach((character,id)=>{this.updateCharacterAnimation(character);});}updateCharacterAnimation(character){const animationData=ANIMATION_REGISTRY[character.currentAnimation];if(!animationData)return;// Calculate frame time\nconst frameTime=1000/animationData.fps;const newFrame=Math.floor(character.animationTime/frameTime);// Check for frame change\nif(newFrame!==character.animationFrame){const oldFrame=character.animationFrame;character.animationFrame=newFrame;// Process frame events\nthis.processFrameEvents(character,oldFrame,newFrame);}// Handle animation completion\nif(character.animationFrame>=animationData.frames){if(animationData.loop){character.animationFrame=0;character.animationTime=0;}else{// Animation complete - fire complete event\nthis.enqueueAnimationEvent(character.id,{frame:animationData.frames-1,type:'complete',data:{}});}}// Update animation time\ncharacter.animationTime+=ANIMATION_CONFIG.fixedTimestep;}// === PROJECTILE MANAGEMENT ===\ncreateProjectile(id,position,velocity,owner){let damage=arguments.length>4&&arguments[4]!==undefined?arguments[4]:15;let knockback=arguments.length>5&&arguments[5]!==undefined?arguments[5]:{x:30,y:-15};let hitstun=arguments.length>6&&arguments[6]!==undefined?arguments[6]:200;const projectile={id,position:_objectSpread({},position),facing:velocity.x>0?1:-1,currentAnimation:'projectile',animationFrame:0,animationTime:0,velocity:_objectSpread({},velocity),speed:Math.sqrt(velocity.x*velocity.x+velocity.y*velocity.y),maxLifetime:1200,// 1.2s fail-safe\nlifetime:0,damage,knockback,hitstun,owner};this.state.projectiles.set(id,projectile);}updateProjectiles(){this.state.projectiles.forEach((projectile,id)=>{this.updateProjectile(projectile);});}updateProjectile(projectile){// Update position\nif(projectile.velocity){projectile.position.x+=projectile.velocity.x*(ANIMATION_CONFIG.fixedTimestep/1000);projectile.position.y+=projectile.velocity.y*(ANIMATION_CONFIG.fixedTimestep/1000);}// Update lifetime\nprojectile.lifetime+=ANIMATION_CONFIG.fixedTimestep;// Check lifetime\nif(projectile.lifetime>=projectile.maxLifetime){this.destroyProjectile(projectile.id);return;}// Update animation\nthis.updateCharacterAnimation(projectile);// Check collisions\nthis.checkProjectileCollisions(projectile);}checkProjectileCollisions(projectile){// Check against all characters (except owner)\nthis.state.characters.forEach((character,characterId)=>{if(characterId===projectile.owner)return;// Simple collision check (can be expanded with proper hitbox system)\nconst distance=Math.sqrt(Math.pow(projectile.position.x-character.position.x,2)+Math.pow(projectile.position.y-character.position.y,2));if(distance<50){// Simple radius collision\nthis.hitCharacter(characterId,projectile);this.destroyProjectile(projectile.id);return;}});}hitCharacter(characterId,projectile){// Create blast effect at hit position\nconst blastId=\"blast_\".concat(Date.now(),\"_\").concat(Math.random());this.createEffect(blastId,projectile.position,'blast');}destroyProjectile(projectileId){const projectile=this.state.projectiles.get(projectileId);if(!projectile)return;// Switch to die animation briefly\nprojectile.currentAnimation='die';projectile.animationFrame=0;projectile.animationTime=0;// Remove after die animation completes\nsetTimeout(()=>{this.state.projectiles.delete(projectileId);},150);// 3 frames at 20fps\n}// Test helper method to force destroy projectile\nforceDestroyProjectile(projectileId){this.state.projectiles.delete(projectileId);}// === EFFECT MANAGEMENT ===\ncreateEffect(id,position,animationName){const effect={id,position:_objectSpread({},position),facing:1,currentAnimation:animationName,animationFrame:0,animationTime:0};this.state.effects.set(id,effect);}updateEffects(){this.state.effects.forEach((effect,id)=>{this.updateCharacterAnimation(effect);});}// === EVENT PROCESSING ===\nprocessFrameEvents(character,oldFrame,newFrame){const animationData=ANIMATION_REGISTRY[character.currentAnimation];if(!animationData||!animationData.events)return;// Process events for all frames between oldFrame and newFrame\nfor(let frame=oldFrame+1;frame<=newFrame;frame++){const events=getFrameEvents(character.currentAnimation,frame);for(const event of events){this.enqueueAnimationEvent(character.id,event);}}}enqueueAnimationEvent(characterId,event){const animationEvent={type:'ANIMATION_EVENT',characterId,event,timestamp:this.state.globalTime};this.eventQueue.push(animationEvent);}processAnimationEvents(){while(this.eventQueue.length>0){const event=this.eventQueue.shift();this.handleAnimationEvent(event);}}handleAnimationEvent(event){switch(event.event.type){case'spawnProjectile':this.handleSpawnProjectile(event);break;case'playSfx':this.handlePlaySfx(event);break;case'emitFx':this.handleEmitFx(event);break;case'dealDamage':this.handleDealDamage(event);break;case'cameraShake':this.handleCameraShake(event);break;case'complete':this.handleAnimationComplete(event);break;}}handleSpawnProjectile(event){const character=this.state.characters.get(event.characterId);if(!character)return;const characterDef=getCharacterDefinition(character.id);if(!characterDef||!characterDef.muzzleOffset)return;// Calculate muzzle position\nconst muzzleOffset=characterDef.muzzleOffset;const facingMultiplier=character.facing;const projectilePosition={x:character.position.x+muzzleOffset.x*facingMultiplier,y:character.position.y+muzzleOffset.y};// Calculate velocity\nconst speed=1000;// px/s\nconst velocity={x:speed*facingMultiplier,y:0};// Create projectile\nconst projectileId=\"projectile_\".concat(Date.now(),\"_\").concat(Math.random());this.createProjectile(projectileId,projectilePosition,velocity,character.id);}handlePlaySfx(event){var _event$event$data;// Integrate with existing audio system\nconsole.log(\"SFX: \".concat((_event$event$data=event.event.data)===null||_event$event$data===void 0?void 0:_event$event$data.sound,\" for \").concat(event.characterId));}handleEmitFx(event){var _event$event$data2;const character=this.state.characters.get(event.characterId);if(!character)return;const effectId=\"fx_\".concat(Date.now(),\"_\").concat(Math.random());this.createEffect(effectId,character.position,((_event$event$data2=event.event.data)===null||_event$event$data2===void 0?void 0:_event$event$data2.actor)||'blast');}handleDealDamage(event){var _event$event$data3;// This would integrate with the game's damage system\nconsole.log(\"Damage: \".concat((_event$event$data3=event.event.data)===null||_event$event$data3===void 0?void 0:_event$event$data3.amount,\" from \").concat(event.characterId));}handleCameraShake(event){var _event$event$data4,_event$event$data5;// This would integrate with the camera system\nconsole.log(\"Camera Shake: \".concat((_event$event$data4=event.event.data)===null||_event$event$data4===void 0?void 0:_event$event$data4.intensity,\" for \").concat((_event$event$data5=event.event.data)===null||_event$event$data5===void 0?void 0:_event$event$data5.duration,\"ms\"));}handleAnimationComplete(event){const character=this.state.characters.get(event.characterId);if(!character)return;// Return to idle or handle completion logic\nif(character.currentAnimation!=='idle'){this.playAnimation(event.characterId,'idle');}}// === PUBLIC API ===\nstart(){this.isRunning=true;this.lastUpdateTime=performance.now();}stop(){this.isRunning=false;}getState(){return _objectSpread(_objectSpread({},this.state),{},{characters:new Map(this.state.characters),projectiles:new Map(this.state.projectiles),effects:new Map(this.state.effects)});}// Get character by ID\ngetCharacter(id){return this.state.characters.get(id);}// Get all characters\ngetCharacters(){return Array.from(this.state.characters.values());}// Get all projectiles\ngetProjectiles(){return Array.from(this.state.projectiles.values());}// Get all effects\ngetEffects(){return Array.from(this.state.effects.values());}}","map":{"version":3,"names":["ANIMATION_REGISTRY","ANIMATION_CONFIG","getFrameEvents","getCharacterDefinition","AnimationEngine","constructor","state","eventQueue","lastUpdateTime","isRunning","characters","Map","projectiles","effects","globalTime","lastUpdate","update","currentTime","start","deltaTime","fixedTimestep","fixedUpdate","updateDirect","steps","Math","floor","i","updateCharacters","updateProjectiles","updateEffects","processAnimationEvents","createCharacter","id","position","facing","arguments","length","undefined","character","_objectSpread","currentAnimation","animationFrame","animationTime","set","playAnimation","characterId","animationName","get","animationData","forEach","updateCharacterAnimation","frameTime","fps","newFrame","oldFrame","processFrameEvents","frames","loop","enqueueAnimationEvent","frame","type","data","createProjectile","velocity","owner","damage","knockback","x","y","hitstun","projectile","speed","sqrt","maxLifetime","lifetime","updateProjectile","destroyProjectile","checkProjectileCollisions","distance","pow","hitCharacter","blastId","concat","Date","now","random","createEffect","projectileId","setTimeout","delete","forceDestroyProjectile","effect","events","event","animationEvent","timestamp","push","shift","handleAnimationEvent","handleSpawnProjectile","handlePlaySfx","handleEmitFx","handleDealDamage","handleCameraShake","handleAnimationComplete","characterDef","muzzleOffset","facingMultiplier","projectilePosition","_event$event$data","console","log","sound","_event$event$data2","effectId","actor","_event$event$data3","amount","_event$event$data4","_event$event$data5","intensity","duration","performance","stop","getState","getCharacter","getCharacters","Array","from","values","getProjectiles","getEffects"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/engine/animationEngine.ts"],"sourcesContent":["// Animation Engine - Fixed-Timestep Event-basiertes System\r\n// Integriert mit bestehender Game-Engine Event-Queue\r\n\r\nimport type {\r\n  AnimationSystemState,\r\n  CharacterState,\r\n  ProjectileState,\r\n  AnimationEvent,\r\n  Vector2,\r\n  FrameEvent\r\n} from '../types/animation';\r\nimport {\r\n  ANIMATION_REGISTRY,\r\n  ANIMATION_CONFIG,\r\n  getFrameEvents,\r\n  getFrameHitboxes,\r\n  getCharacterDefinition\r\n} from '../data/animationRegistry';\r\n\r\nexport class AnimationEngine {\r\n  private state: AnimationSystemState;\r\n  private eventQueue: AnimationEvent[] = [];\r\n  private lastUpdateTime: number = 0;\r\n  private isRunning: boolean = false;\r\n\r\n  constructor() {\r\n    this.state = {\r\n      characters: new Map(),\r\n      projectiles: new Map(),\r\n      effects: new Map(),\r\n      globalTime: 0,\r\n      lastUpdate: 0\r\n    };\r\n  }\r\n\r\n  // === CORE UPDATE LOOP ===\r\n\r\n  update(currentTime: number): void {\r\n    // Auto-start if not running\r\n    if (!this.isRunning) {\r\n      this.start();\r\n    }\r\n\r\n    // Fixed-Timestep Update\r\n    const deltaTime = currentTime - this.lastUpdateTime;\r\n    if (deltaTime >= ANIMATION_CONFIG.fixedTimestep) {\r\n      this.fixedUpdate();\r\n      this.lastUpdateTime = currentTime;\r\n    }\r\n  }\r\n\r\n  // Alternative update method for testing\r\n  updateDirect(deltaTime: number): void {\r\n    // Simulate multiple fixed timesteps\r\n    const steps = Math.floor(deltaTime / ANIMATION_CONFIG.fixedTimestep);\r\n    for (let i = 0; i < steps; i++) {\r\n      this.fixedUpdate();\r\n    }\r\n  }\r\n\r\n  private fixedUpdate(): void {\r\n    this.state.globalTime += ANIMATION_CONFIG.fixedTimestep;\r\n\r\n    // Update Characters\r\n    this.updateCharacters();\r\n\r\n    // Update Projectiles\r\n    this.updateProjectiles();\r\n\r\n    // Update Effects\r\n    this.updateEffects();\r\n\r\n    // Process Animation Events\r\n    this.processAnimationEvents();\r\n  }\r\n\r\n  // === CHARACTER MANAGEMENT ===\r\n\r\n  createCharacter(id: string, position: Vector2, facing: -1 | 1 = 1): void {\r\n    const character: CharacterState = {\r\n      id,\r\n      position: { ...position },\r\n      facing,\r\n      currentAnimation: 'idle',\r\n      animationFrame: 0,\r\n      animationTime: 0\r\n    };\r\n\r\n    this.state.characters.set(id, character);\r\n  }\r\n\r\n  playAnimation(characterId: string, animationName: string): boolean {\r\n    const character = this.state.characters.get(characterId);\r\n    if (!character) return false;\r\n\r\n    const animationData = ANIMATION_REGISTRY[animationName];\r\n    if (!animationData) return false;\r\n\r\n    // Reset animation state\r\n    character.currentAnimation = animationName;\r\n    character.animationFrame = 0;\r\n    character.animationTime = 0;\r\n\r\n    return true;\r\n  }\r\n\r\n  private updateCharacters(): void {\r\n    this.state.characters.forEach((character, id) => {\r\n      this.updateCharacterAnimation(character);\r\n    });\r\n  }\r\n\r\n  private updateCharacterAnimation(character: CharacterState): void {\r\n    const animationData = ANIMATION_REGISTRY[character.currentAnimation];\r\n    if (!animationData) return;\r\n\r\n    // Calculate frame time\r\n    const frameTime = 1000 / animationData.fps;\r\n    const newFrame = Math.floor(character.animationTime / frameTime);\r\n\r\n    // Check for frame change\r\n    if (newFrame !== character.animationFrame) {\r\n      const oldFrame = character.animationFrame;\r\n      character.animationFrame = newFrame;\r\n\r\n      // Process frame events\r\n      this.processFrameEvents(character, oldFrame, newFrame);\r\n    }\r\n\r\n    // Handle animation completion\r\n    if (character.animationFrame >= animationData.frames) {\r\n      if (animationData.loop) {\r\n        character.animationFrame = 0;\r\n        character.animationTime = 0;\r\n      } else {\r\n        // Animation complete - fire complete event\r\n        this.enqueueAnimationEvent(character.id, {\r\n          frame: animationData.frames - 1,\r\n          type: 'complete',\r\n          data: {}\r\n        });\r\n      }\r\n    }\r\n\r\n    // Update animation time\r\n    character.animationTime += ANIMATION_CONFIG.fixedTimestep;\r\n  }\r\n\r\n  // === PROJECTILE MANAGEMENT ===\r\n\r\n  createProjectile(\r\n    id: string,\r\n    position: Vector2,\r\n    velocity: Vector2,\r\n    owner: string,\r\n    damage: number = 15,\r\n    knockback: Vector2 = { x: 30, y: -15 },\r\n    hitstun: number = 200\r\n  ): void {\r\n    const projectile: ProjectileState = {\r\n      id,\r\n      position: { ...position },\r\n      facing: velocity.x > 0 ? 1 : -1,\r\n      currentAnimation: 'projectile',\r\n      animationFrame: 0,\r\n      animationTime: 0,\r\n      velocity: { ...velocity },\r\n      speed: Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y),\r\n      maxLifetime: 1200, // 1.2s fail-safe\r\n      lifetime: 0,\r\n      damage,\r\n      knockback,\r\n      hitstun,\r\n      owner\r\n    };\r\n\r\n    this.state.projectiles.set(id, projectile);\r\n  }\r\n\r\n  private updateProjectiles(): void {\r\n    this.state.projectiles.forEach((projectile, id) => {\r\n      this.updateProjectile(projectile);\r\n    });\r\n  }\r\n\r\n  private updateProjectile(projectile: ProjectileState): void {\r\n    // Update position\r\n    if (projectile.velocity) {\r\n      projectile.position.x += projectile.velocity.x * (ANIMATION_CONFIG.fixedTimestep / 1000);\r\n      projectile.position.y += projectile.velocity.y * (ANIMATION_CONFIG.fixedTimestep / 1000);\r\n    }\r\n\r\n    // Update lifetime\r\n    projectile.lifetime += ANIMATION_CONFIG.fixedTimestep;\r\n\r\n    // Check lifetime\r\n    if (projectile.lifetime >= projectile.maxLifetime) {\r\n      this.destroyProjectile(projectile.id);\r\n      return;\r\n    }\r\n\r\n    // Update animation\r\n    this.updateCharacterAnimation(projectile);\r\n\r\n    // Check collisions\r\n    this.checkProjectileCollisions(projectile);\r\n  }\r\n\r\n  private checkProjectileCollisions(projectile: ProjectileState): void {\r\n    // Check against all characters (except owner)\r\n    this.state.characters.forEach((character, characterId) => {\r\n      if (characterId === projectile.owner) return;\r\n\r\n      // Simple collision check (can be expanded with proper hitbox system)\r\n      const distance = Math.sqrt(\r\n        Math.pow(projectile.position.x - character.position.x, 2) +\r\n        Math.pow(projectile.position.y - character.position.y, 2)\r\n      );\r\n\r\n      if (distance < 50) { // Simple radius collision\r\n        this.hitCharacter(characterId, projectile);\r\n        this.destroyProjectile(projectile.id);\r\n        return;\r\n      }\r\n    });\r\n  }\r\n\r\n  private hitCharacter(characterId: string, projectile: ProjectileState): void {\r\n    // Create blast effect at hit position\r\n    const blastId = `blast_${Date.now()}_${Math.random()}`;\r\n    this.createEffect(blastId, projectile.position, 'blast');\r\n  }\r\n\r\n  private destroyProjectile(projectileId: string): void {\r\n    const projectile = this.state.projectiles.get(projectileId);\r\n    if (!projectile) return;\r\n\r\n    // Switch to die animation briefly\r\n    projectile.currentAnimation = 'die';\r\n    projectile.animationFrame = 0;\r\n    projectile.animationTime = 0;\r\n\r\n    // Remove after die animation completes\r\n    setTimeout(() => {\r\n      this.state.projectiles.delete(projectileId);\r\n    }, 150); // 3 frames at 20fps\r\n  }\r\n\r\n  // Test helper method to force destroy projectile\r\n  public forceDestroyProjectile(projectileId: string): void {\r\n    this.state.projectiles.delete(projectileId);\r\n  }\r\n\r\n  // === EFFECT MANAGEMENT ===\r\n\r\n  createEffect(id: string, position: Vector2, animationName: string): void {\r\n    const effect: CharacterState = {\r\n      id,\r\n      position: { ...position },\r\n      facing: 1,\r\n      currentAnimation: animationName,\r\n      animationFrame: 0,\r\n      animationTime: 0\r\n    };\r\n\r\n    this.state.effects.set(id, effect);\r\n  }\r\n\r\n  private updateEffects(): void {\r\n    this.state.effects.forEach((effect, id) => {\r\n      this.updateCharacterAnimation(effect);\r\n    });\r\n  }\r\n\r\n  // === EVENT PROCESSING ===\r\n\r\n  private processFrameEvents(character: CharacterState, oldFrame: number, newFrame: number): void {\r\n    const animationData = ANIMATION_REGISTRY[character.currentAnimation];\r\n    if (!animationData || !animationData.events) return;\r\n\r\n    // Process events for all frames between oldFrame and newFrame\r\n    for (let frame = oldFrame + 1; frame <= newFrame; frame++) {\r\n      const events = getFrameEvents(character.currentAnimation, frame);\r\n      for (const event of events) {\r\n        this.enqueueAnimationEvent(character.id, event);\r\n      }\r\n    }\r\n  }\r\n\r\n  private enqueueAnimationEvent(characterId: string, event: FrameEvent): void {\r\n    const animationEvent: AnimationEvent = {\r\n      type: 'ANIMATION_EVENT',\r\n      characterId,\r\n      event,\r\n      timestamp: this.state.globalTime\r\n    };\r\n\r\n    this.eventQueue.push(animationEvent);\r\n  }\r\n\r\n  private processAnimationEvents(): void {\r\n    while (this.eventQueue.length > 0) {\r\n      const event = this.eventQueue.shift()!;\r\n      this.handleAnimationEvent(event);\r\n    }\r\n  }\r\n\r\n  private handleAnimationEvent(event: AnimationEvent): void {\r\n    switch (event.event.type) {\r\n      case 'spawnProjectile':\r\n        this.handleSpawnProjectile(event);\r\n        break;\r\n      case 'playSfx':\r\n        this.handlePlaySfx(event);\r\n        break;\r\n      case 'emitFx':\r\n        this.handleEmitFx(event);\r\n        break;\r\n      case 'dealDamage':\r\n        this.handleDealDamage(event);\r\n        break;\r\n      case 'cameraShake':\r\n        this.handleCameraShake(event);\r\n        break;\r\n      case 'complete':\r\n        this.handleAnimationComplete(event);\r\n        break;\r\n    }\r\n  }\r\n\r\n  private handleSpawnProjectile(event: AnimationEvent): void {\r\n    const character = this.state.characters.get(event.characterId);\r\n    if (!character) return;\r\n\r\n    const characterDef = getCharacterDefinition(character.id);\r\n    if (!characterDef || !characterDef.muzzleOffset) return;\r\n\r\n    // Calculate muzzle position\r\n    const muzzleOffset = characterDef.muzzleOffset;\r\n    const facingMultiplier = character.facing;\r\n\r\n    const projectilePosition: Vector2 = {\r\n      x: character.position.x + (muzzleOffset.x * facingMultiplier),\r\n      y: character.position.y + muzzleOffset.y\r\n    };\r\n\r\n    // Calculate velocity\r\n    const speed = 1000; // px/s\r\n    const velocity: Vector2 = {\r\n      x: speed * facingMultiplier,\r\n      y: 0\r\n    };\r\n\r\n    // Create projectile\r\n    const projectileId = `projectile_${Date.now()}_${Math.random()}`;\r\n    this.createProjectile(projectileId, projectilePosition, velocity, character.id);\r\n  }\r\n\r\n  private handlePlaySfx(event: AnimationEvent): void {\r\n    // Integrate with existing audio system\r\n    console.log(`SFX: ${event.event.data?.sound} for ${event.characterId}`);\r\n  }\r\n\r\n  private handleEmitFx(event: AnimationEvent): void {\r\n    const character = this.state.characters.get(event.characterId);\r\n    if (!character) return;\r\n\r\n    const effectId = `fx_${Date.now()}_${Math.random()}`;\r\n    this.createEffect(effectId, character.position, event.event.data?.actor || 'blast');\r\n  }\r\n\r\n  private handleDealDamage(event: AnimationEvent): void {\r\n    // This would integrate with the game's damage system\r\n    console.log(`Damage: ${event.event.data?.amount} from ${event.characterId}`);\r\n  }\r\n\r\n  private handleCameraShake(event: AnimationEvent): void {\r\n    // This would integrate with the camera system\r\n    console.log(`Camera Shake: ${event.event.data?.intensity} for ${event.event.data?.duration}ms`);\r\n  }\r\n\r\n  private handleAnimationComplete(event: AnimationEvent): void {\r\n    const character = this.state.characters.get(event.characterId);\r\n    if (!character) return;\r\n\r\n    // Return to idle or handle completion logic\r\n    if (character.currentAnimation !== 'idle') {\r\n      this.playAnimation(event.characterId, 'idle');\r\n    }\r\n  }\r\n\r\n  // === PUBLIC API ===\r\n\r\n  start(): void {\r\n    this.isRunning = true;\r\n    this.lastUpdateTime = performance.now();\r\n  }\r\n\r\n  stop(): void {\r\n    this.isRunning = false;\r\n  }\r\n\r\n  getState(): AnimationSystemState {\r\n    return {\r\n      ...this.state,\r\n      characters: new Map(this.state.characters),\r\n      projectiles: new Map(this.state.projectiles),\r\n      effects: new Map(this.state.effects)\r\n    };\r\n  }\r\n\r\n  // Get character by ID\r\n  getCharacter(id: string): CharacterState | undefined {\r\n    return this.state.characters.get(id);\r\n  }\r\n\r\n  // Get all characters\r\n  getCharacters(): CharacterState[] {\r\n    return Array.from(this.state.characters.values());\r\n  }\r\n\r\n  // Get all projectiles\r\n  getProjectiles(): ProjectileState[] {\r\n    return Array.from(this.state.projectiles.values());\r\n  }\r\n\r\n  // Get all effects\r\n  getEffects(): CharacterState[] {\r\n    return Array.from(this.state.effects.values());\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}