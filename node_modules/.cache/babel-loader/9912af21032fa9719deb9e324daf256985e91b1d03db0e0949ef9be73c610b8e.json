{"ast":null,"code":"import { SpriteAnimator } from \"./spriteAnimator\";\nimport { P1_PROJECTILE_SRC, P2_PROJECTILE_SRC } from \"./assetRegistry\";\nexport class Projectile {\n  constructor(x, y, vx, vy, owner, imgSrc, framesHint, atlasImage = null, atlasRects = null) {\n    var _a$rects$length, _a$rects;\n    this.x = void 0;\n    this.y = void 0;\n    this.vx = void 0;\n    this.vy = void 0;\n    this.alive = true;\n    this.age = 0;\n    this.lifespan = 1.0;\n    this.owner = void 0;\n    this.anim = void 0;\n    this.displayW = 256;\n    this.displayH = 256;\n    this.x = x;\n    this.y = y;\n    this.vx = vx;\n    this.vy = vy;\n    this.owner = owner;\n    const animationDef = {\n      src: imgSrc,\n      frames: framesHint,\n      fps: 12,\n      loop: true,\n      frameW: 256,\n      frameH: 256\n    };\n    if (atlasImage && atlasRects) {\n      animationDef.image = atlasImage;\n      animationDef.rects = atlasRects;\n      animationDef.frames = atlasRects.length;\n      animationDef.imageLoaded = true;\n      animationDef.imageBroken = false;\n    }\n    this.anim = new SpriteAnimator(atlasImage, 256, 256, {\n      fly: animationDef\n    });\n    this.anim.setState(\"fly\");\n    // Simplified debug for fly animation\n    const a = this.anim.animations[\"fly\"];\n    // eslint-disable-next-line no-console\n    console.debug(\"[qte] projectile fly\", {\n      frames: (_a$rects$length = a === null || a === void 0 ? void 0 : (_a$rects = a.rects) === null || _a$rects === void 0 ? void 0 : _a$rects.length) !== null && _a$rects$length !== void 0 ? _a$rects$length : a === null || a === void 0 ? void 0 : a.frames,\n      hasRects: !!(a !== null && a !== void 0 && a.rects)\n    });\n  }\n  update(dt) {\n    this.age += dt;\n    this.x += this.vx * dt;\n    this.y += this.vy * dt;\n    this.anim.update(dt);\n    if (this.age >= this.lifespan) this.alive = false;\n  }\n  draw(ctx) {\n    ctx.save();\n    const alpha = Math.max(0, 1 - this.age / this.lifespan);\n    ctx.globalAlpha = alpha;\n    // Debug image load state if available\n    const a = this.anim.animations[\"fly\"];\n    // eslint-disable-next-line no-console\n    if (a && a.image && !a.image.complete) console.debug(\"[qte] projectile image not complete\", {\n      src: a.src,\n      complete: a.image.complete,\n      broken: a.imageBroken\n    });\n    this.anim.draw(ctx, this.x, this.y, this.displayW, this.displayH, this.vx < 0);\n    ctx.restore();\n    ctx.globalAlpha = 1;\n  }\n  rect() {\n    return {\n      x: this.x,\n      y: this.y,\n      w: this.displayW,\n      h: this.displayH\n    };\n  }\n}\nexport class Blast {\n  constructor(x, y, imgSrc, framesHint, atlasImage = null, atlasRects = null) {\n    this.x = void 0;\n    this.y = void 0;\n    this.alive = true;\n    this.timer = void 0;\n    this.anim = void 0;\n    this.w = 256;\n    this.h = 256;\n    this.x = x;\n    this.y = y;\n    this.timer = framesHint / 12;\n    const animationDef = {\n      src: imgSrc,\n      frames: framesHint,\n      fps: 12,\n      loop: false,\n      frameW: 256,\n      frameH: 256\n    };\n    if (atlasImage && atlasRects) {\n      animationDef.image = atlasImage;\n      animationDef.rects = atlasRects;\n      animationDef.frames = atlasRects.length;\n      animationDef.imageLoaded = true;\n      animationDef.imageBroken = false;\n    }\n    this.anim = new SpriteAnimator(atlasImage, 256, 256, {\n      boom: animationDef\n    });\n    this.anim.setState(\"boom\");\n  }\n  update(dt) {\n    this.timer -= dt;\n    this.anim.update(dt);\n    if (this.timer <= 0) this.alive = false;\n  }\n  draw(ctx) {\n    this.anim.draw(ctx, this.x - this.w * 0.5, this.y - this.h * 0.5, this.w, this.h);\n  }\n}\nexport class Fighter {\n  constructor(opts) {\n    var _opts$muzzleOffset;\n    this.ctx = void 0;\n    this.canvasW = void 0;\n    this.canvasH = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.w = 256;\n    this.h = 256;\n    this.vx = 0;\n    this.vy = 0;\n    this.facing = 1;\n    this.hp = 100;\n    this.onGround = false;\n    this.state = \"idle\";\n    this.name = void 0;\n    this.color = void 0;\n    this.keys = void 0;\n    this.anim = void 0;\n    // action flags\n    this.attacking = false;\n    this.parrying = false;\n    this.ranging = false;\n    this.attackLaunched = false;\n    this.rangedLaunched = false;\n    this.muzzleOffset = void 0;\n    // timers\n    this.attackTimer = 0;\n    this.rangedTimer = 0;\n    this.parryTimer = 0;\n    this.parryFreezeTimer = 0;\n    this.stunTimer = 0;\n    this.parryConsumed = false;\n    this.parryDurationDefault = 0.4;\n    this.parryWindowLength = this.parryDurationDefault * 0.25;\n    this.stunned = false;\n    this.x = opts.x;\n    this.y = opts.y;\n    this.color = opts.color;\n    this.keys = opts.keys;\n    this.name = opts.name;\n    this.ctx = opts.ctx;\n    this.canvasW = opts.canvasWidth;\n    this.canvasH = opts.canvasHeight;\n    this.muzzleOffset = (_opts$muzzleOffset = opts.muzzleOffset) !== null && _opts$muzzleOffset !== void 0 ? _opts$muzzleOffset : {\n      x: 36,\n      y: -48\n    };\n    const img = new Image();\n    img.src = opts.spriteConfig.animations.idle.src;\n    this.anim = new SpriteAnimator(img, opts.spriteConfig.frameW, opts.spriteConfig.frameH, opts.spriteConfig.animations);\n    this.anim.setState(\"idle\");\n  }\n  rect() {\n    return {\n      x: this.x,\n      y: this.y,\n      w: this.w,\n      h: this.h\n    };\n  }\n  hitbox() {\n    if (this.state === \"attack\") {\n      const aw = 60,\n        ah = 40;\n      const ax = this.facing > 0 ? this.x + this.w - 10 : this.x - (aw - 10);\n      const ay = this.y + this.h * 0.55 - ah * 0.5;\n      return {\n        x: ax,\n        y: ay,\n        w: aw,\n        h: ah\n      };\n    }\n    return null;\n  }\n  update(dt, input, projectiles) {\n    // Movement & gravity\n    if (input[this.keys.left]) {\n      this.vx = -150;\n      this.facing = -1;\n    } else if (input[this.keys.right]) {\n      this.vx = 150;\n      this.facing = 1;\n    } else this.vx = 0;\n    if (this.onGround && input[this.keys.up]) {\n      this.vy = -350;\n      this.onGround = false;\n    }\n    this.vy += 900 * dt;\n    this.x += this.vx * dt;\n    this.y += this.vy * dt;\n\n    // ground collision\n    if (this.y + this.h >= this.canvasH - 40) {\n      this.y = this.canvasH - 40 - this.h;\n      this.vy = 0;\n      this.onGround = true;\n    }\n\n    // Attack input\n    if (input[this.keys.attack] && !this.attacking) {\n      this.attacking = true;\n      this.state = \"attack\";\n      this.anim.setState(\"attack\");\n      this.attackTimer = 0.35;\n    }\n    if (this.attacking) {\n      this.attackTimer -= dt;\n      if (this.attackTimer <= 0) this.attacking = false;\n    }\n\n    // Ranged input\n    if (input[this.keys.ranged] && !this.ranging) {\n      this.ranging = true;\n      this.state = \"ranged\";\n      this.anim.setState(\"ranged\");\n      this.rangedTimer = 0.4;\n      this.rangedLaunched = false;\n    }\n    if (this.ranging) {\n      this.rangedTimer -= dt;\n      if (!this.rangedLaunched && this.anim.state === \"ranged\" && this.anim.frame === this.anim.animations[\"ranged\"].frames - 1) {\n        this.rangedLaunched = true;\n        // spawn point (muzzle) – use configured muzzleOffset (mirrored by facing)\n        const projW = 256,\n          projH = 256;\n        const muzzle = this.muzzleOffset || {\n          x: 36,\n          y: -48\n        };\n        const centerX = this.x + this.w * 0.5 + muzzle.x * this.facing;\n        const centerY = this.y + this.h * 0.5 + muzzle.y;\n        const startX = Math.round(centerX - projW * 0.5);\n        const startY = Math.round(centerY - projH * 0.5);\n        const speed = 600;\n        const vx = this.facing > 0 ? speed : -speed;\n        const imgSrc = this.name === \"P1\" ? P1_PROJECTILE_SRC : P2_PROJECTILE_SRC;\n        // Use atlas for projectile if available\n        let projectileImage = null;\n        let projectileRects = null;\n        let projectileFrames = 6;\n\n        // Try to get atlas from owner's animator (will be set after atlas loads)\n        if (this.anim && this.anim.animations.projectile && this.anim.animations.projectile.rects) {\n          projectileImage = this.anim.animations.projectile.image;\n          projectileRects = this.anim.animations.projectile.rects;\n          projectileFrames = this.anim.animations.projectile.rects.length;\n          console.log(`[qte] Projectile using atlas frames from ${this.name}`);\n        } else {\n          console.log(`[qte] Projectile: No atlas frames for 'projectile' in ${this.name}, falling back to individual image.`);\n          // If atlas isn't available yet, at least pass the already-preloaded per-animation image\n          if (this.anim && this.anim.animations.projectile && this.anim.animations.projectile.image) {\n            projectileImage = this.anim.animations.projectile.image;\n            console.log(`[qte] Projectile: using per-animation image for ${this.name}`);\n          }\n        }\n        const proj = new Projectile(startX, startY, vx, 0, this, imgSrc, projectileFrames, projectileImage, projectileRects);\n        // Debug log projectile spawn\n        // eslint-disable-next-line no-console\n        console.debug(\"[qte] spawnProjectile\", {\n          owner: this.name,\n          startX,\n          startY,\n          imgSrc,\n          facing: this.facing\n        });\n        const distanceToEdge = this.facing > 0 ? this.canvasW - startX : startX;\n        proj.lifespan = Math.min(1.2, Math.abs(distanceToEdge / speed));\n        projectiles.push(proj);\n      }\n      if (this.rangedTimer <= 0) this.ranging = false;\n    }\n\n    // State machine fallbacks\n    if (!this.attacking && !this.ranging) {\n      if (!this.onGround) this.setState(\"jump\");else if (Math.abs(this.vx) > 1) this.setState(\"walk\");else this.setState(\"idle\");\n    }\n\n    // animator update\n    this.anim.update(dt);\n  }\n  draw() {\n    this.anim.draw(this.ctx, this.x, this.y, this.w, this.h, this.facing < 0);\n  }\n  setState(s) {\n    if (this.state === s) return;\n    this.state = s;\n    this.anim.setState(s);\n  }\n}","map":{"version":3,"names":["SpriteAnimator","P1_PROJECTILE_SRC","P2_PROJECTILE_SRC","Projectile","constructor","x","y","vx","vy","owner","imgSrc","framesHint","atlasImage","atlasRects","_a$rects$length","_a$rects","alive","age","lifespan","anim","displayW","displayH","animationDef","src","frames","fps","loop","frameW","frameH","image","rects","length","imageLoaded","imageBroken","fly","setState","a","animations","console","debug","hasRects","update","dt","draw","ctx","save","alpha","Math","max","globalAlpha","complete","broken","restore","rect","w","h","Blast","timer","boom","Fighter","opts","_opts$muzzleOffset","canvasW","canvasH","facing","hp","onGround","state","name","color","keys","attacking","parrying","ranging","attackLaunched","rangedLaunched","muzzleOffset","attackTimer","rangedTimer","parryTimer","parryFreezeTimer","stunTimer","parryConsumed","parryDurationDefault","parryWindowLength","stunned","canvasWidth","canvasHeight","img","Image","spriteConfig","idle","hitbox","aw","ah","ax","ay","input","projectiles","left","right","up","attack","ranged","frame","projW","projH","muzzle","centerX","centerY","startX","round","startY","speed","projectileImage","projectileRects","projectileFrames","projectile","log","proj","distanceToEdge","min","abs","push","s"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/qte/fighter.ts"],"sourcesContent":["import { SpriteAnimator } from \"./spriteAnimator\";\nimport {\n  P1_PROJECTILE_SRC,\n  P2_PROJECTILE_SRC,\n  P1_BLAST_SRC,\n  P2_BLAST_SRC,\n} from \"./assetRegistry\";\n\nexport interface Rect {\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n}\n\nexport interface FighterOptions {\n  x: number;\n  y: number;\n  color: string;\n  keys: Record<string, string>; // keycodes mapping\n  name: string;\n  spriteConfig: { frameW: number; frameH: number; animations: any };\n  ctx: CanvasRenderingContext2D;\n  canvasWidth: number;\n  canvasHeight: number;\n  muzzleOffset?: { x: number; y: number };\n}\n\nexport class Projectile {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  alive = true;\n  age = 0;\n  lifespan = 1.0;\n  owner: Fighter;\n  anim: SpriteAnimator;\n  displayW = 256;\n  displayH = 256;\n\n  constructor(\n    x: number,\n    y: number,\n    vx: number,\n    vy: number,\n    owner: Fighter,\n    imgSrc: string,\n    framesHint: number,\n    atlasImage: HTMLImageElement | null = null,\n    atlasRects: Rect[] | null = null\n  ) {\n    this.x = x;\n    this.y = y;\n    this.vx = vx;\n    this.vy = vy;\n    this.owner = owner;\n    const animationDef: any = {\n      src: imgSrc,\n      frames: framesHint,\n      fps: 12,\n      loop: true,\n      frameW: 256,\n      frameH: 256,\n    };\n\n    if (atlasImage && atlasRects) {\n      animationDef.image = atlasImage;\n      animationDef.rects = atlasRects;\n      animationDef.frames = atlasRects.length;\n      animationDef.imageLoaded = true;\n      animationDef.imageBroken = false;\n    }\n\n    this.anim = new SpriteAnimator(atlasImage, 256, 256, {\n      fly: animationDef,\n    });\n    this.anim.setState(\"fly\");\n    // Simplified debug for fly animation\n    const a = this.anim.animations[\"fly\"];\n    // eslint-disable-next-line no-console\n    console.debug(\"[qte] projectile fly\", { frames: a?.rects?.length ?? a?.frames, hasRects: !!a?.rects });\n  }\n\n  update(dt: number) {\n    this.age += dt;\n    this.x += this.vx * dt;\n    this.y += this.vy * dt;\n    this.anim.update(dt);\n    if (this.age >= this.lifespan) this.alive = false;\n  }\n  draw(ctx: CanvasRenderingContext2D) {\n    ctx.save();\n    const alpha = Math.max(0, 1 - this.age / this.lifespan);\n    ctx.globalAlpha = alpha;\n    // Debug image load state if available\n    const a = this.anim.animations[\"fly\"];\n    // eslint-disable-next-line no-console\n    if (a && a.image && !a.image.complete) console.debug(\"[qte] projectile image not complete\", { src: a.src, complete: a.image.complete, broken: a.imageBroken });\n    this.anim.draw(ctx, this.x, this.y, this.displayW, this.displayH, this.vx < 0);\n    ctx.restore();\n    ctx.globalAlpha = 1;\n  }\n  rect(): Rect {\n    return { x: this.x, y: this.y, w: this.displayW, h: this.displayH };\n  }\n}\n\nexport class Blast {\n  x: number;\n  y: number;\n  alive = true;\n  timer: number;\n  anim: SpriteAnimator;\n  w = 256;\n  h = 256;\n  constructor(x: number, y: number, imgSrc: string, framesHint: number, atlasImage: HTMLImageElement | null = null, atlasRects: Rect[] | null = null) {\n    this.x = x;\n    this.y = y;\n    this.timer = framesHint / 12;\n\n    const animationDef: any = {\n      src: imgSrc,\n      frames: framesHint,\n      fps: 12,\n      loop: false,\n      frameW: 256,\n      frameH: 256,\n    };\n\n    if (atlasImage && atlasRects) {\n      animationDef.image = atlasImage;\n      animationDef.rects = atlasRects;\n      animationDef.frames = atlasRects.length;\n      animationDef.imageLoaded = true;\n      animationDef.imageBroken = false;\n    }\n\n    this.anim = new SpriteAnimator(atlasImage, 256, 256, {\n      boom: animationDef,\n    });\n    this.anim.setState(\"boom\");\n  }\n  update(dt: number) {\n    this.timer -= dt;\n    this.anim.update(dt);\n    if (this.timer <= 0) this.alive = false;\n  }\n  draw(ctx: CanvasRenderingContext2D) {\n    this.anim.draw(ctx, this.x - this.w * 0.5, this.y - this.h * 0.5, this.w, this.h);\n  }\n}\n\nexport class Fighter {\n  private ctx: CanvasRenderingContext2D;\n  private canvasW: number;\n  private canvasH: number;\n\n  x: number;\n  y: number;\n  w = 256;\n  h = 256;\n  vx = 0;\n  vy = 0;\n  facing = 1;\n  hp = 100;\n  onGround = false;\n\n  state: string = \"idle\";\n  name: string;\n  color: string;\n  keys: Record<string, string>;\n  anim: SpriteAnimator;\n\n  // action flags\n  attacking = false;\n  parrying = false;\n  ranging = false;\n  attackLaunched = false;\n  rangedLaunched = false;\n  muzzleOffset: { x: number; y: number };\n\n  // timers\n  attackTimer = 0;\n  rangedTimer = 0;\n  parryTimer = 0;\n  parryFreezeTimer = 0;\n  stunTimer = 0;\n  parryConsumed = false;\n  parryDurationDefault = 0.4;\n  parryWindowLength = this.parryDurationDefault * 0.25;\n  stunned = false;\n\n  constructor(opts: FighterOptions) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.color = opts.color;\n    this.keys = opts.keys;\n    this.name = opts.name;\n    this.ctx = opts.ctx;\n    this.canvasW = opts.canvasWidth;\n    this.canvasH = opts.canvasHeight;\n    this.muzzleOffset = opts.muzzleOffset ?? { x: 36, y: -48 };\n\n    const img = new Image();\n    img.src = opts.spriteConfig.animations.idle.src;\n    this.anim = new SpriteAnimator(img, opts.spriteConfig.frameW, opts.spriteConfig.frameH, opts.spriteConfig.animations);\n    this.anim.setState(\"idle\");\n  }\n\n  rect(): Rect {\n    return { x: this.x, y: this.y, w: this.w, h: this.h };\n  }\n\n  hitbox(): Rect | null {\n    if (this.state === \"attack\") {\n      const aw = 60,\n        ah = 40;\n      const ax = this.facing > 0 ? this.x + this.w - 10 : this.x - (aw - 10);\n      const ay = this.y + this.h * 0.55 - ah * 0.5;\n      return { x: ax, y: ay, w: aw, h: ah };\n    }\n    return null;\n  }\n\n  update(dt: number, input: Record<string, boolean>, projectiles: Projectile[]) {\n    // Movement & gravity\n    if (input[this.keys.left]) {\n      this.vx = -150;\n      this.facing = -1;\n    } else if (input[this.keys.right]) {\n      this.vx = 150;\n      this.facing = 1;\n    } else this.vx = 0;\n    if (this.onGround && input[this.keys.up]) {\n      this.vy = -350;\n      this.onGround = false;\n    }\n    this.vy += 900 * dt;\n    this.x += this.vx * dt;\n    this.y += this.vy * dt;\n\n    // ground collision\n    if (this.y + this.h >= this.canvasH - 40) {\n      this.y = this.canvasH - 40 - this.h;\n      this.vy = 0;\n      this.onGround = true;\n    }\n\n    // Attack input\n    if (input[this.keys.attack] && !this.attacking) {\n      this.attacking = true;\n      this.state = \"attack\";\n      this.anim.setState(\"attack\");\n      this.attackTimer = 0.35;\n    }\n    if (this.attacking) {\n      this.attackTimer -= dt;\n      if (this.attackTimer <= 0) this.attacking = false;\n    }\n\n    // Ranged input\n    if (input[this.keys.ranged] && !this.ranging) {\n      this.ranging = true;\n      this.state = \"ranged\";\n      this.anim.setState(\"ranged\");\n      this.rangedTimer = 0.4;\n      this.rangedLaunched = false;\n    }\n    if (this.ranging) {\n      this.rangedTimer -= dt;\n      if (!this.rangedLaunched && this.anim.state === \"ranged\" && this.anim.frame === this.anim.animations[\"ranged\"].frames - 1) {\n        this.rangedLaunched = true;\n        // spawn point (muzzle) – use configured muzzleOffset (mirrored by facing)\n        const projW = 256, projH = 256;\n        const muzzle = this.muzzleOffset || { x: 36, y: -48 };\n        const centerX = this.x + this.w * 0.5 + muzzle.x * this.facing;\n        const centerY = this.y + this.h * 0.5 + muzzle.y;\n        const startX = Math.round(centerX - projW * 0.5);\n        const startY = Math.round(centerY - projH * 0.5);\n        const speed = 600;\n        const vx = this.facing > 0 ? speed : -speed;\n        const imgSrc = this.name === \"P1\" ? P1_PROJECTILE_SRC : P2_PROJECTILE_SRC;\n        // Use atlas for projectile if available\n        let projectileImage = null;\n        let projectileRects = null;\n        let projectileFrames = 6;\n\n        // Try to get atlas from owner's animator (will be set after atlas loads)\n        if (this.anim && this.anim.animations.projectile && this.anim.animations.projectile.rects) {\n          projectileImage = this.anim.animations.projectile.image;\n          projectileRects = this.anim.animations.projectile.rects;\n          projectileFrames = this.anim.animations.projectile.rects.length;\n          console.log(`[qte] Projectile using atlas frames from ${this.name}`);\n        } else {\n          console.log(`[qte] Projectile: No atlas frames for 'projectile' in ${this.name}, falling back to individual image.`);\n          // If atlas isn't available yet, at least pass the already-preloaded per-animation image\n          if (this.anim && this.anim.animations.projectile && this.anim.animations.projectile.image) {\n            projectileImage = this.anim.animations.projectile.image;\n            console.log(`[qte] Projectile: using per-animation image for ${this.name}`);\n          }\n        }\n\n        const proj = new Projectile(startX, startY, vx, 0, this, imgSrc, projectileFrames, projectileImage, projectileRects);\n        // Debug log projectile spawn\n        // eslint-disable-next-line no-console\n        console.debug(\"[qte] spawnProjectile\", { owner: this.name, startX, startY, imgSrc, facing: this.facing });\n        const distanceToEdge = this.facing > 0 ? this.canvasW - startX : startX;\n        proj.lifespan = Math.min(1.2, Math.abs(distanceToEdge / speed));\n        projectiles.push(proj);\n      }\n      if (this.rangedTimer <= 0) this.ranging = false;\n    }\n\n    // State machine fallbacks\n    if (!this.attacking && !this.ranging) {\n      if (!this.onGround) this.setState(\"jump\");\n      else if (Math.abs(this.vx) > 1) this.setState(\"walk\");\n      else this.setState(\"idle\");\n    }\n\n    // animator update\n    this.anim.update(dt);\n  }\n\n  draw() {\n    this.anim.draw(this.ctx, this.x, this.y, this.w, this.h, this.facing < 0);\n  }\n\n  private setState(s: string) {\n    if (this.state === s) return;\n    this.state = s;\n    this.anim.setState(s);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}