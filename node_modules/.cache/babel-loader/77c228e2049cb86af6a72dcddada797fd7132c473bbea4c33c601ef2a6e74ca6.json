{"ast":null,"code":"// src/qte/atlasLoader.ts - simple runtime loader for TexturePacker JSON (ARRAY) format\n// The JSON layout we expect (TexturePacker \"JSON (Hash)\" or \"JSON (Array)\" works):\n// {\n//   \"frames\": {\n//      \"idle_0\": { \"frame\": {\"x\":0,\"y\":0,\"w\":256,\"h\":256}, ... },\n//      \"idle_1\": {...},\n//      \"walk_0\": {...}\n//   },\n//   \"meta\": { \"image\": \"atlas.png\" }\n// }\n// Each frame key is expected to be <state>_<index> (index starting at 0).\n// We group them into an array per state and keep the order of index.\n\nexport async function loadAtlas(basePath) {\n  // basePath may be a directory or a path to a JSON file (e.g. \"/qte/ninja\" or \"/qte/ninja/atlas2.json\")\n  const cacheBuster = Date.now();\n  const candidates = [];\n  if (basePath.match(/\\.json$/i)) {\n    candidates.push(basePath);\n  } else {\n    candidates.push(`${basePath}/atlas.json`);\n    candidates.push(`${basePath}.json`);\n    // allow explicit atlas2 naming (common in this project)\n    candidates.push(`${basePath}/atlas2.json`);\n    candidates.push(`${basePath}/atlas2`);\n  }\n  let text = null;\n  let usedJsonUrl = null;\n  const tried = [];\n  for (const cand of candidates) {\n    const url = `${cand}?v=${cacheBuster}`;\n    tried.push(url);\n    console.log(`[atlas] Trying ${url}`);\n    try {\n      const res = await fetch(url);\n      if (!res.ok) {\n        console.log(`[atlas] ${url} responded ${res.status}`);\n        continue;\n      }\n      const contentType = res.headers.get('content-type') || '';\n      const body = await res.text();\n      // If server returned HTML (e.g. index.html), skip and try next candidate\n      if (contentType.includes('text/html') || body.trim().startsWith('<!DOCTYPE')) {\n        console.warn(`[atlas] ${url} looks like HTML (skipping)`);\n        continue;\n      }\n      text = body;\n      usedJsonUrl = url.replace(/\\?v=\\d+$/, '');\n      console.log(`[atlas] Loaded JSON from ${url} (len=${text.length})`);\n      break;\n    } catch (e) {\n      console.warn(`[atlas] fetch failed for ${url}`, e);\n      continue;\n    }\n  }\n  if (!text || !usedJsonUrl) {\n    throw new Error(`Atlas JSON not found. Tried: ${tried.join(', ')}`);\n  }\n  console.log(`[atlas] JSON response length: ${text.length}, starts with: ${text.substring(0, 100)}`);\n  let data;\n  try {\n    data = JSON.parse(text);\n  } catch (e) {\n    console.error(`[atlas] JSON parse error:`, e);\n    console.error(`[atlas] Invalid JSON text:`, text.substring(0, 200));\n    throw e;\n  }\n  const framesData = data.frames;\n  const meta = data.meta || {};\n  // compute base directory from usedJsonUrl\n  const baseDir = usedJsonUrl.replace(/\\/[^/]*$/, '');\n  const imgPath = `${baseDir}/${meta.image || 'atlas.png'}?v=${cacheBuster}`;\n  console.log(`[atlas] Loading image ${imgPath}`);\n  const image = await loadImage(imgPath);\n  const stateMap = {};\n  for (const key in framesData) {\n    const state = key.replace(/_\\d+$/, \"\");\n    const idxMatch = /_(\\d+)$/.exec(key);\n    const idx = idxMatch ? parseInt(idxMatch[1], 10) : 0;\n    if (!stateMap[state]) stateMap[state] = [];\n    const f = framesData[key].frame;\n    stateMap[state][idx] = {\n      x: f.x,\n      y: f.y,\n      w: f.w,\n      h: f.h\n    };\n  }\n\n  // Sort frames by index to ensure correct order\n  for (const state in stateMap) {\n    stateMap[state].sort((a, b) => {\n      // Find the original indices for sorting\n      const aIdx = Object.keys(framesData).find(k => k.startsWith(`${state}_`) && framesData[k].frame.x === a.x && framesData[k].frame.y === a.y);\n      const bIdx = Object.keys(framesData).find(k => k.startsWith(`${state}_`) && framesData[k].frame.x === b.x && framesData[k].frame.y === b.y);\n      if (aIdx && bIdx) {\n        const aNum = parseInt(aIdx.split('_')[1], 10);\n        const bNum = parseInt(bIdx.split('_')[1], 10);\n        return aNum - bNum;\n      }\n      return 0;\n    });\n  }\n\n  // Determine frame size: prefer meta.tileSize if provided\n  const firstState = Object.keys(stateMap)[0];\n  const firstFrame = firstState ? stateMap[firstState][0] : {\n    w: 64,\n    h: 64\n  };\n  const tileSize = meta.tileSize && Array.isArray(meta.tileSize) && meta.tileSize.length >= 2 ? meta.tileSize : [firstFrame.w, firstFrame.h];\n  const frameW = tileSize[0];\n  const frameH = tileSize[1];\n\n  // Build animations; prefer loop/fps from data.animations if present\n  const providedAnims = data.animations || {};\n  const animations = {};\n  for (const s of Object.keys(stateMap)) {\n    const provided = providedAnims[s] || providedAnims[s + ''];\n    const fps = provided && provided.fps ? provided.fps : meta.fps || 12;\n    const loop = provided && typeof provided.loop === 'boolean' ? provided.loop : true;\n    animations[s] = {\n      frames: stateMap[s],\n      fps,\n      loop\n    };\n  }\n  return {\n    image,\n    animations,\n    frameW,\n    frameH\n  };\n}\nfunction loadImage(src) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n}","map":{"version":3,"names":["loadAtlas","basePath","cacheBuster","Date","now","candidates","match","push","text","usedJsonUrl","tried","cand","url","console","log","res","fetch","ok","status","contentType","headers","get","body","includes","trim","startsWith","warn","replace","length","e","Error","join","substring","data","JSON","parse","error","framesData","frames","meta","baseDir","imgPath","image","loadImage","stateMap","key","state","idxMatch","exec","idx","parseInt","f","frame","x","y","w","h","sort","a","b","aIdx","Object","keys","find","k","bIdx","aNum","split","bNum","firstState","firstFrame","tileSize","Array","isArray","frameW","frameH","providedAnims","animations","s","provided","fps","loop","src","Promise","resolve","reject","img","Image","onload","onerror"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/qte/atlasLoader.ts"],"sourcesContent":["// src/qte/atlasLoader.ts - simple runtime loader for TexturePacker JSON (ARRAY) format\n// The JSON layout we expect (TexturePacker \"JSON (Hash)\" or \"JSON (Array)\" works):\n// {\n//   \"frames\": {\n//      \"idle_0\": { \"frame\": {\"x\":0,\"y\":0,\"w\":256,\"h\":256}, ... },\n//      \"idle_1\": {...},\n//      \"walk_0\": {...}\n//   },\n//   \"meta\": { \"image\": \"atlas.png\" }\n// }\n// Each frame key is expected to be <state>_<index> (index starting at 0).\n// We group them into an array per state and keep the order of index.\n\nexport interface Rect { x: number; y: number; w: number; h: number }\nexport interface AtlasAnimation {\n  frames: Rect[];\n  fps: number;\n  loop: boolean;\n}\n\nexport interface LoadedAtlas {\n  image: HTMLImageElement;\n  animations: Record<string, AtlasAnimation>;\n  frameW: number;\n  frameH: number;\n}\n\nexport async function loadAtlas(basePath: string): Promise<LoadedAtlas> {\n  // basePath may be a directory or a path to a JSON file (e.g. \"/qte/ninja\" or \"/qte/ninja/atlas2.json\")\n  const cacheBuster = Date.now();\n\n  const candidates: string[] = [];\n  if (basePath.match(/\\.json$/i)) {\n    candidates.push(basePath);\n  } else {\n    candidates.push(`${basePath}/atlas.json`);\n    candidates.push(`${basePath}.json`);\n    // allow explicit atlas2 naming (common in this project)\n    candidates.push(`${basePath}/atlas2.json`);\n    candidates.push(`${basePath}/atlas2`);\n  }\n\n  let text: string | null = null;\n  let usedJsonUrl: string | null = null;\n  const tried: string[] = [];\n\n  for (const cand of candidates) {\n    const url = `${cand}?v=${cacheBuster}`;\n    tried.push(url);\n    console.log(`[atlas] Trying ${url}`);\n    try {\n      const res = await fetch(url);\n      if (!res.ok) {\n        console.log(`[atlas] ${url} responded ${res.status}`);\n        continue;\n      }\n\n      const contentType = res.headers.get('content-type') || '';\n      const body = await res.text();\n      // If server returned HTML (e.g. index.html), skip and try next candidate\n      if (contentType.includes('text/html') || body.trim().startsWith('<!DOCTYPE')) {\n        console.warn(`[atlas] ${url} looks like HTML (skipping)`);\n        continue;\n      }\n\n      text = body;\n      usedJsonUrl = url.replace(/\\?v=\\d+$/, '');\n      console.log(`[atlas] Loaded JSON from ${url} (len=${text.length})`);\n      break;\n    } catch (e) {\n      console.warn(`[atlas] fetch failed for ${url}`, e);\n      continue;\n    }\n  }\n\n  if (!text || !usedJsonUrl) {\n    throw new Error(`Atlas JSON not found. Tried: ${tried.join(', ')}`);\n  }\n\n  console.log(`[atlas] JSON response length: ${text.length}, starts with: ${text.substring(0, 100)}`);\n\n  let data: any;\n  try {\n    data = JSON.parse(text);\n  } catch (e) {\n    console.error(`[atlas] JSON parse error:`, e);\n    console.error(`[atlas] Invalid JSON text:`, text.substring(0, 200));\n    throw e;\n  }\n\n  const framesData = data.frames;\n  const meta = data.meta || {};\n  // compute base directory from usedJsonUrl\n  const baseDir = usedJsonUrl.replace(/\\/[^/]*$/, '');\n  const imgPath = `${baseDir}/${meta.image || 'atlas.png'}?v=${cacheBuster}`;\n  console.log(`[atlas] Loading image ${imgPath}`);\n  const image = await loadImage(imgPath);\n\n  const stateMap: Record<string, Rect[]> = {};\n  for (const key in framesData) {\n    const state = key.replace(/_\\d+$/, \"\");\n    const idxMatch = /_(\\d+)$/.exec(key);\n    const idx = idxMatch ? parseInt(idxMatch[1], 10) : 0;\n    if (!stateMap[state]) stateMap[state] = [];\n    const f = framesData[key].frame as { x: number; y: number; w: number; h: number };\n    stateMap[state][idx] = { x: f.x, y: f.y, w: f.w, h: f.h };\n  }\n  \n  // Sort frames by index to ensure correct order\n  for (const state in stateMap) {\n    stateMap[state].sort((a, b) => {\n      // Find the original indices for sorting\n      const aIdx = Object.keys(framesData).find(k => k.startsWith(`${state}_`) && framesData[k].frame.x === a.x && framesData[k].frame.y === a.y);\n      const bIdx = Object.keys(framesData).find(k => k.startsWith(`${state}_`) && framesData[k].frame.x === b.x && framesData[k].frame.y === b.y);\n      if (aIdx && bIdx) {\n        const aNum = parseInt(aIdx.split('_')[1], 10);\n        const bNum = parseInt(bIdx.split('_')[1], 10);\n        return aNum - bNum;\n      }\n      return 0;\n    });\n  }\n\n  // Determine frame size: prefer meta.tileSize if provided\n  const firstState = Object.keys(stateMap)[0];\n  const firstFrame = firstState ? stateMap[firstState][0] : { w: 64, h: 64 };\n  const tileSize = (meta.tileSize && Array.isArray(meta.tileSize) && meta.tileSize.length >= 2) ? meta.tileSize : [firstFrame.w, firstFrame.h];\n  const frameW = tileSize[0];\n  const frameH = tileSize[1];\n\n  // Build animations; prefer loop/fps from data.animations if present\n  const providedAnims = data.animations || {};\n  const animations: Record<string, AtlasAnimation> = {};\n  for (const s of Object.keys(stateMap)) {\n    const provided = providedAnims[s] || providedAnims[s + ''];\n    const fps = provided && provided.fps ? provided.fps : (meta.fps || 12);\n    const loop = provided && typeof provided.loop === 'boolean' ? provided.loop : true;\n    animations[s] = { frames: stateMap[s], fps, loop };\n  }\n\n  return { image, animations, frameW, frameH };\n}\n\nfunction loadImage(src: string): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}