{"ast":null,"code":"// Simplified AP system (2025-08-25)\n// ------------------------------------------------------------\n// Rules:\n// 1. Each card costs exactly 1 AP to play.\n// 2. Players start every turn with 2 AP (handled in game logic).\n// 3. AP effects simply ADD to the current AP via queued ADD_AP events.\n// 4. There is **no upper AP cap**. Values may exceed previous MAX_AP of 4.\n\nexport const START_AP = 2;\nexport const MAX_AP = Number.MAX_SAFE_INTEGER; // unlimited cap used for legacy code\nexport const BASE_AP_COST = 1; // fixed cost for every card\n\n// Cache for AP calculations to prevent redundant calls\nconst apCache = new Map();\nfunction getCacheKey(state, player, card, lane) {\n  const flags = state.effectFlags[player];\n  return `${player}-${card.uid}-${lane}-${flags === null || flags === void 0 ? void 0 : flags.initiativeDiscount}-${flags === null || flags === void 0 ? void 0 : flags.initiativeRefund}-${flags === null || flags === void 0 ? void 0 : flags.govRefundAvailable}`;\n}\nfunction clearApCache() {\n  apCache.clear();\n}\nfunction isInitiative(card) {\n  var _type;\n  const typeStr = (_type = card.type) !== null && _type !== void 0 ? _type : '';\n  return card.kind === 'spec' && /Sofort-?Initiative/i.test(typeStr);\n}\nfunction isGovernment(card) {\n  return card.kind === 'pol';\n}\n\n/**\r\n * Returns the (fixed) AP cost for playing a card.\r\n * The new simplified system ignores all discounts – those abilities should now\r\n * enqueue an ADD_AP event instead. We still keep the signature to avoid large\r\n * refactors elsewhere.\r\n */\nexport function getCardActionPointCost(_state, _player, _card, _lane) {\n  return {\n    cost: BASE_AP_COST,\n    reasons: []\n  };\n}\nexport function getNetApCost(state, player, card, lane) {\n  // Simplified AP system: All cards cost exactly 1 AP\n  const cost = BASE_AP_COST;\n  const refund = 0;\n  const net = cost; // always 1\n\n  return {\n    cost,\n    refund,\n    net,\n    reasons: []\n  };\n}\n\n// Clear cache when game state changes significantly\nexport function clearApCacheOnStateChange() {\n  clearApCache();\n}\nexport function wouldBeNetZero(state, player, card, lane) {\n  return getNetApCost(state, player, card, lane).net <= 0;\n}\nexport const isInitiativeCard = isInitiative;\nexport const isGovernmentCard = isGovernment;\nexport const isNetZeroMove = wouldBeNetZero;\nexport const canPlayCard = (state, p, card) => {\n  // In the simplified AP system we only check that the player still has AP.\n  return state.actionPoints[p] > 0;\n};\nexport const hasGretaOnBoard = (state, p) => state.board[p].innen.some(c => (c === null || c === void 0 ? void 0 : c.kind) === 'pol' && (c === null || c === void 0 ? void 0 : c.name) === 'Greta Thunberg' && !(c !== null && c !== void 0 && c.deactivated));\nexport const hasAnyZeroApPlay = (state, p) => {\n  var _state$hands$p;\n  return ((_state$hands$p = state.hands[p]) !== null && _state$hands$p !== void 0 ? _state$hands$p : []).some(c => wouldBeNetZero(state, p, c));\n};\nexport function resetTurnApRefundFlags(state, p) {}\nexport function applyApRefundsAfterPlay(_state, _p, _card) {}","map":{"version":3,"names":["START_AP","MAX_AP","Number","MAX_SAFE_INTEGER","BASE_AP_COST","apCache","Map","getCacheKey","state","player","card","lane","flags","effectFlags","uid","initiativeDiscount","initiativeRefund","govRefundAvailable","clearApCache","clear","isInitiative","_type","typeStr","type","kind","test","isGovernment","getCardActionPointCost","_state","_player","_card","_lane","cost","reasons","getNetApCost","refund","net","clearApCacheOnStateChange","wouldBeNetZero","isInitiativeCard","isGovernmentCard","isNetZeroMove","canPlayCard","p","actionPoints","hasGretaOnBoard","board","innen","some","c","name","deactivated","hasAnyZeroApPlay","_state$hands$p","hands","resetTurnApRefundFlags","applyApRefundsAfterPlay","_p"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/utils/ap.ts"],"sourcesContent":["import { Card, GameState, Player } from '../types/game';\r\n\r\n// Simplified AP system (2025-08-25)\r\n// ------------------------------------------------------------\r\n// Rules:\r\n// 1. Each card costs exactly 1 AP to play.\r\n// 2. Players start every turn with 2 AP (handled in game logic).\r\n// 3. AP effects simply ADD to the current AP via queued ADD_AP events.\r\n// 4. There is **no upper AP cap**. Values may exceed previous MAX_AP of 4.\r\n\r\nexport const START_AP = 2;\r\nexport const MAX_AP = Number.MAX_SAFE_INTEGER; // unlimited cap used for legacy code\r\nexport const BASE_AP_COST = 1; // fixed cost for every card\r\n\r\n// Cache for AP calculations to prevent redundant calls\r\nconst apCache = new Map<string, { cost: number; refund: number; net: number; reasons: string[] }>();\r\n\r\nfunction getCacheKey(state: GameState, player: Player, card: Card, lane?: string): string {\r\n  const flags = state.effectFlags[player];\r\n  return `${player}-${card.uid}-${lane}-${flags?.initiativeDiscount}-${flags?.initiativeRefund}-${flags?.govRefundAvailable}`;\r\n}\r\n\r\nfunction clearApCache(): void {\r\n  apCache.clear();\r\n}\r\n\r\nfunction isInitiative(card: Card): boolean {\r\n  const typeStr = (card as any).type ?? '';\r\n  return card.kind === 'spec' && /Sofort-?Initiative/i.test(typeStr);\r\n}\r\n\r\nfunction isGovernment(card: Card): boolean {\r\n  return card.kind === 'pol';\r\n}\r\n\r\n/**\r\n * Returns the (fixed) AP cost for playing a card.\r\n * The new simplified system ignores all discounts – those abilities should now\r\n * enqueue an ADD_AP event instead. We still keep the signature to avoid large\r\n * refactors elsewhere.\r\n */\r\nexport function getCardActionPointCost(\r\n  _state: GameState,\r\n  _player: Player,\r\n  _card: Card,\r\n  _lane?: 'innen' | 'aussen' | 'sofort'\r\n): { cost: number; reasons: string[] } {\r\n  return { cost: BASE_AP_COST, reasons: [] };\r\n}\r\n\r\nexport function getNetApCost(\r\n  state: GameState,\r\n  player: Player,\r\n  card: Card,\r\n  lane?: 'innen' | 'aussen' | 'sofort'\r\n): { cost: number; refund: number; net: number; reasons: string[] } {\r\n  // Simplified AP system: All cards cost exactly 1 AP\r\n  const cost = BASE_AP_COST;\r\n  const refund = 0;\r\n  const net = cost; // always 1\r\n\r\n  return { cost, refund, net, reasons: [] };\r\n}\r\n\r\n// Clear cache when game state changes significantly\r\nexport function clearApCacheOnStateChange(): void {\r\n  clearApCache();\r\n}\r\n\r\nexport function wouldBeNetZero(\r\n  state: GameState,\r\n  player: Player,\r\n  card: Card,\r\n  lane?: 'innen' | 'aussen' | 'sofort'\r\n): boolean {\r\n  return getNetApCost(state, player, card, lane).net <= 0;\r\n}\r\n\r\nexport const isInitiativeCard = isInitiative;\r\nexport const isGovernmentCard = isGovernment;\r\nexport const isNetZeroMove = wouldBeNetZero;\r\nexport const canPlayCard = (state: GameState, p: Player, card: Card): boolean => {\r\n  // In the simplified AP system we only check that the player still has AP.\r\n  return state.actionPoints[p] > 0;\r\n};\r\n\r\nexport const hasGretaOnBoard = (state: GameState, p: Player) =>\r\n  state.board[p].innen.some(\r\n    (c) => (c as any)?.kind === 'pol' && (c as any)?.name === 'Greta Thunberg' && !(c as any)?.deactivated\r\n  );\r\nexport const hasAnyZeroApPlay = (state: GameState, p: Player) =>\r\n  (state.hands[p] ?? []).some((c) => wouldBeNetZero(state, p, c));\r\nexport function resetTurnApRefundFlags(state: GameState, p: Player) {}\r\nexport function applyApRefundsAfterPlay(_state: GameState, _p: Player, _card: Card) {}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}