{"ast":null,"code":"// Character System - State Management und Facing Logic\n// Erweitert die Animation Engine um Character-spezifische Logik\n\nimport { getFrameHitboxes } from '../data/animationRegistry';\nexport class CharacterSystem {\n  constructor() {\n    this.characters = new Map();\n    this.hurtboxes = new Map();\n  }\n  // === CHARACTER STATE MANAGEMENT ===\n\n  createCharacter(id, position, facing = 1) {\n    const character = {\n      id,\n      position: {\n        ...position\n      },\n      facing,\n      currentAnimation: 'idle',\n      animationFrame: 0,\n      animationTime: 0\n    };\n    this.characters.set(id, character);\n    return character;\n  }\n  getCharacter(id) {\n    return this.characters.get(id);\n  }\n  updateCharacterPosition(id, position) {\n    const character = this.characters.get(id);\n    if (character) {\n      character.position = {\n        ...position\n      };\n    }\n  }\n  setCharacterFacing(id, facing) {\n    const character = this.characters.get(id);\n    if (character) {\n      character.facing = facing;\n    }\n  }\n\n  // === FACING LOGIC ===\n\n  // Berechnet Facing basierend auf Position relativ zu einem Ziel\n  calculateFacingToTarget(characterId, targetPosition) {\n    const character = this.characters.get(characterId);\n    if (!character) return 1;\n    return targetPosition.x > character.position.x ? 1 : -1;\n  }\n\n  // Setzt Facing automatisch basierend auf Bewegung\n  updateFacingFromMovement(characterId, velocity) {\n    if (Math.abs(velocity.x) > 0.1) {\n      // Deadzone für kleine Bewegungen\n      this.setCharacterFacing(characterId, velocity.x > 0 ? 1 : -1);\n    }\n  }\n\n  // === HITBOX/HURTBOX SYSTEM ===\n\n  // Aktualisiert Hurtboxen basierend auf aktueller Animation und Frame\n  updateHurtboxes(characterId, animationName, frame) {\n    const hitboxes = getFrameHitboxes(animationName, frame);\n    const hurtboxes = hitboxes.filter(hitbox => hitbox.type === 'hurt').map(hitbox => this.transformHitboxToWorldSpace(characterId, hitbox.bounds));\n    this.hurtboxes.set(characterId, hurtboxes);\n  }\n\n  // Transformiert Hitbox von Sprite-Space zu World-Space\n  transformHitboxToWorldSpace(characterId, bounds) {\n    const character = this.characters.get(characterId);\n    if (!character) return bounds;\n\n    // Berücksichtigt Facing für X-Koordinaten\n    const facingMultiplier = character.facing;\n    return {\n      x: character.position.x + bounds.x * facingMultiplier,\n      y: character.position.y + bounds.y,\n      width: bounds.width,\n      height: bounds.height\n    };\n  }\n\n  // Prüft Kollision zwischen zwei BoundingBoxen\n  checkCollision(box1, box2) {\n    return !(box1.x + box1.width < box2.x || box2.x + box2.width < box1.x || box1.y + box1.height < box2.y || box2.y + box2.height < box1.y);\n  }\n\n  // Prüft Kollision zwischen Character und einem Punkt\n  checkPointCollision(characterId, point) {\n    const hurtboxes = this.hurtboxes.get(characterId) || [];\n    return hurtboxes.some(hurtbox => point.x >= hurtbox.x && point.x <= hurtbox.x + hurtbox.width && point.y >= hurtbox.y && point.y <= hurtbox.y + hurtbox.height);\n  }\n\n  // Prüft Kollision zwischen zwei Characters\n  checkCharacterCollision(characterId1, characterId2) {\n    const hurtboxes1 = this.hurtboxes.get(characterId1) || [];\n    const hurtboxes2 = this.hurtboxes.get(characterId2) || [];\n    for (const box1 of hurtboxes1) {\n      for (const box2 of hurtboxes2) {\n        if (this.checkCollision(box1, box2)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  // === ANIMATION STATE HELPERS ===\n\n  // Prüft ob Character in einer bestimmten Animation ist\n  isInAnimation(characterId, animationName) {\n    const character = this.characters.get(characterId);\n    return (character === null || character === void 0 ? void 0 : character.currentAnimation) === animationName;\n  }\n\n  // Prüft ob Character in einem bestimmten Frame ist\n  isInFrame(characterId, frame) {\n    const character = this.characters.get(characterId);\n    return (character === null || character === void 0 ? void 0 : character.animationFrame) === frame;\n  }\n\n  // Prüft ob Character in einem Frame-Bereich ist\n  isInFrameRange(characterId, startFrame, endFrame) {\n    const character = this.characters.get(characterId);\n    if (!character) return false;\n    return character.animationFrame >= startFrame && character.animationFrame <= endFrame;\n  }\n\n  // === MOVEMENT HELPERS ===\n\n  // Bewegt Character in eine Richtung\n  moveCharacter(characterId, direction, speed) {\n    const character = this.characters.get(characterId);\n    if (!character) return;\n\n    // Normalisiere Richtung\n    const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y);\n    if (length === 0) return;\n    const normalizedDirection = {\n      x: direction.x / length,\n      y: direction.y / length\n    };\n\n    // Update Position\n    character.position.x += normalizedDirection.x * speed;\n    character.position.y += normalizedDirection.y * speed;\n\n    // Update Facing basierend auf Bewegung\n    this.updateFacingFromMovement(characterId, normalizedDirection);\n  }\n\n  // Teleportiert Character zu einer Position\n  teleportCharacter(characterId, position) {\n    const character = this.characters.get(characterId);\n    if (character) {\n      character.position = {\n        ...position\n      };\n    }\n  }\n\n  // === UTILITY METHODS ===\n\n  // Gibt alle Characters zurück\n  getAllCharacters() {\n    return Array.from(this.characters.values());\n  }\n\n  // Gibt Characters in einem bestimmten Bereich zurück\n  getCharactersInArea(center, radius) {\n    return this.getAllCharacters().filter(character => {\n      const distance = Math.sqrt(Math.pow(character.position.x - center.x, 2) + Math.pow(character.position.y - center.y, 2));\n      return distance <= radius;\n    });\n  }\n\n  // Gibt den nächsten Character zu einer Position zurück\n  getNearestCharacter(position, excludeId) {\n    let nearest = null;\n    let nearestDistance = Infinity;\n    for (const character of this.getAllCharacters()) {\n      if (excludeId && character.id === excludeId) continue;\n      const distance = Math.sqrt(Math.pow(character.position.x - position.x, 2) + Math.pow(character.position.y - position.y, 2));\n      if (distance < nearestDistance) {\n        nearest = character;\n        nearestDistance = distance;\n      }\n    }\n    return nearest;\n  }\n\n  // Entfernt Character aus dem System\n  removeCharacter(characterId) {\n    this.characters.delete(characterId);\n    this.hurtboxes.delete(characterId);\n  }\n\n  // Leert das gesamte System\n  clear() {\n    this.characters.clear();\n    this.hurtboxes.clear();\n  }\n}","map":{"version":3,"names":["getFrameHitboxes","CharacterSystem","constructor","characters","Map","hurtboxes","createCharacter","id","position","facing","character","currentAnimation","animationFrame","animationTime","set","getCharacter","get","updateCharacterPosition","setCharacterFacing","calculateFacingToTarget","characterId","targetPosition","x","updateFacingFromMovement","velocity","Math","abs","updateHurtboxes","animationName","frame","hitboxes","filter","hitbox","type","map","transformHitboxToWorldSpace","bounds","facingMultiplier","y","width","height","checkCollision","box1","box2","checkPointCollision","point","some","hurtbox","checkCharacterCollision","characterId1","characterId2","hurtboxes1","hurtboxes2","isInAnimation","isInFrame","isInFrameRange","startFrame","endFrame","moveCharacter","direction","speed","length","sqrt","normalizedDirection","teleportCharacter","getAllCharacters","Array","from","values","getCharactersInArea","center","radius","distance","pow","getNearestCharacter","excludeId","nearest","nearestDistance","Infinity","removeCharacter","delete","clear"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/engine/characterSystem.ts"],"sourcesContent":["// Character System - State Management und Facing Logic\r\n// Erweitert die Animation Engine um Character-spezifische Logik\r\n\r\nimport type {\r\n  CharacterState,\r\n  Vector2,\r\n  BoundingBox,\r\n  FrameHitbox\r\n} from '../types/animation';\r\nimport { getFrameHitboxes } from '../data/animationRegistry';\r\n\r\nexport class CharacterSystem {\r\n  private characters: Map<string, CharacterState> = new Map();\r\n  private hurtboxes: Map<string, BoundingBox[]> = new Map();\r\n\r\n  // === CHARACTER STATE MANAGEMENT ===\r\n\r\n  createCharacter(id: string, position: Vector2, facing: -1 | 1 = 1): CharacterState {\r\n    const character: CharacterState = {\r\n      id,\r\n      position: { ...position },\r\n      facing,\r\n      currentAnimation: 'idle',\r\n      animationFrame: 0,\r\n      animationTime: 0\r\n    };\r\n\r\n    this.characters.set(id, character);\r\n    return character;\r\n  }\r\n\r\n  getCharacter(id: string): CharacterState | undefined {\r\n    return this.characters.get(id);\r\n  }\r\n\r\n  updateCharacterPosition(id: string, position: Vector2): void {\r\n    const character = this.characters.get(id);\r\n    if (character) {\r\n      character.position = { ...position };\r\n    }\r\n  }\r\n\r\n  setCharacterFacing(id: string, facing: -1 | 1): void {\r\n    const character = this.characters.get(id);\r\n    if (character) {\r\n      character.facing = facing;\r\n    }\r\n  }\r\n\r\n  // === FACING LOGIC ===\r\n\r\n  // Berechnet Facing basierend auf Position relativ zu einem Ziel\r\n  calculateFacingToTarget(characterId: string, targetPosition: Vector2): -1 | 1 {\r\n    const character = this.characters.get(characterId);\r\n    if (!character) return 1;\r\n\r\n    return targetPosition.x > character.position.x ? 1 : -1;\r\n  }\r\n\r\n  // Setzt Facing automatisch basierend auf Bewegung\r\n  updateFacingFromMovement(characterId: string, velocity: Vector2): void {\r\n    if (Math.abs(velocity.x) > 0.1) { // Deadzone für kleine Bewegungen\r\n      this.setCharacterFacing(characterId, velocity.x > 0 ? 1 : -1);\r\n    }\r\n  }\r\n\r\n  // === HITBOX/HURTBOX SYSTEM ===\r\n\r\n  // Aktualisiert Hurtboxen basierend auf aktueller Animation und Frame\r\n  updateHurtboxes(characterId: string, animationName: string, frame: number): void {\r\n    const hitboxes = getFrameHitboxes(animationName, frame);\r\n    const hurtboxes = hitboxes\r\n      .filter(hitbox => hitbox.type === 'hurt')\r\n      .map(hitbox => this.transformHitboxToWorldSpace(characterId, hitbox.bounds));\r\n\r\n    this.hurtboxes.set(characterId, hurtboxes);\r\n  }\r\n\r\n  // Transformiert Hitbox von Sprite-Space zu World-Space\r\n  private transformHitboxToWorldSpace(characterId: string, bounds: BoundingBox): BoundingBox {\r\n    const character = this.characters.get(characterId);\r\n    if (!character) return bounds;\r\n\r\n    // Berücksichtigt Facing für X-Koordinaten\r\n    const facingMultiplier = character.facing;\r\n\r\n    return {\r\n      x: character.position.x + (bounds.x * facingMultiplier),\r\n      y: character.position.y + bounds.y,\r\n      width: bounds.width,\r\n      height: bounds.height\r\n    };\r\n  }\r\n\r\n  // Prüft Kollision zwischen zwei BoundingBoxen\r\n  checkCollision(box1: BoundingBox, box2: BoundingBox): boolean {\r\n    return !(\r\n      box1.x + box1.width < box2.x ||\r\n      box2.x + box2.width < box1.x ||\r\n      box1.y + box1.height < box2.y ||\r\n      box2.y + box2.height < box1.y\r\n    );\r\n  }\r\n\r\n  // Prüft Kollision zwischen Character und einem Punkt\r\n  checkPointCollision(characterId: string, point: Vector2): boolean {\r\n    const hurtboxes = this.hurtboxes.get(characterId) || [];\r\n\r\n    return hurtboxes.some(hurtbox =>\r\n      point.x >= hurtbox.x &&\r\n      point.x <= hurtbox.x + hurtbox.width &&\r\n      point.y >= hurtbox.y &&\r\n      point.y <= hurtbox.y + hurtbox.height\r\n    );\r\n  }\r\n\r\n  // Prüft Kollision zwischen zwei Characters\r\n  checkCharacterCollision(characterId1: string, characterId2: string): boolean {\r\n    const hurtboxes1 = this.hurtboxes.get(characterId1) || [];\r\n    const hurtboxes2 = this.hurtboxes.get(characterId2) || [];\r\n\r\n    for (const box1 of hurtboxes1) {\r\n      for (const box2 of hurtboxes2) {\r\n        if (this.checkCollision(box1, box2)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  // === ANIMATION STATE HELPERS ===\r\n\r\n  // Prüft ob Character in einer bestimmten Animation ist\r\n  isInAnimation(characterId: string, animationName: string): boolean {\r\n    const character = this.characters.get(characterId);\r\n    return character?.currentAnimation === animationName;\r\n  }\r\n\r\n  // Prüft ob Character in einem bestimmten Frame ist\r\n  isInFrame(characterId: string, frame: number): boolean {\r\n    const character = this.characters.get(characterId);\r\n    return character?.animationFrame === frame;\r\n  }\r\n\r\n  // Prüft ob Character in einem Frame-Bereich ist\r\n  isInFrameRange(characterId: string, startFrame: number, endFrame: number): boolean {\r\n    const character = this.characters.get(characterId);\r\n    if (!character) return false;\r\n\r\n    return character.animationFrame >= startFrame && character.animationFrame <= endFrame;\r\n  }\r\n\r\n  // === MOVEMENT HELPERS ===\r\n\r\n  // Bewegt Character in eine Richtung\r\n  moveCharacter(characterId: string, direction: Vector2, speed: number): void {\r\n    const character = this.characters.get(characterId);\r\n    if (!character) return;\r\n\r\n    // Normalisiere Richtung\r\n    const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y);\r\n    if (length === 0) return;\r\n\r\n    const normalizedDirection = {\r\n      x: direction.x / length,\r\n      y: direction.y / length\r\n    };\r\n\r\n    // Update Position\r\n    character.position.x += normalizedDirection.x * speed;\r\n    character.position.y += normalizedDirection.y * speed;\r\n\r\n    // Update Facing basierend auf Bewegung\r\n    this.updateFacingFromMovement(characterId, normalizedDirection);\r\n  }\r\n\r\n  // Teleportiert Character zu einer Position\r\n  teleportCharacter(characterId: string, position: Vector2): void {\r\n    const character = this.characters.get(characterId);\r\n    if (character) {\r\n      character.position = { ...position };\r\n    }\r\n  }\r\n\r\n  // === UTILITY METHODS ===\r\n\r\n  // Gibt alle Characters zurück\r\n  getAllCharacters(): CharacterState[] {\r\n    return Array.from(this.characters.values());\r\n  }\r\n\r\n  // Gibt Characters in einem bestimmten Bereich zurück\r\n  getCharactersInArea(center: Vector2, radius: number): CharacterState[] {\r\n    return this.getAllCharacters().filter(character => {\r\n      const distance = Math.sqrt(\r\n        Math.pow(character.position.x - center.x, 2) +\r\n        Math.pow(character.position.y - center.y, 2)\r\n      );\r\n      return distance <= radius;\r\n    });\r\n  }\r\n\r\n  // Gibt den nächsten Character zu einer Position zurück\r\n  getNearestCharacter(position: Vector2, excludeId?: string): CharacterState | null {\r\n    let nearest: CharacterState | null = null;\r\n    let nearestDistance = Infinity;\r\n\r\n    for (const character of this.getAllCharacters()) {\r\n      if (excludeId && character.id === excludeId) continue;\r\n\r\n      const distance = Math.sqrt(\r\n        Math.pow(character.position.x - position.x, 2) +\r\n        Math.pow(character.position.y - position.y, 2)\r\n      );\r\n\r\n      if (distance < nearestDistance) {\r\n        nearest = character;\r\n        nearestDistance = distance;\r\n      }\r\n    }\r\n\r\n    return nearest;\r\n  }\r\n\r\n  // Entfernt Character aus dem System\r\n  removeCharacter(characterId: string): void {\r\n    this.characters.delete(characterId);\r\n    this.hurtboxes.delete(characterId);\r\n  }\r\n\r\n  // Leert das gesamte System\r\n  clear(): void {\r\n    this.characters.clear();\r\n    this.hurtboxes.clear();\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}