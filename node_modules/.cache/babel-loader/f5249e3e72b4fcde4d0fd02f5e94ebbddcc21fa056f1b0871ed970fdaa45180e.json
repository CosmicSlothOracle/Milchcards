{"ast":null,"code":"import { sumRow, getCardActionPointCost } from '../utils/gameUtils';\n// Basic AI player module with three difficulty presets.\n// takeTurn applies a state update via setGameState(prev => newState).\nexport function takeTurn(setGameState, difficulty, log) {\n  setGameState(prev => {\n    var _prev$aiEnabled$, _prev$aiEnabled;\n    const aiEnabled = (_prev$aiEnabled$ = (_prev$aiEnabled = prev.aiEnabled) === null || _prev$aiEnabled === void 0 ? void 0 : _prev$aiEnabled[2]) !== null && _prev$aiEnabled$ !== void 0 ? _prev$aiEnabled$ : false;\n    if (!aiEnabled || prev.current !== 2) return prev;\n    const hand = prev.hands[2];\n    const playerBoard = prev.board[1];\n    const aiBoard = prev.board[2];\n    const aiAP = prev.actionPoints[2];\n    log(` AI(${difficulty}) Analyse: P=${sumRow([...playerBoard.aussen])} vs AI=${sumRow([...aiBoard.aussen])}`);\n    if (aiAP <= 0) {\n      log(' AI passt - keine AP mehr.');\n      return {\n        ...prev,\n        passed: {\n          ...prev.passed,\n          2: true\n        }\n      };\n    }\n\n    // Use the centralized decision helper so tests and takeTurn share logic\n    const action = decideBestAction(prev, 2, difficulty);\n    if (action.type === 'pass') {\n      log(' AI passt - keine guten Aktionen.');\n      return {\n        ...prev,\n        passed: {\n          ...prev.passed,\n          2: true\n        }\n      };\n    }\n\n    // Execute chosen play\n    const playIndex = action.type === 'play' ? action.index : -1;\n    const chosenCard = prev.hands[2][playIndex];\n    if (!chosenCard) {\n      log(' AI Fehler: Ung羹ltiger Kartenindex, passe.');\n      return {\n        ...prev,\n        passed: {\n          ...prev.passed,\n          2: true\n        }\n      };\n    }\n    const apCost = getCardActionPointCost(chosenCard, prev, 2);\n    function detectLaneForCard(card) {\n      if (card.T && card.T >= 2) return 'aussen';\n      if (card.tag && ['Staatsoberhaupt', 'Regierungschef', 'Diplomat'].includes(card.tag)) return 'aussen';\n      return 'innen';\n    }\n    if (chosenCard.kind === 'pol') {\n      var _action$lane, _influence;\n      const lane = (_action$lane = action.lane) !== null && _action$lane !== void 0 ? _action$lane : detectLaneForCard(chosenCard);\n      const newP2Hand = [...prev.hands[2]];\n      const [played] = newP2Hand.splice(playIndex, 1);\n      const newP2Lane = [...prev.board[2][lane], played];\n      const newP2Board = {\n        ...prev.board[2],\n        [lane]: newP2Lane\n      };\n      const newBoard = {\n        ...prev.board,\n        2: newP2Board\n      };\n      const newActionPoints = {\n        ...prev.actionPoints,\n        2: prev.actionPoints[2] - apCost\n      };\n      const laneName = lane === 'aussen' ? 'Regierungsreihe' : 'ffentlichkeitsreihe';\n      const power = (_influence = played.influence) !== null && _influence !== void 0 ? _influence : 0;\n      log(` AI spielt ${played.name} (${power} Einfluss) nach ${laneName}.`);\n      return {\n        ...prev,\n        hands: {\n          ...prev.hands,\n          2: newP2Hand\n        },\n        board: newBoard,\n        actionPoints: newActionPoints\n      };\n    }\n\n    // spec cards\n    const newP2Hand = [...prev.hands[2]];\n    const [playedSpec] = newP2Hand.splice(playIndex, 1);\n    const newActionPoints = {\n      ...prev.actionPoints,\n      2: prev.actionPoints[2] - apCost\n    };\n    if (playedSpec.type === 'Dauerhaft-Initiative') {\n      const slotType = playedSpec.slot === 'ffentlichkeit' ? 'public' : 'government';\n      if (slotType === 'government' && !prev.permanentSlots[2].government) {\n        const newPermanentSlots = {\n          ...prev.permanentSlots,\n          2: {\n            ...prev.permanentSlots[2],\n            government: playedSpec\n          }\n        };\n        log(` AI legt ${playedSpec.name} in Regierung Spezial-Slot.`);\n        return {\n          ...prev,\n          hands: {\n            ...prev.hands,\n            2: newP2Hand\n          },\n          permanentSlots: newPermanentSlots,\n          actionPoints: newActionPoints\n        };\n      } else if (slotType === 'public' && !prev.permanentSlots[2].public) {\n        const newPermanentSlots = {\n          ...prev.permanentSlots,\n          2: {\n            ...prev.permanentSlots[2],\n            public: playedSpec\n          }\n        };\n        log(` AI legt ${playedSpec.name} in ffentlichkeit Spezial-Slot.`);\n        return {\n          ...prev,\n          hands: {\n            ...prev.hands,\n            2: newP2Hand\n          },\n          permanentSlots: newPermanentSlots,\n          actionPoints: newActionPoints\n        };\n      }\n    }\n    log(` AI spielt Spezialkarte ${playedSpec.name}.`);\n    return {\n      ...prev,\n      hands: {\n        ...prev.hands,\n        2: newP2Hand\n      },\n      actionPoints: newActionPoints\n    };\n  });\n}\n\n// Expose a light-weight decision helper for tests\nexport function decideBestAction(state, player, difficulty = 'easy') {\n  // reuse takeTurn logic but without mutating state: produce an action suggestions\n  const hand = state.hands[player];\n  const aiAP = state.actionPoints[player];\n  if (aiAP <= 0) return {\n    type: 'pass'\n  };\n  // Policy: maximize influence placed per round. If current lead is already durable, pass.\n  const candidates = [];\n  const myInf = sumRow([...state.board[player].aussen]);\n  const opponent = player === 1 ? 2 : 1;\n  const oppInf = sumRow([...state.board[opponent].aussen]);\n\n  // If already holding a durable lead, pass\n  const currentLead = myInf - oppInf;\n  if (currentLead >= 3) return {\n    type: 'pass'\n  };\n  hand.forEach((card, idx) => {\n    const apCost = getCardActionPointCost(card, state, player);\n    if (apCost > aiAP) return;\n    let score = 0;\n    let suggestedLane = undefined;\n    if (card.kind === 'pol') {\n      const pol = card;\n      suggestedLane = pol.tag === 'Staatsoberhaupt' || pol.tag === 'Regierungschef' || pol.tag === 'Diplomat' ? 'aussen' : 'innen';\n      const influence = pol.influence || 0;\n      // Strong preference: influence per AP (primary objective)\n      score = influence / Math.max(1, apCost) * 100;\n      // small bonus for placing into government lane\n      if (suggestedLane === 'aussen') score += 15;\n    } else if (card.kind === 'spec') {\n      const spec = card;\n      // Specs less prioritized; interventions get moderate score\n      if (spec.type === 'Intervention') score = 30;else score = 20 + (spec.bp || 0) * 2;\n    }\n\n    // difficulty randomness\n    if (difficulty === 'medium') score += Math.floor(Math.random() * 6) - 2;\n    if (difficulty === 'hard') score += 4;\n    candidates.push({\n      index: idx,\n      card,\n      score,\n      lane: suggestedLane\n    });\n  });\n  if (candidates.length === 0) return {\n    type: 'pass'\n  };\n  candidates.sort((a, b) => b.score - a.score);\n  // If hard difficulty, run light Monte Carlo rollouts from top candidates\n  if (difficulty === 'hard') {\n    var _rolloutScores$get;\n    const top = candidates.slice(0, Math.min(4, candidates.length));\n    const rolloutScores = new Map();\n    const simulate = (stateSnapshot, playIndex, lane) => {\n      // Very lightweight simulation: apply the play and evaluate immediate board influence difference\n      const simState = JSON.parse(JSON.stringify(stateSnapshot));\n      const card = simState.hands[player][playIndex];\n      const apCost = getCardActionPointCost(card, simState, player);\n\n      // apply simple play\n      simState.actionPoints[player] = Math.max(0, simState.actionPoints[player] - apCost);\n      simState.hands[player].splice(playIndex, 1);\n      if (card.kind === 'pol') {\n        const targetLane = lane !== null && lane !== void 0 ? lane : card.tag === 'Staatsoberhaupt' || card.tag === 'Regierungschef' || card.tag === 'Diplomat' ? 'aussen' : 'innen';\n        simState.board[player][targetLane].push(card);\n      } else if (card.kind === 'spec' && card.type === 'Intervention') {\n        simState.traps[player].push(card);\n      }\n\n      // Quick eval: difference in government influence\n      const myInf = sumRow([...simState.board[player].aussen]);\n      const opp = player === 1 ? 2 : 1;\n      const oppInf = sumRow([...simState.board[opp].aussen]);\n      return myInf - oppInf;\n    };\n    for (const c of top) {\n      let acc = 0;\n      const trials = 6;\n      for (let t = 0; t < trials; t++) {\n        acc += simulate(state, c.index, c.lane);\n      }\n      rolloutScores.set(c.index, acc / trials + c.score);\n    }\n\n    // pick best by rollout-adjusted score\n    let bestIdx = top[0].index;\n    let bestScore = (_rolloutScores$get = rolloutScores.get(bestIdx)) !== null && _rolloutScores$get !== void 0 ? _rolloutScores$get : top[0].score;\n    for (const c of top) {\n      var _rolloutScores$get2;\n      const s = (_rolloutScores$get2 = rolloutScores.get(c.index)) !== null && _rolloutScores$get2 !== void 0 ? _rolloutScores$get2 : c.score;\n      if (s > bestScore) {\n        bestScore = s;\n        bestIdx = c.index;\n      }\n    }\n    const chosen = candidates.find(x => x.index === bestIdx);\n    return {\n      type: 'play',\n      index: chosen.index,\n      lane: chosen.lane\n    };\n  }\n  const best = candidates[0];\n  return {\n    type: 'play',\n    index: best.index,\n    lane: best.lane\n  };\n}","map":{"version":3,"names":["sumRow","getCardActionPointCost","takeTurn","setGameState","difficulty","log","prev","_prev$aiEnabled$","_prev$aiEnabled","aiEnabled","current","hand","hands","playerBoard","board","aiBoard","aiAP","actionPoints","aussen","passed","action","decideBestAction","type","playIndex","index","chosenCard","apCost","detectLaneForCard","card","T","tag","includes","kind","_action$lane","_influence","lane","newP2Hand","played","splice","newP2Lane","newP2Board","newBoard","newActionPoints","laneName","power","influence","name","playedSpec","slotType","slot","permanentSlots","government","newPermanentSlots","public","state","player","candidates","myInf","opponent","oppInf","currentLead","forEach","idx","score","suggestedLane","undefined","pol","Math","max","spec","bp","floor","random","push","length","sort","a","b","_rolloutScores$get","top","slice","min","rolloutScores","Map","simulate","stateSnapshot","simState","JSON","parse","stringify","targetLane","traps","opp","c","acc","trials","t","set","bestIdx","bestScore","get","_rolloutScores$get2","s","chosen","find","x","best"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/ai/aiPlayer.ts"],"sourcesContent":["import { GameState, Card, Player } from '../types/game';\nimport { sumRow, getCardActionPointCost } from '../utils/gameUtils';\nimport { buildDeckFromEntries } from '../utils/gameUtils';\n\nexport type Difficulty = 'easy' | 'medium' | 'hard';\n\nexport type AIAction =\n  | { type: 'pass' }\n  | { type: 'play'; index: number; lane?: 'innen' | 'aussen' };\n\n// Basic AI player module with three difficulty presets.\n// takeTurn applies a state update via setGameState(prev => newState).\nexport function takeTurn(\n  setGameState: React.Dispatch<React.SetStateAction<GameState>>,\n  difficulty: Difficulty,\n  log: (msg: string) => void\n) {\n  setGameState(prev => {\n    const aiEnabled = prev.aiEnabled?.[2] ?? false;\n    if (!aiEnabled || prev.current !== 2) return prev;\n\n    const hand = prev.hands[2];\n    const playerBoard = prev.board[1];\n    const aiBoard = prev.board[2];\n    const aiAP = prev.actionPoints[2];\n\n    log(` AI(${difficulty}) Analyse: P=${sumRow([...playerBoard.aussen])} vs AI=${sumRow([...aiBoard.aussen])}`);\n\n    if (aiAP <= 0) {\n      log(' AI passt - keine AP mehr.');\n      return { ...prev, passed: { ...prev.passed, 2: true } };\n    }\n\n    // Use the centralized decision helper so tests and takeTurn share logic\n    const action = decideBestAction(prev, 2, difficulty);\n    if (action.type === 'pass') {\n      log(' AI passt - keine guten Aktionen.');\n      return { ...prev, passed: { ...prev.passed, 2: true } };\n    }\n\n    // Execute chosen play\n    const playIndex = action.type === 'play' ? action.index : -1;\n    const chosenCard = prev.hands[2][playIndex];\n    if (!chosenCard) {\n      log(' AI Fehler: Ung羹ltiger Kartenindex, passe.');\n      return { ...prev, passed: { ...prev.passed, 2: true } };\n    }\n\n    const apCost = getCardActionPointCost(chosenCard, prev, 2);\n\n    function detectLaneForCard(card: any): 'innen' | 'aussen' {\n      if (card.T && card.T >= 2) return 'aussen';\n      if (card.tag && ['Staatsoberhaupt', 'Regierungschef', 'Diplomat'].includes(card.tag)) return 'aussen';\n      return 'innen';\n    }\n\n    if (chosenCard.kind === 'pol') {\n      const lane = action.lane ?? detectLaneForCard(chosenCard);\n      const newP2Hand = [...prev.hands[2]];\n      const [played] = newP2Hand.splice(playIndex, 1);\n      const newP2Lane = [...prev.board[2][lane], played];\n      const newP2Board = { ...prev.board[2], [lane]: newP2Lane };\n      const newBoard = { ...prev.board, 2: newP2Board };\n      const newActionPoints = { ...prev.actionPoints, 2: prev.actionPoints[2] - apCost };\n\n      const laneName = lane === 'aussen' ? 'Regierungsreihe' : 'ffentlichkeitsreihe';\n      const power = (played as any).influence ?? 0;\n      log(` AI spielt ${played.name} (${power} Einfluss) nach ${laneName}.`);\n\n      return {\n        ...prev,\n        hands: { ...prev.hands, 2: newP2Hand },\n        board: newBoard,\n        actionPoints: newActionPoints\n      };\n    }\n\n    // spec cards\n    const newP2Hand = [...prev.hands[2]];\n    const [playedSpec] = newP2Hand.splice(playIndex, 1);\n    const newActionPoints = { ...prev.actionPoints, 2: prev.actionPoints[2] - apCost };\n\n    if ((playedSpec as any).type === 'Dauerhaft-Initiative') {\n      const slotType = (playedSpec as any).slot === 'ffentlichkeit' ? 'public' : 'government';\n      if (slotType === 'government' && !prev.permanentSlots[2].government) {\n        const newPermanentSlots = { ...prev.permanentSlots, 2: { ...prev.permanentSlots[2], government: playedSpec } };\n        log(` AI legt ${playedSpec.name} in Regierung Spezial-Slot.`);\n        return { ...prev, hands: { ...prev.hands, 2: newP2Hand }, permanentSlots: newPermanentSlots, actionPoints: newActionPoints };\n      } else if (slotType === 'public' && !prev.permanentSlots[2].public) {\n        const newPermanentSlots = { ...prev.permanentSlots, 2: { ...prev.permanentSlots[2], public: playedSpec } };\n        log(` AI legt ${playedSpec.name} in ffentlichkeit Spezial-Slot.`);\n        return { ...prev, hands: { ...prev.hands, 2: newP2Hand }, permanentSlots: newPermanentSlots, actionPoints: newActionPoints };\n      }\n    }\n\n    log(` AI spielt Spezialkarte ${playedSpec.name}.`);\n    return { ...prev, hands: { ...prev.hands, 2: newP2Hand }, actionPoints: newActionPoints };\n  });\n}\n\n// Expose a light-weight decision helper for tests\nexport function decideBestAction(state: GameState, player: Player, difficulty: Difficulty = 'easy'): AIAction {\n  // reuse takeTurn logic but without mutating state: produce an action suggestions\n  const hand = state.hands[player];\n  const aiAP = state.actionPoints[player];\n  if (aiAP <= 0) return { type: 'pass' };\n  // Policy: maximize influence placed per round. If current lead is already durable, pass.\n  const candidates: Array<{ index: number; card: Card; score: number; lane?: 'innen' | 'aussen' }> = [];\n  const myInf = sumRow([...state.board[player].aussen]);\n  const opponent = player === 1 ? 2 : 1;\n  const oppInf = sumRow([...state.board[opponent].aussen]);\n\n  // If already holding a durable lead, pass\n  const currentLead = myInf - oppInf;\n  if (currentLead >= 3) return { type: 'pass' };\n\n  hand.forEach((card, idx) => {\n    const apCost = getCardActionPointCost(card, state, player);\n    if (apCost > aiAP) return;\n\n    let score = 0;\n    let suggestedLane: 'innen' | 'aussen' | undefined = undefined;\n\n    if (card.kind === 'pol') {\n      const pol = card as any;\n      suggestedLane = pol.tag === 'Staatsoberhaupt' || pol.tag === 'Regierungschef' || pol.tag === 'Diplomat' ? 'aussen' : 'innen';\n      const influence = pol.influence || 0;\n      // Strong preference: influence per AP (primary objective)\n      score = influence / Math.max(1, apCost) * 100;\n      // small bonus for placing into government lane\n      if (suggestedLane === 'aussen') score += 15;\n    } else if (card.kind === 'spec') {\n      const spec = card as any;\n      // Specs less prioritized; interventions get moderate score\n      if (spec.type === 'Intervention') score = 30;\n      else score = 20 + (spec.bp || 0) * 2;\n    }\n\n    // difficulty randomness\n    if (difficulty === 'medium') score += Math.floor(Math.random() * 6) - 2;\n    if (difficulty === 'hard') score += 4;\n\n    candidates.push({ index: idx, card, score, lane: suggestedLane });\n  });\n\n  if (candidates.length === 0) return { type: 'pass' };\n\n  candidates.sort((a, b) => b.score - a.score);\n  // If hard difficulty, run light Monte Carlo rollouts from top candidates\n  if (difficulty === 'hard') {\n    const top = candidates.slice(0, Math.min(4, candidates.length));\n    const rolloutScores: Map<number, number> = new Map();\n\n    const simulate = (stateSnapshot: GameState, playIndex: number, lane?: 'innen' | 'aussen') => {\n      // Very lightweight simulation: apply the play and evaluate immediate board influence difference\n      const simState = JSON.parse(JSON.stringify(stateSnapshot)) as GameState;\n      const card = simState.hands[player][playIndex];\n      const apCost = getCardActionPointCost(card, simState, player);\n\n      // apply simple play\n      simState.actionPoints[player] = Math.max(0, simState.actionPoints[player] - apCost);\n      simState.hands[player].splice(playIndex, 1);\n      if (card.kind === 'pol') {\n        const targetLane = lane ?? ((card as any).tag === 'Staatsoberhaupt' || (card as any).tag === 'Regierungschef' || (card as any).tag === 'Diplomat' ? 'aussen' : 'innen');\n        (simState.board[player] as any)[targetLane].push(card);\n      } else if (card.kind === 'spec' && (card as any).type === 'Intervention') {\n        simState.traps[player].push(card);\n      }\n\n      // Quick eval: difference in government influence\n      const myInf = sumRow([...simState.board[player].aussen]);\n      const opp = player === 1 ? 2 : 1;\n      const oppInf = sumRow([...simState.board[opp].aussen]);\n      return myInf - oppInf;\n    };\n\n    for (const c of top) {\n      let acc = 0;\n      const trials = 6;\n      for (let t = 0; t < trials; t++) {\n        acc += simulate(state, c.index, c.lane);\n      }\n      rolloutScores.set(c.index, acc / trials + c.score);\n    }\n\n    // pick best by rollout-adjusted score\n    let bestIdx = top[0].index;\n    let bestScore = rolloutScores.get(bestIdx) ?? top[0].score;\n    for (const c of top) {\n      const s = rolloutScores.get(c.index) ?? c.score;\n      if (s > bestScore) {\n        bestScore = s;\n        bestIdx = c.index;\n      }\n    }\n\n    const chosen = candidates.find(x => x.index === bestIdx)!;\n    return { type: 'play', index: chosen.index, lane: chosen.lane };\n  }\n\n  const best = candidates[0];\n  return { type: 'play', index: best.index, lane: best.lane };\n}\n\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}