{"ast":null,"code":"// Animation Engine - Fixed-Timestep Event-basiertes System\n// Integriert mit bestehender Game-Engine Event-Queue\n\nimport { ANIMATION_REGISTRY, ANIMATION_CONFIG, getFrameEvents, getCharacterDefinition } from '../data/animationRegistry';\nexport class AnimationEngine {\n  constructor() {\n    this.state = void 0;\n    this.eventQueue = [];\n    this.lastUpdateTime = 0;\n    this.isRunning = false;\n    this.state = {\n      characters: new Map(),\n      projectiles: new Map(),\n      effects: new Map(),\n      globalTime: 0,\n      lastUpdate: 0\n    };\n  }\n\n  // === CORE UPDATE LOOP ===\n\n  update(currentTime) {\n    // Auto-start if not running\n    if (!this.isRunning) {\n      this.start();\n    }\n\n    // Fixed-Timestep Update\n    const deltaTime = currentTime - this.lastUpdateTime;\n    if (deltaTime >= ANIMATION_CONFIG.fixedTimestep) {\n      this.fixedUpdate();\n      this.lastUpdateTime = currentTime;\n    }\n  }\n  fixedUpdate() {\n    this.state.globalTime += ANIMATION_CONFIG.fixedTimestep;\n\n    // Update Characters\n    this.updateCharacters();\n\n    // Update Projectiles\n    this.updateProjectiles();\n\n    // Update Effects\n    this.updateEffects();\n\n    // Process Animation Events\n    this.processAnimationEvents();\n  }\n\n  // === CHARACTER MANAGEMENT ===\n\n  createCharacter(id, position, facing = 1) {\n    const character = {\n      id,\n      position: {\n        ...position\n      },\n      facing,\n      currentAnimation: 'idle',\n      animationFrame: 0,\n      animationTime: 0\n    };\n    this.state.characters.set(id, character);\n  }\n  playAnimation(characterId, animationName) {\n    const character = this.state.characters.get(characterId);\n    if (!character) return false;\n    const animationData = ANIMATION_REGISTRY[animationName];\n    if (!animationData) return false;\n\n    // Reset animation state\n    character.currentAnimation = animationName;\n    character.animationFrame = 0;\n    character.animationTime = 0;\n    return true;\n  }\n  updateCharacters() {\n    this.state.characters.forEach((character, id) => {\n      this.updateCharacterAnimation(character);\n    });\n  }\n  updateCharacterAnimation(character) {\n    const animationData = ANIMATION_REGISTRY[character.currentAnimation];\n    if (!animationData) return;\n\n    // Calculate frame time\n    const frameTime = 1000 / animationData.fps;\n    const newFrame = Math.floor(character.animationTime / frameTime);\n\n    // Check for frame change\n    if (newFrame !== character.animationFrame) {\n      const oldFrame = character.animationFrame;\n      character.animationFrame = newFrame;\n\n      // Process frame events\n      this.processFrameEvents(character, oldFrame, newFrame);\n    }\n\n    // Handle animation completion\n    if (character.animationFrame >= animationData.frames) {\n      if (animationData.loop) {\n        character.animationFrame = 0;\n        character.animationTime = 0;\n      } else {\n        // Animation complete - fire complete event\n        this.enqueueAnimationEvent(character.id, {\n          frame: animationData.frames - 1,\n          type: 'complete',\n          data: {}\n        });\n      }\n    }\n\n    // Update animation time\n    character.animationTime += ANIMATION_CONFIG.fixedTimestep;\n  }\n\n  // === PROJECTILE MANAGEMENT ===\n\n  createProjectile(id, position, velocity, owner, damage = 15, knockback = {\n    x: 30,\n    y: -15\n  }, hitstun = 200) {\n    const projectile = {\n      id,\n      position: {\n        ...position\n      },\n      facing: velocity.x > 0 ? 1 : -1,\n      currentAnimation: 'projectile',\n      animationFrame: 0,\n      animationTime: 0,\n      velocity: {\n        ...velocity\n      },\n      speed: Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y),\n      maxLifetime: 1200,\n      // 1.2s fail-safe\n      lifetime: 0,\n      damage,\n      knockback,\n      hitstun,\n      owner\n    };\n    this.state.projectiles.set(id, projectile);\n  }\n  updateProjectiles() {\n    this.state.projectiles.forEach((projectile, id) => {\n      this.updateProjectile(projectile);\n    });\n  }\n  updateProjectile(projectile) {\n    // Update position\n    if (projectile.velocity) {\n      projectile.position.x += projectile.velocity.x * (ANIMATION_CONFIG.fixedTimestep / 1000);\n      projectile.position.y += projectile.velocity.y * (ANIMATION_CONFIG.fixedTimestep / 1000);\n    }\n\n    // Update lifetime\n    if (projectile.lifetime !== undefined) {\n      projectile.lifetime += ANIMATION_CONFIG.fixedTimestep;\n\n      // Check lifetime\n      if (projectile.lifetime >= projectile.maxLifetime) {\n        this.destroyProjectile(projectile.id);\n        return;\n      }\n    }\n\n    // Update animation\n    this.updateCharacterAnimation(projectile);\n\n    // Check collisions\n    this.checkProjectileCollisions(projectile);\n  }\n  checkProjectileCollisions(projectile) {\n    // Check against all characters (except owner)\n    this.state.characters.forEach((character, characterId) => {\n      if (characterId === projectile.owner) return;\n\n      // Simple collision check (can be expanded with proper hitbox system)\n      const distance = Math.sqrt(Math.pow(projectile.position.x - character.position.x, 2) + Math.pow(projectile.position.y - character.position.y, 2));\n      if (distance < 50) {\n        // Simple radius collision\n        this.hitCharacter(characterId, projectile);\n        this.destroyProjectile(projectile.id);\n        return;\n      }\n    });\n  }\n  hitCharacter(characterId, projectile) {\n    // Create blast effect at hit position\n    const blastId = `blast_${Date.now()}_${Math.random()}`;\n    this.createEffect(blastId, projectile.position, 'blast');\n  }\n  destroyProjectile(projectileId) {\n    const projectile = this.state.projectiles.get(projectileId);\n    if (!projectile) return;\n\n    // Switch to die animation briefly\n    projectile.currentAnimation = 'die';\n    projectile.animationFrame = 0;\n    projectile.animationTime = 0;\n\n    // Remove after die animation completes\n    setTimeout(() => {\n      this.state.projectiles.delete(projectileId);\n    }, 150); // 3 frames at 20fps\n  }\n\n  // === EFFECT MANAGEMENT ===\n\n  createEffect(id, position, animationName) {\n    const effect = {\n      id,\n      position: {\n        ...position\n      },\n      facing: 1,\n      currentAnimation: animationName,\n      animationFrame: 0,\n      animationTime: 0\n    };\n    this.state.effects.set(id, effect);\n  }\n  updateEffects() {\n    this.state.effects.forEach((effect, id) => {\n      this.updateCharacterAnimation(effect);\n    });\n  }\n\n  // === EVENT PROCESSING ===\n\n  processFrameEvents(character, oldFrame, newFrame) {\n    const animationData = ANIMATION_REGISTRY[character.currentAnimation];\n    if (!animationData || !animationData.events) return;\n\n    // Process events for all frames between oldFrame and newFrame\n    for (let frame = oldFrame + 1; frame <= newFrame; frame++) {\n      const events = getFrameEvents(character.currentAnimation, frame);\n      for (const event of events) {\n        this.enqueueAnimationEvent(character.id, event);\n      }\n    }\n  }\n  enqueueAnimationEvent(characterId, event) {\n    const animationEvent = {\n      type: 'ANIMATION_EVENT',\n      characterId,\n      event,\n      timestamp: this.state.globalTime\n    };\n    this.eventQueue.push(animationEvent);\n  }\n  processAnimationEvents() {\n    while (this.eventQueue.length > 0) {\n      const event = this.eventQueue.shift();\n      this.handleAnimationEvent(event);\n    }\n  }\n  handleAnimationEvent(event) {\n    switch (event.event.type) {\n      case 'spawnProjectile':\n        this.handleSpawnProjectile(event);\n        break;\n      case 'playSfx':\n        this.handlePlaySfx(event);\n        break;\n      case 'emitFx':\n        this.handleEmitFx(event);\n        break;\n      case 'dealDamage':\n        this.handleDealDamage(event);\n        break;\n      case 'cameraShake':\n        this.handleCameraShake(event);\n        break;\n      case 'complete':\n        this.handleAnimationComplete(event);\n        break;\n    }\n  }\n  handleSpawnProjectile(event) {\n    const character = this.state.characters.get(event.characterId);\n    if (!character) return;\n    const characterDef = getCharacterDefinition(character.id);\n    if (!characterDef || !characterDef.muzzleOffset) return;\n\n    // Calculate muzzle position\n    const muzzleOffset = characterDef.muzzleOffset;\n    const facingMultiplier = character.facing;\n    const projectilePosition = {\n      x: character.position.x + muzzleOffset.x * facingMultiplier,\n      y: character.position.y + muzzleOffset.y\n    };\n\n    // Calculate velocity\n    const speed = 1000; // px/s\n    const velocity = {\n      x: speed * facingMultiplier,\n      y: 0\n    };\n\n    // Create projectile\n    const projectileId = `projectile_${Date.now()}_${Math.random()}`;\n    this.createProjectile(projectileId, projectilePosition, velocity, character.id);\n  }\n  handlePlaySfx(event) {\n    var _event$event$data;\n    // Integrate with existing audio system\n    console.log(`SFX: ${(_event$event$data = event.event.data) === null || _event$event$data === void 0 ? void 0 : _event$event$data.sound} for ${event.characterId}`);\n  }\n  handleEmitFx(event) {\n    var _event$event$data2;\n    const character = this.state.characters.get(event.characterId);\n    if (!character) return;\n    const effectId = `fx_${Date.now()}_${Math.random()}`;\n    this.createEffect(effectId, character.position, ((_event$event$data2 = event.event.data) === null || _event$event$data2 === void 0 ? void 0 : _event$event$data2.actor) || 'blast');\n  }\n  handleDealDamage(event) {\n    var _event$event$data3;\n    // This would integrate with the game's damage system\n    console.log(`Damage: ${(_event$event$data3 = event.event.data) === null || _event$event$data3 === void 0 ? void 0 : _event$event$data3.amount} from ${event.characterId}`);\n  }\n  handleCameraShake(event) {\n    var _event$event$data4, _event$event$data5;\n    // This would integrate with the camera system\n    console.log(`Camera Shake: ${(_event$event$data4 = event.event.data) === null || _event$event$data4 === void 0 ? void 0 : _event$event$data4.intensity} for ${(_event$event$data5 = event.event.data) === null || _event$event$data5 === void 0 ? void 0 : _event$event$data5.duration}ms`);\n  }\n  handleAnimationComplete(event) {\n    const character = this.state.characters.get(event.characterId);\n    if (!character) return;\n\n    // Return to idle or handle completion logic\n    if (character.currentAnimation !== 'idle') {\n      this.playAnimation(event.characterId, 'idle');\n    }\n  }\n\n  // === PUBLIC API ===\n\n  start() {\n    this.isRunning = true;\n    this.lastUpdateTime = performance.now();\n  }\n  stop() {\n    this.isRunning = false;\n  }\n  getState() {\n    return {\n      ...this.state,\n      characters: new Map(this.state.characters),\n      projectiles: new Map(this.state.projectiles),\n      effects: new Map(this.state.effects)\n    };\n  }\n\n  // Get character by ID\n  getCharacter(id) {\n    return this.state.characters.get(id);\n  }\n\n  // Get all characters\n  getCharacters() {\n    return Array.from(this.state.characters.values());\n  }\n\n  // Get all projectiles\n  getProjectiles() {\n    return Array.from(this.state.projectiles.values());\n  }\n\n  // Get all effects\n  getEffects() {\n    return Array.from(this.state.effects.values());\n  }\n}","map":{"version":3,"names":["ANIMATION_REGISTRY","ANIMATION_CONFIG","getFrameEvents","getCharacterDefinition","AnimationEngine","constructor","state","eventQueue","lastUpdateTime","isRunning","characters","Map","projectiles","effects","globalTime","lastUpdate","update","currentTime","start","deltaTime","fixedTimestep","fixedUpdate","updateCharacters","updateProjectiles","updateEffects","processAnimationEvents","createCharacter","id","position","facing","character","currentAnimation","animationFrame","animationTime","set","playAnimation","characterId","animationName","get","animationData","forEach","updateCharacterAnimation","frameTime","fps","newFrame","Math","floor","oldFrame","processFrameEvents","frames","loop","enqueueAnimationEvent","frame","type","data","createProjectile","velocity","owner","damage","knockback","x","y","hitstun","projectile","speed","sqrt","maxLifetime","lifetime","updateProjectile","undefined","destroyProjectile","checkProjectileCollisions","distance","pow","hitCharacter","blastId","Date","now","random","createEffect","projectileId","setTimeout","delete","effect","events","event","animationEvent","timestamp","push","length","shift","handleAnimationEvent","handleSpawnProjectile","handlePlaySfx","handleEmitFx","handleDealDamage","handleCameraShake","handleAnimationComplete","characterDef","muzzleOffset","facingMultiplier","projectilePosition","_event$event$data","console","log","sound","_event$event$data2","effectId","actor","_event$event$data3","amount","_event$event$data4","_event$event$data5","intensity","duration","performance","stop","getState","getCharacter","getCharacters","Array","from","values","getProjectiles","getEffects"],"sources":["C:/Users/skank/Videos/Cards/Milchcards/src/engine/animationEngine.ts"],"sourcesContent":["// Animation Engine - Fixed-Timestep Event-basiertes System\r\n// Integriert mit bestehender Game-Engine Event-Queue\r\n\r\nimport type {\r\n  AnimationSystemState,\r\n  CharacterState,\r\n  ProjectileState,\r\n  AnimationEvent,\r\n  Vector2,\r\n  FrameEvent\r\n} from '../types/animation';\r\nimport {\r\n  ANIMATION_REGISTRY,\r\n  ANIMATION_CONFIG,\r\n  getFrameEvents,\r\n  getFrameHitboxes,\r\n  getCharacterDefinition\r\n} from '../data/animationRegistry';\r\n\r\nexport class AnimationEngine {\r\n  private state: AnimationSystemState;\r\n  private eventQueue: AnimationEvent[] = [];\r\n  private lastUpdateTime: number = 0;\r\n  private isRunning: boolean = false;\r\n\r\n  constructor() {\r\n    this.state = {\r\n      characters: new Map(),\r\n      projectiles: new Map(),\r\n      effects: new Map(),\r\n      globalTime: 0,\r\n      lastUpdate: 0\r\n    };\r\n  }\r\n\r\n  // === CORE UPDATE LOOP ===\r\n\r\n  update(currentTime: number): void {\r\n    // Auto-start if not running\r\n    if (!this.isRunning) {\r\n      this.start();\r\n    }\r\n\r\n    // Fixed-Timestep Update\r\n    const deltaTime = currentTime - this.lastUpdateTime;\r\n    if (deltaTime >= ANIMATION_CONFIG.fixedTimestep) {\r\n      this.fixedUpdate();\r\n      this.lastUpdateTime = currentTime;\r\n    }\r\n  }\r\n\r\n  private fixedUpdate(): void {\r\n    this.state.globalTime += ANIMATION_CONFIG.fixedTimestep;\r\n\r\n    // Update Characters\r\n    this.updateCharacters();\r\n\r\n    // Update Projectiles\r\n    this.updateProjectiles();\r\n\r\n    // Update Effects\r\n    this.updateEffects();\r\n\r\n    // Process Animation Events\r\n    this.processAnimationEvents();\r\n  }\r\n\r\n  // === CHARACTER MANAGEMENT ===\r\n\r\n  createCharacter(id: string, position: Vector2, facing: -1 | 1 = 1): void {\r\n    const character: CharacterState = {\r\n      id,\r\n      position: { ...position },\r\n      facing,\r\n      currentAnimation: 'idle',\r\n      animationFrame: 0,\r\n      animationTime: 0\r\n    };\r\n\r\n    this.state.characters.set(id, character);\r\n  }\r\n\r\n  playAnimation(characterId: string, animationName: string): boolean {\r\n    const character = this.state.characters.get(characterId);\r\n    if (!character) return false;\r\n\r\n    const animationData = ANIMATION_REGISTRY[animationName];\r\n    if (!animationData) return false;\r\n\r\n    // Reset animation state\r\n    character.currentAnimation = animationName;\r\n    character.animationFrame = 0;\r\n    character.animationTime = 0;\r\n\r\n    return true;\r\n  }\r\n\r\n  private updateCharacters(): void {\r\n    this.state.characters.forEach((character, id) => {\r\n      this.updateCharacterAnimation(character);\r\n    });\r\n  }\r\n\r\n  private updateCharacterAnimation(character: CharacterState): void {\r\n    const animationData = ANIMATION_REGISTRY[character.currentAnimation];\r\n    if (!animationData) return;\r\n\r\n    // Calculate frame time\r\n    const frameTime = 1000 / animationData.fps;\r\n    const newFrame = Math.floor(character.animationTime / frameTime);\r\n\r\n    // Check for frame change\r\n    if (newFrame !== character.animationFrame) {\r\n      const oldFrame = character.animationFrame;\r\n      character.animationFrame = newFrame;\r\n\r\n      // Process frame events\r\n      this.processFrameEvents(character, oldFrame, newFrame);\r\n    }\r\n\r\n    // Handle animation completion\r\n    if (character.animationFrame >= animationData.frames) {\r\n      if (animationData.loop) {\r\n        character.animationFrame = 0;\r\n        character.animationTime = 0;\r\n      } else {\r\n        // Animation complete - fire complete event\r\n        this.enqueueAnimationEvent(character.id, {\r\n          frame: animationData.frames - 1,\r\n          type: 'complete',\r\n          data: {}\r\n        });\r\n      }\r\n    }\r\n\r\n    // Update animation time\r\n    character.animationTime += ANIMATION_CONFIG.fixedTimestep;\r\n  }\r\n\r\n  // === PROJECTILE MANAGEMENT ===\r\n\r\n  createProjectile(\r\n    id: string,\r\n    position: Vector2,\r\n    velocity: Vector2,\r\n    owner: string,\r\n    damage: number = 15,\r\n    knockback: Vector2 = { x: 30, y: -15 },\r\n    hitstun: number = 200\r\n  ): void {\r\n    const projectile: ProjectileState = {\r\n      id,\r\n      position: { ...position },\r\n      facing: velocity.x > 0 ? 1 : -1,\r\n      currentAnimation: 'projectile',\r\n      animationFrame: 0,\r\n      animationTime: 0,\r\n      velocity: { ...velocity },\r\n      speed: Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y),\r\n      maxLifetime: 1200, // 1.2s fail-safe\r\n      lifetime: 0,\r\n      damage,\r\n      knockback,\r\n      hitstun,\r\n      owner\r\n    };\r\n\r\n    this.state.projectiles.set(id, projectile);\r\n  }\r\n\r\n  private updateProjectiles(): void {\r\n    this.state.projectiles.forEach((projectile, id) => {\r\n      this.updateProjectile(projectile);\r\n    });\r\n  }\r\n\r\n  private updateProjectile(projectile: ProjectileState): void {\r\n    // Update position\r\n    if (projectile.velocity) {\r\n      projectile.position.x += projectile.velocity.x * (ANIMATION_CONFIG.fixedTimestep / 1000);\r\n      projectile.position.y += projectile.velocity.y * (ANIMATION_CONFIG.fixedTimestep / 1000);\r\n    }\r\n\r\n    // Update lifetime\r\n    if (projectile.lifetime !== undefined) {\r\n      projectile.lifetime += ANIMATION_CONFIG.fixedTimestep;\r\n\r\n      // Check lifetime\r\n      if (projectile.lifetime >= projectile.maxLifetime) {\r\n        this.destroyProjectile(projectile.id);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Update animation\r\n    this.updateCharacterAnimation(projectile);\r\n\r\n    // Check collisions\r\n    this.checkProjectileCollisions(projectile);\r\n  }\r\n\r\n  private checkProjectileCollisions(projectile: ProjectileState): void {\r\n    // Check against all characters (except owner)\r\n    this.state.characters.forEach((character, characterId) => {\r\n      if (characterId === projectile.owner) return;\r\n\r\n      // Simple collision check (can be expanded with proper hitbox system)\r\n      const distance = Math.sqrt(\r\n        Math.pow(projectile.position.x - character.position.x, 2) +\r\n        Math.pow(projectile.position.y - character.position.y, 2)\r\n      );\r\n\r\n      if (distance < 50) { // Simple radius collision\r\n        this.hitCharacter(characterId, projectile);\r\n        this.destroyProjectile(projectile.id);\r\n        return;\r\n      }\r\n    });\r\n  }\r\n\r\n  private hitCharacter(characterId: string, projectile: ProjectileState): void {\r\n    // Create blast effect at hit position\r\n    const blastId = `blast_${Date.now()}_${Math.random()}`;\r\n    this.createEffect(blastId, projectile.position, 'blast');\r\n  }\r\n\r\n  private destroyProjectile(projectileId: string): void {\r\n    const projectile = this.state.projectiles.get(projectileId);\r\n    if (!projectile) return;\r\n\r\n    // Switch to die animation briefly\r\n    projectile.currentAnimation = 'die';\r\n    projectile.animationFrame = 0;\r\n    projectile.animationTime = 0;\r\n\r\n    // Remove after die animation completes\r\n    setTimeout(() => {\r\n      this.state.projectiles.delete(projectileId);\r\n    }, 150); // 3 frames at 20fps\r\n  }\r\n\r\n  // === EFFECT MANAGEMENT ===\r\n\r\n  createEffect(id: string, position: Vector2, animationName: string): void {\r\n    const effect: CharacterState = {\r\n      id,\r\n      position: { ...position },\r\n      facing: 1,\r\n      currentAnimation: animationName,\r\n      animationFrame: 0,\r\n      animationTime: 0\r\n    };\r\n\r\n    this.state.effects.set(id, effect);\r\n  }\r\n\r\n  private updateEffects(): void {\r\n    this.state.effects.forEach((effect, id) => {\r\n      this.updateCharacterAnimation(effect);\r\n    });\r\n  }\r\n\r\n  // === EVENT PROCESSING ===\r\n\r\n  private processFrameEvents(character: CharacterState, oldFrame: number, newFrame: number): void {\r\n    const animationData = ANIMATION_REGISTRY[character.currentAnimation];\r\n    if (!animationData || !animationData.events) return;\r\n\r\n    // Process events for all frames between oldFrame and newFrame\r\n    for (let frame = oldFrame + 1; frame <= newFrame; frame++) {\r\n      const events = getFrameEvents(character.currentAnimation, frame);\r\n      for (const event of events) {\r\n        this.enqueueAnimationEvent(character.id, event);\r\n      }\r\n    }\r\n  }\r\n\r\n  private enqueueAnimationEvent(characterId: string, event: FrameEvent): void {\r\n    const animationEvent: AnimationEvent = {\r\n      type: 'ANIMATION_EVENT',\r\n      characterId,\r\n      event,\r\n      timestamp: this.state.globalTime\r\n    };\r\n\r\n    this.eventQueue.push(animationEvent);\r\n  }\r\n\r\n  private processAnimationEvents(): void {\r\n    while (this.eventQueue.length > 0) {\r\n      const event = this.eventQueue.shift()!;\r\n      this.handleAnimationEvent(event);\r\n    }\r\n  }\r\n\r\n  private handleAnimationEvent(event: AnimationEvent): void {\r\n    switch (event.event.type) {\r\n      case 'spawnProjectile':\r\n        this.handleSpawnProjectile(event);\r\n        break;\r\n      case 'playSfx':\r\n        this.handlePlaySfx(event);\r\n        break;\r\n      case 'emitFx':\r\n        this.handleEmitFx(event);\r\n        break;\r\n      case 'dealDamage':\r\n        this.handleDealDamage(event);\r\n        break;\r\n      case 'cameraShake':\r\n        this.handleCameraShake(event);\r\n        break;\r\n      case 'complete':\r\n        this.handleAnimationComplete(event);\r\n        break;\r\n    }\r\n  }\r\n\r\n  private handleSpawnProjectile(event: AnimationEvent): void {\r\n    const character = this.state.characters.get(event.characterId);\r\n    if (!character) return;\r\n\r\n    const characterDef = getCharacterDefinition(character.id);\r\n    if (!characterDef || !characterDef.muzzleOffset) return;\r\n\r\n    // Calculate muzzle position\r\n    const muzzleOffset = characterDef.muzzleOffset;\r\n    const facingMultiplier = character.facing;\r\n\r\n    const projectilePosition: Vector2 = {\r\n      x: character.position.x + (muzzleOffset.x * facingMultiplier),\r\n      y: character.position.y + muzzleOffset.y\r\n    };\r\n\r\n    // Calculate velocity\r\n    const speed = 1000; // px/s\r\n    const velocity: Vector2 = {\r\n      x: speed * facingMultiplier,\r\n      y: 0\r\n    };\r\n\r\n    // Create projectile\r\n    const projectileId = `projectile_${Date.now()}_${Math.random()}`;\r\n    this.createProjectile(projectileId, projectilePosition, velocity, character.id);\r\n  }\r\n\r\n  private handlePlaySfx(event: AnimationEvent): void {\r\n    // Integrate with existing audio system\r\n    console.log(`SFX: ${event.event.data?.sound} for ${event.characterId}`);\r\n  }\r\n\r\n  private handleEmitFx(event: AnimationEvent): void {\r\n    const character = this.state.characters.get(event.characterId);\r\n    if (!character) return;\r\n\r\n    const effectId = `fx_${Date.now()}_${Math.random()}`;\r\n    this.createEffect(effectId, character.position, event.event.data?.actor || 'blast');\r\n  }\r\n\r\n  private handleDealDamage(event: AnimationEvent): void {\r\n    // This would integrate with the game's damage system\r\n    console.log(`Damage: ${event.event.data?.amount} from ${event.characterId}`);\r\n  }\r\n\r\n  private handleCameraShake(event: AnimationEvent): void {\r\n    // This would integrate with the camera system\r\n    console.log(`Camera Shake: ${event.event.data?.intensity} for ${event.event.data?.duration}ms`);\r\n  }\r\n\r\n  private handleAnimationComplete(event: AnimationEvent): void {\r\n    const character = this.state.characters.get(event.characterId);\r\n    if (!character) return;\r\n\r\n    // Return to idle or handle completion logic\r\n    if (character.currentAnimation !== 'idle') {\r\n      this.playAnimation(event.characterId, 'idle');\r\n    }\r\n  }\r\n\r\n  // === PUBLIC API ===\r\n\r\n  start(): void {\r\n    this.isRunning = true;\r\n    this.lastUpdateTime = performance.now();\r\n  }\r\n\r\n  stop(): void {\r\n    this.isRunning = false;\r\n  }\r\n\r\n  getState(): AnimationSystemState {\r\n    return {\r\n      ...this.state,\r\n      characters: new Map(this.state.characters),\r\n      projectiles: new Map(this.state.projectiles),\r\n      effects: new Map(this.state.effects)\r\n    };\r\n  }\r\n\r\n  // Get character by ID\r\n  getCharacter(id: string): CharacterState | undefined {\r\n    return this.state.characters.get(id);\r\n  }\r\n\r\n  // Get all characters\r\n  getCharacters(): CharacterState[] {\r\n    return Array.from(this.state.characters.values());\r\n  }\r\n\r\n  // Get all projectiles\r\n  getProjectiles(): ProjectileState[] {\r\n    return Array.from(this.state.projectiles.values());\r\n  }\r\n\r\n  // Get all effects\r\n  getEffects(): CharacterState[] {\r\n    return Array.from(this.state.effects.values());\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;;AAUA,SACEA,kBAAkB,EAClBC,gBAAgB,EAChBC,cAAc,EAEdC,sBAAsB,QACjB,2BAA2B;AAElC,OAAO,MAAMC,eAAe,CAAC;EAM3BC,WAAWA,CAAA,EAAG;IAAA,KALNC,KAAK;IAAA,KACLC,UAAU,GAAqB,EAAE;IAAA,KACjCC,cAAc,GAAW,CAAC;IAAA,KAC1BC,SAAS,GAAY,KAAK;IAGhC,IAAI,CAACH,KAAK,GAAG;MACXI,UAAU,EAAE,IAAIC,GAAG,CAAC,CAAC;MACrBC,WAAW,EAAE,IAAID,GAAG,CAAC,CAAC;MACtBE,OAAO,EAAE,IAAIF,GAAG,CAAC,CAAC;MAClBG,UAAU,EAAE,CAAC;MACbC,UAAU,EAAE;IACd,CAAC;EACH;;EAEA;;EAEAC,MAAMA,CAACC,WAAmB,EAAQ;IAChC;IACA,IAAI,CAAC,IAAI,CAACR,SAAS,EAAE;MACnB,IAAI,CAACS,KAAK,CAAC,CAAC;IACd;;IAEA;IACA,MAAMC,SAAS,GAAGF,WAAW,GAAG,IAAI,CAACT,cAAc;IACnD,IAAIW,SAAS,IAAIlB,gBAAgB,CAACmB,aAAa,EAAE;MAC/C,IAAI,CAACC,WAAW,CAAC,CAAC;MAClB,IAAI,CAACb,cAAc,GAAGS,WAAW;IACnC;EACF;EAEQI,WAAWA,CAAA,EAAS;IAC1B,IAAI,CAACf,KAAK,CAACQ,UAAU,IAAIb,gBAAgB,CAACmB,aAAa;;IAEvD;IACA,IAAI,CAACE,gBAAgB,CAAC,CAAC;;IAEvB;IACA,IAAI,CAACC,iBAAiB,CAAC,CAAC;;IAExB;IACA,IAAI,CAACC,aAAa,CAAC,CAAC;;IAEpB;IACA,IAAI,CAACC,sBAAsB,CAAC,CAAC;EAC/B;;EAEA;;EAEAC,eAAeA,CAACC,EAAU,EAAEC,QAAiB,EAAEC,MAAc,GAAG,CAAC,EAAQ;IACvE,MAAMC,SAAyB,GAAG;MAChCH,EAAE;MACFC,QAAQ,EAAE;QAAE,GAAGA;MAAS,CAAC;MACzBC,MAAM;MACNE,gBAAgB,EAAE,MAAM;MACxBC,cAAc,EAAE,CAAC;MACjBC,aAAa,EAAE;IACjB,CAAC;IAED,IAAI,CAAC3B,KAAK,CAACI,UAAU,CAACwB,GAAG,CAACP,EAAE,EAAEG,SAAS,CAAC;EAC1C;EAEAK,aAAaA,CAACC,WAAmB,EAAEC,aAAqB,EAAW;IACjE,MAAMP,SAAS,GAAG,IAAI,CAACxB,KAAK,CAACI,UAAU,CAAC4B,GAAG,CAACF,WAAW,CAAC;IACxD,IAAI,CAACN,SAAS,EAAE,OAAO,KAAK;IAE5B,MAAMS,aAAa,GAAGvC,kBAAkB,CAACqC,aAAa,CAAC;IACvD,IAAI,CAACE,aAAa,EAAE,OAAO,KAAK;;IAEhC;IACAT,SAAS,CAACC,gBAAgB,GAAGM,aAAa;IAC1CP,SAAS,CAACE,cAAc,GAAG,CAAC;IAC5BF,SAAS,CAACG,aAAa,GAAG,CAAC;IAE3B,OAAO,IAAI;EACb;EAEQX,gBAAgBA,CAAA,EAAS;IAC/B,IAAI,CAAChB,KAAK,CAACI,UAAU,CAAC8B,OAAO,CAAC,CAACV,SAAS,EAAEH,EAAE,KAAK;MAC/C,IAAI,CAACc,wBAAwB,CAACX,SAAS,CAAC;IAC1C,CAAC,CAAC;EACJ;EAEQW,wBAAwBA,CAACX,SAAyB,EAAQ;IAChE,MAAMS,aAAa,GAAGvC,kBAAkB,CAAC8B,SAAS,CAACC,gBAAgB,CAAC;IACpE,IAAI,CAACQ,aAAa,EAAE;;IAEpB;IACA,MAAMG,SAAS,GAAG,IAAI,GAAGH,aAAa,CAACI,GAAG;IAC1C,MAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAAChB,SAAS,CAACG,aAAa,GAAGS,SAAS,CAAC;;IAEhE;IACA,IAAIE,QAAQ,KAAKd,SAAS,CAACE,cAAc,EAAE;MACzC,MAAMe,QAAQ,GAAGjB,SAAS,CAACE,cAAc;MACzCF,SAAS,CAACE,cAAc,GAAGY,QAAQ;;MAEnC;MACA,IAAI,CAACI,kBAAkB,CAAClB,SAAS,EAAEiB,QAAQ,EAAEH,QAAQ,CAAC;IACxD;;IAEA;IACA,IAAId,SAAS,CAACE,cAAc,IAAIO,aAAa,CAACU,MAAM,EAAE;MACpD,IAAIV,aAAa,CAACW,IAAI,EAAE;QACtBpB,SAAS,CAACE,cAAc,GAAG,CAAC;QAC5BF,SAAS,CAACG,aAAa,GAAG,CAAC;MAC7B,CAAC,MAAM;QACL;QACA,IAAI,CAACkB,qBAAqB,CAACrB,SAAS,CAACH,EAAE,EAAE;UACvCyB,KAAK,EAAEb,aAAa,CAACU,MAAM,GAAG,CAAC;UAC/BI,IAAI,EAAE,UAAU;UAChBC,IAAI,EAAE,CAAC;QACT,CAAC,CAAC;MACJ;IACF;;IAEA;IACAxB,SAAS,CAACG,aAAa,IAAIhC,gBAAgB,CAACmB,aAAa;EAC3D;;EAEA;;EAEAmC,gBAAgBA,CACd5B,EAAU,EACVC,QAAiB,EACjB4B,QAAiB,EACjBC,KAAa,EACbC,MAAc,GAAG,EAAE,EACnBC,SAAkB,GAAG;IAAEC,CAAC,EAAE,EAAE;IAAEC,CAAC,EAAE,CAAC;EAAG,CAAC,EACtCC,OAAe,GAAG,GAAG,EACf;IACN,MAAMC,UAA2B,GAAG;MAClCpC,EAAE;MACFC,QAAQ,EAAE;QAAE,GAAGA;MAAS,CAAC;MACzBC,MAAM,EAAE2B,QAAQ,CAACI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;MAC/B7B,gBAAgB,EAAE,YAAY;MAC9BC,cAAc,EAAE,CAAC;MACjBC,aAAa,EAAE,CAAC;MAChBuB,QAAQ,EAAE;QAAE,GAAGA;MAAS,CAAC;MACzBQ,KAAK,EAAEnB,IAAI,CAACoB,IAAI,CAACT,QAAQ,CAACI,CAAC,GAAGJ,QAAQ,CAACI,CAAC,GAAGJ,QAAQ,CAACK,CAAC,GAAGL,QAAQ,CAACK,CAAC,CAAC;MACnEK,WAAW,EAAE,IAAI;MAAE;MACnBC,QAAQ,EAAE,CAAC;MACXT,MAAM;MACNC,SAAS;MACTG,OAAO;MACPL;IACF,CAAC;IAED,IAAI,CAACnD,KAAK,CAACM,WAAW,CAACsB,GAAG,CAACP,EAAE,EAAEoC,UAAU,CAAC;EAC5C;EAEQxC,iBAAiBA,CAAA,EAAS;IAChC,IAAI,CAACjB,KAAK,CAACM,WAAW,CAAC4B,OAAO,CAAC,CAACuB,UAAU,EAAEpC,EAAE,KAAK;MACjD,IAAI,CAACyC,gBAAgB,CAACL,UAAU,CAAC;IACnC,CAAC,CAAC;EACJ;EAEQK,gBAAgBA,CAACL,UAA2B,EAAQ;IAC1D;IACA,IAAIA,UAAU,CAACP,QAAQ,EAAE;MACvBO,UAAU,CAACnC,QAAQ,CAACgC,CAAC,IAAIG,UAAU,CAACP,QAAQ,CAACI,CAAC,IAAI3D,gBAAgB,CAACmB,aAAa,GAAG,IAAI,CAAC;MACxF2C,UAAU,CAACnC,QAAQ,CAACiC,CAAC,IAAIE,UAAU,CAACP,QAAQ,CAACK,CAAC,IAAI5D,gBAAgB,CAACmB,aAAa,GAAG,IAAI,CAAC;IAC1F;;IAEA;IACA,IAAI2C,UAAU,CAACI,QAAQ,KAAKE,SAAS,EAAE;MACrCN,UAAU,CAACI,QAAQ,IAAIlE,gBAAgB,CAACmB,aAAa;;MAErD;MACA,IAAI2C,UAAU,CAACI,QAAQ,IAAIJ,UAAU,CAACG,WAAW,EAAE;QACjD,IAAI,CAACI,iBAAiB,CAACP,UAAU,CAACpC,EAAE,CAAC;QACrC;MACF;IACF;;IAEA;IACA,IAAI,CAACc,wBAAwB,CAACsB,UAAU,CAAC;;IAEzC;IACA,IAAI,CAACQ,yBAAyB,CAACR,UAAU,CAAC;EAC5C;EAEQQ,yBAAyBA,CAACR,UAA2B,EAAQ;IACnE;IACA,IAAI,CAACzD,KAAK,CAACI,UAAU,CAAC8B,OAAO,CAAC,CAACV,SAAS,EAAEM,WAAW,KAAK;MACxD,IAAIA,WAAW,KAAK2B,UAAU,CAACN,KAAK,EAAE;;MAEtC;MACA,MAAMe,QAAQ,GAAG3B,IAAI,CAACoB,IAAI,CACxBpB,IAAI,CAAC4B,GAAG,CAACV,UAAU,CAACnC,QAAQ,CAACgC,CAAC,GAAG9B,SAAS,CAACF,QAAQ,CAACgC,CAAC,EAAE,CAAC,CAAC,GACzDf,IAAI,CAAC4B,GAAG,CAACV,UAAU,CAACnC,QAAQ,CAACiC,CAAC,GAAG/B,SAAS,CAACF,QAAQ,CAACiC,CAAC,EAAE,CAAC,CAC1D,CAAC;MAED,IAAIW,QAAQ,GAAG,EAAE,EAAE;QAAE;QACnB,IAAI,CAACE,YAAY,CAACtC,WAAW,EAAE2B,UAAU,CAAC;QAC1C,IAAI,CAACO,iBAAiB,CAACP,UAAU,CAACpC,EAAE,CAAC;QACrC;MACF;IACF,CAAC,CAAC;EACJ;EAEQ+C,YAAYA,CAACtC,WAAmB,EAAE2B,UAA2B,EAAQ;IAC3E;IACA,MAAMY,OAAO,GAAG,SAASC,IAAI,CAACC,GAAG,CAAC,CAAC,IAAIhC,IAAI,CAACiC,MAAM,CAAC,CAAC,EAAE;IACtD,IAAI,CAACC,YAAY,CAACJ,OAAO,EAAEZ,UAAU,CAACnC,QAAQ,EAAE,OAAO,CAAC;EAC1D;EAEQ0C,iBAAiBA,CAACU,YAAoB,EAAQ;IACpD,MAAMjB,UAAU,GAAG,IAAI,CAACzD,KAAK,CAACM,WAAW,CAAC0B,GAAG,CAAC0C,YAAY,CAAC;IAC3D,IAAI,CAACjB,UAAU,EAAE;;IAEjB;IACAA,UAAU,CAAChC,gBAAgB,GAAG,KAAK;IACnCgC,UAAU,CAAC/B,cAAc,GAAG,CAAC;IAC7B+B,UAAU,CAAC9B,aAAa,GAAG,CAAC;;IAE5B;IACAgD,UAAU,CAAC,MAAM;MACf,IAAI,CAAC3E,KAAK,CAACM,WAAW,CAACsE,MAAM,CAACF,YAAY,CAAC;IAC7C,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;EACX;;EAEA;;EAEAD,YAAYA,CAACpD,EAAU,EAAEC,QAAiB,EAAES,aAAqB,EAAQ;IACvE,MAAM8C,MAAsB,GAAG;MAC7BxD,EAAE;MACFC,QAAQ,EAAE;QAAE,GAAGA;MAAS,CAAC;MACzBC,MAAM,EAAE,CAAC;MACTE,gBAAgB,EAAEM,aAAa;MAC/BL,cAAc,EAAE,CAAC;MACjBC,aAAa,EAAE;IACjB,CAAC;IAED,IAAI,CAAC3B,KAAK,CAACO,OAAO,CAACqB,GAAG,CAACP,EAAE,EAAEwD,MAAM,CAAC;EACpC;EAEQ3D,aAAaA,CAAA,EAAS;IAC5B,IAAI,CAAClB,KAAK,CAACO,OAAO,CAAC2B,OAAO,CAAC,CAAC2C,MAAM,EAAExD,EAAE,KAAK;MACzC,IAAI,CAACc,wBAAwB,CAAC0C,MAAM,CAAC;IACvC,CAAC,CAAC;EACJ;;EAEA;;EAEQnC,kBAAkBA,CAAClB,SAAyB,EAAEiB,QAAgB,EAAEH,QAAgB,EAAQ;IAC9F,MAAML,aAAa,GAAGvC,kBAAkB,CAAC8B,SAAS,CAACC,gBAAgB,CAAC;IACpE,IAAI,CAACQ,aAAa,IAAI,CAACA,aAAa,CAAC6C,MAAM,EAAE;;IAE7C;IACA,KAAK,IAAIhC,KAAK,GAAGL,QAAQ,GAAG,CAAC,EAAEK,KAAK,IAAIR,QAAQ,EAAEQ,KAAK,EAAE,EAAE;MACzD,MAAMgC,MAAM,GAAGlF,cAAc,CAAC4B,SAAS,CAACC,gBAAgB,EAAEqB,KAAK,CAAC;MAChE,KAAK,MAAMiC,KAAK,IAAID,MAAM,EAAE;QAC1B,IAAI,CAACjC,qBAAqB,CAACrB,SAAS,CAACH,EAAE,EAAE0D,KAAK,CAAC;MACjD;IACF;EACF;EAEQlC,qBAAqBA,CAACf,WAAmB,EAAEiD,KAAiB,EAAQ;IAC1E,MAAMC,cAA8B,GAAG;MACrCjC,IAAI,EAAE,iBAAiB;MACvBjB,WAAW;MACXiD,KAAK;MACLE,SAAS,EAAE,IAAI,CAACjF,KAAK,CAACQ;IACxB,CAAC;IAED,IAAI,CAACP,UAAU,CAACiF,IAAI,CAACF,cAAc,CAAC;EACtC;EAEQ7D,sBAAsBA,CAAA,EAAS;IACrC,OAAO,IAAI,CAAClB,UAAU,CAACkF,MAAM,GAAG,CAAC,EAAE;MACjC,MAAMJ,KAAK,GAAG,IAAI,CAAC9E,UAAU,CAACmF,KAAK,CAAC,CAAE;MACtC,IAAI,CAACC,oBAAoB,CAACN,KAAK,CAAC;IAClC;EACF;EAEQM,oBAAoBA,CAACN,KAAqB,EAAQ;IACxD,QAAQA,KAAK,CAACA,KAAK,CAAChC,IAAI;MACtB,KAAK,iBAAiB;QACpB,IAAI,CAACuC,qBAAqB,CAACP,KAAK,CAAC;QACjC;MACF,KAAK,SAAS;QACZ,IAAI,CAACQ,aAAa,CAACR,KAAK,CAAC;QACzB;MACF,KAAK,QAAQ;QACX,IAAI,CAACS,YAAY,CAACT,KAAK,CAAC;QACxB;MACF,KAAK,YAAY;QACf,IAAI,CAACU,gBAAgB,CAACV,KAAK,CAAC;QAC5B;MACF,KAAK,aAAa;QAChB,IAAI,CAACW,iBAAiB,CAACX,KAAK,CAAC;QAC7B;MACF,KAAK,UAAU;QACb,IAAI,CAACY,uBAAuB,CAACZ,KAAK,CAAC;QACnC;IACJ;EACF;EAEQO,qBAAqBA,CAACP,KAAqB,EAAQ;IACzD,MAAMvD,SAAS,GAAG,IAAI,CAACxB,KAAK,CAACI,UAAU,CAAC4B,GAAG,CAAC+C,KAAK,CAACjD,WAAW,CAAC;IAC9D,IAAI,CAACN,SAAS,EAAE;IAEhB,MAAMoE,YAAY,GAAG/F,sBAAsB,CAAC2B,SAAS,CAACH,EAAE,CAAC;IACzD,IAAI,CAACuE,YAAY,IAAI,CAACA,YAAY,CAACC,YAAY,EAAE;;IAEjD;IACA,MAAMA,YAAY,GAAGD,YAAY,CAACC,YAAY;IAC9C,MAAMC,gBAAgB,GAAGtE,SAAS,CAACD,MAAM;IAEzC,MAAMwE,kBAA2B,GAAG;MAClCzC,CAAC,EAAE9B,SAAS,CAACF,QAAQ,CAACgC,CAAC,GAAIuC,YAAY,CAACvC,CAAC,GAAGwC,gBAAiB;MAC7DvC,CAAC,EAAE/B,SAAS,CAACF,QAAQ,CAACiC,CAAC,GAAGsC,YAAY,CAACtC;IACzC,CAAC;;IAED;IACA,MAAMG,KAAK,GAAG,IAAI,CAAC,CAAC;IACpB,MAAMR,QAAiB,GAAG;MACxBI,CAAC,EAAEI,KAAK,GAAGoC,gBAAgB;MAC3BvC,CAAC,EAAE;IACL,CAAC;;IAED;IACA,MAAMmB,YAAY,GAAG,cAAcJ,IAAI,CAACC,GAAG,CAAC,CAAC,IAAIhC,IAAI,CAACiC,MAAM,CAAC,CAAC,EAAE;IAChE,IAAI,CAACvB,gBAAgB,CAACyB,YAAY,EAAEqB,kBAAkB,EAAE7C,QAAQ,EAAE1B,SAAS,CAACH,EAAE,CAAC;EACjF;EAEQkE,aAAaA,CAACR,KAAqB,EAAQ;IAAA,IAAAiB,iBAAA;IACjD;IACAC,OAAO,CAACC,GAAG,CAAC,SAAAF,iBAAA,GAAQjB,KAAK,CAACA,KAAK,CAAC/B,IAAI,cAAAgD,iBAAA,uBAAhBA,iBAAA,CAAkBG,KAAK,QAAQpB,KAAK,CAACjD,WAAW,EAAE,CAAC;EACzE;EAEQ0D,YAAYA,CAACT,KAAqB,EAAQ;IAAA,IAAAqB,kBAAA;IAChD,MAAM5E,SAAS,GAAG,IAAI,CAACxB,KAAK,CAACI,UAAU,CAAC4B,GAAG,CAAC+C,KAAK,CAACjD,WAAW,CAAC;IAC9D,IAAI,CAACN,SAAS,EAAE;IAEhB,MAAM6E,QAAQ,GAAG,MAAM/B,IAAI,CAACC,GAAG,CAAC,CAAC,IAAIhC,IAAI,CAACiC,MAAM,CAAC,CAAC,EAAE;IACpD,IAAI,CAACC,YAAY,CAAC4B,QAAQ,EAAE7E,SAAS,CAACF,QAAQ,EAAE,EAAA8E,kBAAA,GAAArB,KAAK,CAACA,KAAK,CAAC/B,IAAI,cAAAoD,kBAAA,uBAAhBA,kBAAA,CAAkBE,KAAK,KAAI,OAAO,CAAC;EACrF;EAEQb,gBAAgBA,CAACV,KAAqB,EAAQ;IAAA,IAAAwB,kBAAA;IACpD;IACAN,OAAO,CAACC,GAAG,CAAC,YAAAK,kBAAA,GAAWxB,KAAK,CAACA,KAAK,CAAC/B,IAAI,cAAAuD,kBAAA,uBAAhBA,kBAAA,CAAkBC,MAAM,SAASzB,KAAK,CAACjD,WAAW,EAAE,CAAC;EAC9E;EAEQ4D,iBAAiBA,CAACX,KAAqB,EAAQ;IAAA,IAAA0B,kBAAA,EAAAC,kBAAA;IACrD;IACAT,OAAO,CAACC,GAAG,CAAC,kBAAAO,kBAAA,GAAiB1B,KAAK,CAACA,KAAK,CAAC/B,IAAI,cAAAyD,kBAAA,uBAAhBA,kBAAA,CAAkBE,SAAS,SAAAD,kBAAA,GAAQ3B,KAAK,CAACA,KAAK,CAAC/B,IAAI,cAAA0D,kBAAA,uBAAhBA,kBAAA,CAAkBE,QAAQ,IAAI,CAAC;EACjG;EAEQjB,uBAAuBA,CAACZ,KAAqB,EAAQ;IAC3D,MAAMvD,SAAS,GAAG,IAAI,CAACxB,KAAK,CAACI,UAAU,CAAC4B,GAAG,CAAC+C,KAAK,CAACjD,WAAW,CAAC;IAC9D,IAAI,CAACN,SAAS,EAAE;;IAEhB;IACA,IAAIA,SAAS,CAACC,gBAAgB,KAAK,MAAM,EAAE;MACzC,IAAI,CAACI,aAAa,CAACkD,KAAK,CAACjD,WAAW,EAAE,MAAM,CAAC;IAC/C;EACF;;EAEA;;EAEAlB,KAAKA,CAAA,EAAS;IACZ,IAAI,CAACT,SAAS,GAAG,IAAI;IACrB,IAAI,CAACD,cAAc,GAAG2G,WAAW,CAACtC,GAAG,CAAC,CAAC;EACzC;EAEAuC,IAAIA,CAAA,EAAS;IACX,IAAI,CAAC3G,SAAS,GAAG,KAAK;EACxB;EAEA4G,QAAQA,CAAA,EAAyB;IAC/B,OAAO;MACL,GAAG,IAAI,CAAC/G,KAAK;MACbI,UAAU,EAAE,IAAIC,GAAG,CAAC,IAAI,CAACL,KAAK,CAACI,UAAU,CAAC;MAC1CE,WAAW,EAAE,IAAID,GAAG,CAAC,IAAI,CAACL,KAAK,CAACM,WAAW,CAAC;MAC5CC,OAAO,EAAE,IAAIF,GAAG,CAAC,IAAI,CAACL,KAAK,CAACO,OAAO;IACrC,CAAC;EACH;;EAEA;EACAyG,YAAYA,CAAC3F,EAAU,EAA8B;IACnD,OAAO,IAAI,CAACrB,KAAK,CAACI,UAAU,CAAC4B,GAAG,CAACX,EAAE,CAAC;EACtC;;EAEA;EACA4F,aAAaA,CAAA,EAAqB;IAChC,OAAOC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACnH,KAAK,CAACI,UAAU,CAACgH,MAAM,CAAC,CAAC,CAAC;EACnD;;EAEA;EACAC,cAAcA,CAAA,EAAsB;IAClC,OAAOH,KAAK,CAACC,IAAI,CAAC,IAAI,CAACnH,KAAK,CAACM,WAAW,CAAC8G,MAAM,CAAC,CAAC,CAAC;EACpD;;EAEA;EACAE,UAAUA,CAAA,EAAqB;IAC7B,OAAOJ,KAAK,CAACC,IAAI,CAAC,IAAI,CAACnH,KAAK,CAACO,OAAO,CAAC6G,MAAM,CAAC,CAAC,CAAC;EAChD;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}